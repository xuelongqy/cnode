var performance = performance || {};
performance.now = function() {
    return performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || Date.now
}();

function Benchmark(a, c, b, d, e, f, g, h, l) {
    this.name = a;
    this.doWarmup = c;
    this.doDeterministic = b;
    this.deterministicIterations = d;
    this.run = e;
    this.Setup = f ? f : function() {};
    this.TearDown = g ? g : function() {};
    this.rmsResult = h ? h : null;
    this.minIterations = l ? l : 32
}

function BenchmarkResult(a, c, b) {
    this.benchmark = a;
    this.time = c;
    this.latency = b
}
BenchmarkResult.prototype.valueOf = function() {
    return this.time
};

function BenchmarkSuite(a, c, b) {
    this.name = a;
    this.reference = c;
    this.benchmarks = b;
    BenchmarkSuite.suites.push(this)
}
BenchmarkSuite.suites = [];
BenchmarkSuite.version = "9";
BenchmarkSuite.config = {
    doWarmup: void 0,
    doDeterministic: void 0
};
alert = function(a) {
    throw "Alert called with argument: " + a;
};
BenchmarkSuite.ResetRNG = function() {
    Math.random = function() {
        var a = 49734321;
        return function() {
            a = a + 2127912214 + (a << 12) & 4294967295;
            a = (a ^ 3345072700 ^ a >>> 19) & 4294967295;
            a = a + 374761393 + (a << 5) & 4294967295;
            a = (a + 3550635116 ^ a << 9) & 4294967295;
            a = a + 4251993797 + (a << 3) & 4294967295;
            a = (a ^ 3042594569 ^ a >>> 16) & 4294967295;
            return (a & 268435455) / 268435456
        }
    }()
};
BenchmarkSuite.RunSuites = function(a, c) {
    function b() {
        for (; d || g < f;) {
            if (d) d = d();
            else {
                var h = e[g++];
                a.NotifyStart && a.NotifyStart(h.name); - 1 < c.indexOf(h.name) ? h.NotifySkipped(a) : d = h.RunStep(a)
            }
            if (d && "undefined" != typeof window && window.setTimeout) {
                window.setTimeout(b, 25);
                return
            }
        }
        a.NotifyScore && (h = BenchmarkSuite.GeometricMean(BenchmarkSuite.scores), h = BenchmarkSuite.FormatScore(100 * h), a.NotifyScore(h))
    }
    c = "undefined" === typeof c ? [] : c;
    var d = null,
        e = BenchmarkSuite.suites,
        f = e.length;
    BenchmarkSuite.scores = [];
    var g =
        0;
    b()
};
BenchmarkSuite.CountBenchmarks = function() {
    for (var a = 0, c = BenchmarkSuite.suites, b = 0; b < c.length; b++) a += c[b].benchmarks.length;
    return a
};
BenchmarkSuite.GeometricMean = function(a) {
    for (var c = 0, b = 0; b < a.length; b++) c += Math.log(a[b]);
    return Math.pow(Math.E, c / a.length)
};
BenchmarkSuite.GeometricMeanTime = function(a) {
    for (var c = 0, b = 0; b < a.length; b++) c += Math.log(a[b].time);
    return Math.pow(Math.E, c / a.length)
};
BenchmarkSuite.GeometricMeanLatency = function(a) {
    for (var c = 0, b = !1, d = 0; d < a.length; d++) 0 != a[d].latency && (c += Math.log(a[d].latency), b = !0);
    return b ? Math.pow(Math.E, c / a.length) : 0
};
BenchmarkSuite.FormatScore = function(a) {
    return 100 < a ? a.toFixed(0) : a.toPrecision(3)
};
BenchmarkSuite.prototype.NotifyStep = function(a) {
    this.results.push(a);
    this.runner.NotifyStep && this.runner.NotifyStep(a.benchmark.name)
};
BenchmarkSuite.prototype.NotifyResult = function() {
    var a = BenchmarkSuite.GeometricMeanTime(this.results),
        a = this.reference[0] / a;
    BenchmarkSuite.scores.push(a);
    this.runner.NotifyResult && (a = BenchmarkSuite.FormatScore(100 * a), this.runner.NotifyResult(this.name, a));
    2 == this.reference.length && (a = BenchmarkSuite.GeometricMeanLatency(this.results), 0 != a && (a = this.reference[1] / a, BenchmarkSuite.scores.push(a), this.runner.NotifyResult && (a = BenchmarkSuite.FormatScore(100 * a), this.runner.NotifyResult(this.name + "Latency",
        a))))
};
BenchmarkSuite.prototype.NotifySkipped = function(a) {
    BenchmarkSuite.scores.push(1);
    a.NotifyResult && a.NotifyResult(this.name, "Skipped")
};
BenchmarkSuite.prototype.NotifyError = function(a) {
    this.runner.NotifyError && this.runner.NotifyError(this.name, a);
    this.runner.NotifyStep && this.runner.NotifyStep(this.name)
};
BenchmarkSuite.prototype.RunSingleBenchmark = function(a, c) {
    function b(b) {
        for (var c = 0, d = new Date, f = 0; e ? f < a.deterministicIterations : 1E3 > c; f++) a.run(), c = new Date - d;
        null != b && (b.runs += f, b.elapsed += c)
    }
    var d = BenchmarkSuite.config,
        e = void 0 !== d.doDeterministic ? d.doDeterministic : a.doDeterministic;
    (void 0 !== d.doWarmup ? d.doWarmup : a.doWarmup) || null != c || (c = {
        runs: 0,
        elapsed: 0
    });
    if (null == c) return b(null), {
        runs: 0,
        elapsed: 0
    };
    b(c);
    if (c.runs < a.minIterations) return c;
    var d = 1E3 * c.elapsed / c.runs,
        f = null != a.rmsResult ? a.rmsResult() :
        0;
    this.NotifyStep(new BenchmarkResult(a, d, f));
    return null
};
BenchmarkSuite.prototype.RunStep = function(a) {
    function c() {
        if (f < e) {
            try {
                g.benchmarks[f].Setup()
            } catch (a) {
                return g.NotifyError(a), null
            }
            return b
        }
        g.NotifyResult();
        return null
    }

    function b() {
        try {
            h = g.RunSingleBenchmark(g.benchmarks[f], h)
        } catch (a) {
            return g.NotifyError(a), null
        }
        return null == h ? d : b()
    }

    function d() {
        try {
            g.benchmarks[f++].TearDown()
        } catch (a) {
            return g.NotifyError(a), null
        }
        return c
    }
    BenchmarkSuite.ResetRNG();
    this.results = [];
    this.runner = a;
    var e = this.benchmarks.length,
        f = 0,
        g = this,
        h;
    return c()
};
var Box2D = {};
(function(a, c) {
    function b() {}!(Object.defineProperty instanceof Function) && Object.prototype.__defineGetter__ instanceof Function && Object.prototype.__defineSetter__ instanceof Function && (Object.defineProperty = function(a, b, c) {
        c.get instanceof Function && a.__defineGetter__(b, c.get);
        c.set instanceof Function && a.__defineSetter__(b, c.set)
    });
    a.inherit = function(a, c) {
        b.prototype = c.prototype;
        a.prototype = new b;
        a.prototype.constructor = a
    };
    a.generateCallback = function(a, b) {
        return function() {
            b.apply(a, arguments)
        }
    };
    a.NVector = function(a) {
        a === c && (a = 0);
        for (var b = Array(a || 0), f = 0; f < a; ++f) b[f] = 0;
        return b
    };
    a.is = function(a, b) {
        return null === a ? !1 : b instanceof Function && a instanceof b || a.constructor.__implements != c && a.constructor.__implements[b] ? !0 : !1
    };
    a.parseUInt = function(a) {
        return Math.abs(parseInt(a))
    }
})(Box2D);
var Vector = Array,
    Vector_a2j_Number = Box2D.NVector;
"undefined" === typeof Box2D && (Box2D = {});
"undefined" === typeof Box2D.Collision && (Box2D.Collision = {});
"undefined" === typeof Box2D.Collision.Shapes && (Box2D.Collision.Shapes = {});
"undefined" === typeof Box2D.Common && (Box2D.Common = {});
"undefined" === typeof Box2D.Common.Math && (Box2D.Common.Math = {});
"undefined" === typeof Box2D.Dynamics && (Box2D.Dynamics = {});
"undefined" === typeof Box2D.Dynamics.Contacts && (Box2D.Dynamics.Contacts = {});
"undefined" === typeof Box2D.Dynamics.Controllers && (Box2D.Dynamics.Controllers = {});
"undefined" === typeof Box2D.Dynamics.Joints && (Box2D.Dynamics.Joints = {});
(function() {
    function a() {
        a.b2AABB.apply(this, arguments)
    }

    function c() {
        c.b2Bound.apply(this, arguments)
    }

    function b() {
        b.b2BoundValues.apply(this, arguments);
        this.constructor === b && this.b2BoundValues.apply(this, arguments)
    }

    function d() {
        d.b2Collision.apply(this, arguments)
    }

    function e() {
        e.b2ContactID.apply(this, arguments);
        this.constructor === e && this.b2ContactID.apply(this, arguments)
    }

    function f() {
        f.b2ContactPoint.apply(this, arguments)
    }

    function g() {
        g.b2Distance.apply(this, arguments)
    }

    function h() {
        h.b2DistanceInput.apply(this,
            arguments)
    }

    function l() {
        l.b2DistanceOutput.apply(this, arguments)
    }

    function m() {
        m.b2DistanceProxy.apply(this, arguments)
    }

    function q() {
        q.b2DynamicTree.apply(this, arguments);
        this.constructor === q && this.b2DynamicTree.apply(this, arguments)
    }

    function p() {
        p.b2DynamicTreeBroadPhase.apply(this, arguments)
    }

    function y() {
        y.b2DynamicTreeNode.apply(this, arguments)
    }

    function A() {
        A.b2DynamicTreePair.apply(this, arguments)
    }

    function B() {
        B.b2Manifold.apply(this, arguments);
        this.constructor === B && this.b2Manifold.apply(this, arguments)
    }

    function K() {
        K.b2ManifoldPoint.apply(this, arguments);
        this.constructor === K && this.b2ManifoldPoint.apply(this, arguments)
    }

    function H() {
        H.b2Point.apply(this, arguments)
    }

    function E() {
        E.b2RayCastInput.apply(this, arguments);
        this.constructor === E && this.b2RayCastInput.apply(this, arguments)
    }

    function M() {
        M.b2RayCastOutput.apply(this, arguments)
    }

    function Xb() {
        Xb.b2Segment.apply(this, arguments)
    }

    function Zb() {
        Zb.b2SeparationFunction.apply(this, arguments)
    }

    function aa() {
        aa.b2Simplex.apply(this, arguments);
        this.constructor ===
            aa && this.b2Simplex.apply(this, arguments)
    }

    function Yb() {
        Yb.b2SimplexCache.apply(this, arguments)
    }

    function $b() {
        $b.b2SimplexVertex.apply(this, arguments)
    }

    function ac() {
        ac.b2TimeOfImpact.apply(this, arguments)
    }

    function bc() {
        bc.b2TOIInput.apply(this, arguments)
    }

    function ec() {
        ec.b2WorldManifold.apply(this, arguments);
        this.constructor === ec && this.b2WorldManifold.apply(this, arguments)
    }

    function jc() {
        jc.ClipVertex.apply(this, arguments)
    }

    function cc() {
        cc.Features.apply(this, arguments)
    }

    function dc() {
        dc.b2CircleShape.apply(this,
            arguments);
        this.constructor === dc && this.b2CircleShape.apply(this, arguments)
    }

    function gc() {
        gc.b2EdgeChainDef.apply(this, arguments);
        this.constructor === gc && this.b2EdgeChainDef.apply(this, arguments)
    }

    function hc() {
        hc.b2EdgeShape.apply(this, arguments);
        this.constructor === hc && this.b2EdgeShape.apply(this, arguments)
    }

    function fc() {
        fc.b2MassData.apply(this, arguments)
    }

    function kc() {
        kc.b2PolygonShape.apply(this, arguments);
        this.constructor === kc && this.b2PolygonShape.apply(this, arguments)
    }

    function lc() {
        lc.b2Shape.apply(this,
            arguments);
        this.constructor === lc && this.b2Shape.apply(this, arguments)
    }

    function mc() {
        mc.b2Color.apply(this, arguments);
        this.constructor === mc && this.b2Color.apply(this, arguments)
    }

    function nc() {
        nc.b2Settings.apply(this, arguments)
    }

    function oc() {
        oc.b2Mat22.apply(this, arguments);
        this.constructor === oc && this.b2Mat22.apply(this, arguments)
    }

    function qc() {
        qc.b2Mat33.apply(this, arguments);
        this.constructor === qc && this.b2Mat33.apply(this, arguments)
    }

    function pc() {
        pc.b2Math.apply(this, arguments)
    }

    function rc() {
        rc.b2Sweep.apply(this,
            arguments)
    }

    function uc() {
        uc.b2Transform.apply(this, arguments);
        this.constructor === uc && this.b2Transform.apply(this, arguments)
    }

    function wc() {
        wc.b2Vec2.apply(this, arguments);
        this.constructor === wc && this.b2Vec2.apply(this, arguments)
    }

    function sc() {
        sc.b2Vec3.apply(this, arguments);
        this.constructor === sc && this.b2Vec3.apply(this, arguments)
    }

    function xc() {
        xc.b2Body.apply(this, arguments);
        this.constructor === xc && this.b2Body.apply(this, arguments)
    }

    function tc() {
        tc.b2BodyDef.apply(this, arguments);
        this.constructor ===
            tc && this.b2BodyDef.apply(this, arguments)
    }

    function yc() {
        yc.b2ContactFilter.apply(this, arguments)
    }

    function Ac() {
        Ac.b2ContactImpulse.apply(this, arguments)
    }

    function zc() {
        zc.b2ContactListener.apply(this, arguments)
    }

    function Cc() {
        Cc.b2ContactManager.apply(this, arguments);
        this.constructor === Cc && this.b2ContactManager.apply(this, arguments)
    }

    function Bc() {
        Bc.b2DebugDraw.apply(this, arguments);
        this.constructor === Bc && this.b2DebugDraw.apply(this, arguments)
    }

    function ud() {
        ud.b2DestructionListener.apply(this, arguments)
    }

    function Dc() {
        Dc.b2FilterData.apply(this, arguments)
    }

    function Cd() {
        Cd.b2Fixture.apply(this, arguments);
        this.constructor === Cd && this.b2Fixture.apply(this, arguments)
    }

    function Dd() {
        Dd.b2FixtureDef.apply(this, arguments);
        this.constructor === Dd && this.b2FixtureDef.apply(this, arguments)
    }

    function Ed() {
        Ed.b2Island.apply(this, arguments);
        this.constructor === Ed && this.b2Island.apply(this, arguments)
    }

    function Xd() {
        Xd.b2TimeStep.apply(this, arguments)
    }

    function Fd() {
        Fd.b2World.apply(this, arguments);
        this.constructor === Fd &&
            this.b2World.apply(this, arguments)
    }

    function Yd() {
        Yd.b2CircleContact.apply(this, arguments)
    }

    function Gd() {
        Gd.b2Contact.apply(this, arguments);
        this.constructor === Gd && this.b2Contact.apply(this, arguments)
    }

    function Hd() {
        Hd.b2ContactConstraint.apply(this, arguments);
        this.constructor === Hd && this.b2ContactConstraint.apply(this, arguments)
    }

    function Zd() {
        Zd.b2ContactConstraintPoint.apply(this, arguments)
    }

    function $d() {
        $d.b2ContactEdge.apply(this, arguments)
    }

    function Id() {
        Id.b2ContactFactory.apply(this, arguments);
        this.constructor === Id && this.b2ContactFactory.apply(this, arguments)
    }

    function ae() {
        ae.b2ContactRegister.apply(this, arguments)
    }

    function be() {
        be.b2ContactResult.apply(this, arguments)
    }

    function vd() {
        vd.b2ContactSolver.apply(this, arguments);
        this.constructor === vd && this.b2ContactSolver.apply(this, arguments)
    }

    function ce() {
        ce.b2EdgeAndCircleContact.apply(this, arguments)
    }

    function Jd() {
        Jd.b2NullContact.apply(this, arguments);
        this.constructor === Jd && this.b2NullContact.apply(this, arguments)
    }

    function de() {
        de.b2PolyAndCircleContact.apply(this,
            arguments)
    }

    function ee() {
        ee.b2PolyAndEdgeContact.apply(this, arguments)
    }

    function fe() {
        fe.b2PolygonContact.apply(this, arguments)
    }

    function Kd() {
        Kd.b2PositionSolverManifold.apply(this, arguments);
        this.constructor === Kd && this.b2PositionSolverManifold.apply(this, arguments)
    }

    function ge() {
        ge.b2BuoyancyController.apply(this, arguments)
    }

    function he() {
        he.b2ConstantAccelController.apply(this, arguments)
    }

    function ie() {
        ie.b2ConstantForceController.apply(this, arguments)
    }

    function je() {
        je.b2Controller.apply(this, arguments)
    }

    function ke() {
        ke.b2ControllerEdge.apply(this, arguments)
    }

    function le() {
        le.b2GravityController.apply(this, arguments)
    }

    function Ld() {
        Ld.b2TensorDampingController.apply(this, arguments)
    }

    function ld() {
        ld.b2DistanceJoint.apply(this, arguments);
        this.constructor === ld && this.b2DistanceJoint.apply(this, arguments)
    }

    function md() {
        md.b2DistanceJointDef.apply(this, arguments);
        this.constructor === md && this.b2DistanceJointDef.apply(this, arguments)
    }

    function wd() {
        wd.b2FrictionJoint.apply(this, arguments);
        this.constructor ===
            wd && this.b2FrictionJoint.apply(this, arguments)
    }

    function jd() {
        jd.b2FrictionJointDef.apply(this, arguments);
        this.constructor === jd && this.b2FrictionJointDef.apply(this, arguments)
    }

    function xd() {
        xd.b2GearJoint.apply(this, arguments);
        this.constructor === xd && this.b2GearJoint.apply(this, arguments)
    }

    function yd() {
        yd.b2GearJointDef.apply(this, arguments);
        this.constructor === yd && this.b2GearJointDef.apply(this, arguments)
    }

    function me() {
        me.b2Jacobian.apply(this, arguments)
    }

    function Md() {
        Md.b2Joint.apply(this, arguments);
        this.constructor === Md && this.b2Joint.apply(this, arguments)
    }

    function Nd() {
        Nd.b2JointDef.apply(this, arguments);
        this.constructor === Nd && this.b2JointDef.apply(this, arguments)
    }

    function Od() {
        Od.b2JointEdge.apply(this, arguments)
    }

    function Pd() {
        Pd.b2LineJoint.apply(this, arguments);
        this.constructor === Pd && this.b2LineJoint.apply(this, arguments)
    }

    function zd() {
        zd.b2LineJointDef.apply(this, arguments);
        this.constructor === zd && this.b2LineJointDef.apply(this, arguments)
    }

    function Qd() {
        Qd.b2MouseJoint.apply(this, arguments);
        this.constructor === Qd && this.b2MouseJoint.apply(this, arguments)
    }

    function Ad() {
        Ad.b2MouseJointDef.apply(this, arguments);
        this.constructor === Ad && this.b2MouseJointDef.apply(this, arguments)
    }

    function Rd() {
        Rd.b2PrismaticJoint.apply(this, arguments);
        this.constructor === Rd && this.b2PrismaticJoint.apply(this, arguments)
    }

    function kd() {
        kd.b2PrismaticJointDef.apply(this, arguments);
        this.constructor === kd && this.b2PrismaticJointDef.apply(this, arguments)
    }

    function nd() {
        nd.b2PulleyJoint.apply(this, arguments);
        this.constructor ===
            nd && this.b2PulleyJoint.apply(this, arguments)
    }

    function ed() {
        ed.b2PulleyJointDef.apply(this, arguments);
        this.constructor === ed && this.b2PulleyJointDef.apply(this, arguments)
    }

    function Gc() {
        Gc.b2RevoluteJoint.apply(this, arguments);
        this.constructor === Gc && this.b2RevoluteJoint.apply(this, arguments)
    }

    function od() {
        od.b2RevoluteJointDef.apply(this, arguments);
        this.constructor === od && this.b2RevoluteJointDef.apply(this, arguments)
    }

    function Ic() {
        Ic.b2WeldJoint.apply(this, arguments);
        this.constructor === Ic && this.b2WeldJoint.apply(this,
            arguments)
    }

    function ad() {
        ad.b2WeldJointDef.apply(this, arguments);
        this.constructor === ad && this.b2WeldJointDef.apply(this, arguments)
    }
    Box2D.Collision.IBroadPhase = "Box2D.Collision.IBroadPhase";
    Box2D.Collision.b2AABB = a;
    Box2D.Collision.b2Bound = c;
    Box2D.Collision.b2BoundValues = b;
    Box2D.Collision.b2Collision = d;
    Box2D.Collision.b2ContactID = e;
    Box2D.Collision.b2ContactPoint = f;
    Box2D.Collision.b2Distance = g;
    Box2D.Collision.b2DistanceInput = h;
    Box2D.Collision.b2DistanceOutput = l;
    Box2D.Collision.b2DistanceProxy = m;
    Box2D.Collision.b2DynamicTree =
        q;
    Box2D.Collision.b2DynamicTreeBroadPhase = p;
    Box2D.Collision.b2DynamicTreeNode = y;
    Box2D.Collision.b2DynamicTreePair = A;
    Box2D.Collision.b2Manifold = B;
    Box2D.Collision.b2ManifoldPoint = K;
    Box2D.Collision.b2Point = H;
    Box2D.Collision.b2RayCastInput = E;
    Box2D.Collision.b2RayCastOutput = M;
    Box2D.Collision.b2Segment = Xb;
    Box2D.Collision.b2SeparationFunction = Zb;
    Box2D.Collision.b2Simplex = aa;
    Box2D.Collision.b2SimplexCache = Yb;
    Box2D.Collision.b2SimplexVertex = $b;
    Box2D.Collision.b2TimeOfImpact = ac;
    Box2D.Collision.b2TOIInput = bc;
    Box2D.Collision.b2WorldManifold = ec;
    Box2D.Collision.ClipVertex = jc;
    Box2D.Collision.Features = cc;
    Box2D.Collision.Shapes.b2CircleShape = dc;
    Box2D.Collision.Shapes.b2EdgeChainDef = gc;
    Box2D.Collision.Shapes.b2EdgeShape = hc;
    Box2D.Collision.Shapes.b2MassData = fc;
    Box2D.Collision.Shapes.b2PolygonShape = kc;
    Box2D.Collision.Shapes.b2Shape = lc;
    Box2D.Common.b2internal = "Box2D.Common.b2internal";
    Box2D.Common.b2Color = mc;
    Box2D.Common.b2Settings = nc;
    Box2D.Common.Math.b2Mat22 = oc;
    Box2D.Common.Math.b2Mat33 = qc;
    Box2D.Common.Math.b2Math =
        pc;
    Box2D.Common.Math.b2Sweep = rc;
    Box2D.Common.Math.b2Transform = uc;
    Box2D.Common.Math.b2Vec2 = wc;
    Box2D.Common.Math.b2Vec3 = sc;
    Box2D.Dynamics.b2Body = xc;
    Box2D.Dynamics.b2BodyDef = tc;
    Box2D.Dynamics.b2ContactFilter = yc;
    Box2D.Dynamics.b2ContactImpulse = Ac;
    Box2D.Dynamics.b2ContactListener = zc;
    Box2D.Dynamics.b2ContactManager = Cc;
    Box2D.Dynamics.b2DebugDraw = Bc;
    Box2D.Dynamics.b2DestructionListener = ud;
    Box2D.Dynamics.b2FilterData = Dc;
    Box2D.Dynamics.b2Fixture = Cd;
    Box2D.Dynamics.b2FixtureDef = Dd;
    Box2D.Dynamics.b2Island = Ed;
    Box2D.Dynamics.b2TimeStep = Xd;
    Box2D.Dynamics.b2World = Fd;
    Box2D.Dynamics.Contacts.b2CircleContact = Yd;
    Box2D.Dynamics.Contacts.b2Contact = Gd;
    Box2D.Dynamics.Contacts.b2ContactConstraint = Hd;
    Box2D.Dynamics.Contacts.b2ContactConstraintPoint = Zd;
    Box2D.Dynamics.Contacts.b2ContactEdge = $d;
    Box2D.Dynamics.Contacts.b2ContactFactory = Id;
    Box2D.Dynamics.Contacts.b2ContactRegister = ae;
    Box2D.Dynamics.Contacts.b2ContactResult = be;
    Box2D.Dynamics.Contacts.b2ContactSolver = vd;
    Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = ce;
    Box2D.Dynamics.Contacts.b2NullContact =
        Jd;
    Box2D.Dynamics.Contacts.b2PolyAndCircleContact = de;
    Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = ee;
    Box2D.Dynamics.Contacts.b2PolygonContact = fe;
    Box2D.Dynamics.Contacts.b2PositionSolverManifold = Kd;
    Box2D.Dynamics.Controllers.b2BuoyancyController = ge;
    Box2D.Dynamics.Controllers.b2ConstantAccelController = he;
    Box2D.Dynamics.Controllers.b2ConstantForceController = ie;
    Box2D.Dynamics.Controllers.b2Controller = je;
    Box2D.Dynamics.Controllers.b2ControllerEdge = ke;
    Box2D.Dynamics.Controllers.b2GravityController = le;
    Box2D.Dynamics.Controllers.b2TensorDampingController =
        Ld;
    Box2D.Dynamics.Joints.b2DistanceJoint = ld;
    Box2D.Dynamics.Joints.b2DistanceJointDef = md;
    Box2D.Dynamics.Joints.b2FrictionJoint = wd;
    Box2D.Dynamics.Joints.b2FrictionJointDef = jd;
    Box2D.Dynamics.Joints.b2GearJoint = xd;
    Box2D.Dynamics.Joints.b2GearJointDef = yd;
    Box2D.Dynamics.Joints.b2Jacobian = me;
    Box2D.Dynamics.Joints.b2Joint = Md;
    Box2D.Dynamics.Joints.b2JointDef = Nd;
    Box2D.Dynamics.Joints.b2JointEdge = Od;
    Box2D.Dynamics.Joints.b2LineJoint = Pd;
    Box2D.Dynamics.Joints.b2LineJointDef = zd;
    Box2D.Dynamics.Joints.b2MouseJoint =
        Qd;
    Box2D.Dynamics.Joints.b2MouseJointDef = Ad;
    Box2D.Dynamics.Joints.b2PrismaticJoint = Rd;
    Box2D.Dynamics.Joints.b2PrismaticJointDef = kd;
    Box2D.Dynamics.Joints.b2PulleyJoint = nd;
    Box2D.Dynamics.Joints.b2PulleyJointDef = ed;
    Box2D.Dynamics.Joints.b2RevoluteJoint = Gc;
    Box2D.Dynamics.Joints.b2RevoluteJointDef = od;
    Box2D.Dynamics.Joints.b2WeldJoint = Ic;
    Box2D.Dynamics.Joints.b2WeldJointDef = ad
})();
Box2D.postDefs = [];
(function() {
    var a = Box2D.Collision.Shapes.b2CircleShape,
        c = Box2D.Collision.Shapes.b2PolygonShape,
        b = Box2D.Collision.Shapes.b2Shape,
        d = Box2D.Common.b2Settings,
        e = Box2D.Common.Math.b2Math,
        f = Box2D.Common.Math.b2Sweep,
        g = Box2D.Common.Math.b2Transform,
        h = Box2D.Common.Math.b2Vec2,
        l = Box2D.Collision.b2AABB,
        m = Box2D.Collision.b2Bound,
        q = Box2D.Collision.b2BoundValues,
        p = Box2D.Collision.b2Collision,
        y = Box2D.Collision.b2ContactID,
        A = Box2D.Collision.b2ContactPoint,
        B = Box2D.Collision.b2Distance,
        K = Box2D.Collision.b2DistanceInput,
        H = Box2D.Collision.b2DistanceOutput,
        E = Box2D.Collision.b2DistanceProxy,
        M = Box2D.Collision.b2DynamicTree,
        Xb = Box2D.Collision.b2DynamicTreeBroadPhase,
        Zb = Box2D.Collision.b2DynamicTreeNode,
        aa = Box2D.Collision.b2DynamicTreePair,
        Yb = Box2D.Collision.b2Manifold,
        $b = Box2D.Collision.b2ManifoldPoint,
        ac = Box2D.Collision.b2Point,
        bc = Box2D.Collision.b2RayCastInput,
        ec = Box2D.Collision.b2RayCastOutput,
        jc = Box2D.Collision.b2Segment,
        cc = Box2D.Collision.b2SeparationFunction,
        dc = Box2D.Collision.b2Simplex,
        gc = Box2D.Collision.b2SimplexCache,
        hc = Box2D.Collision.b2SimplexVertex,
        fc = Box2D.Collision.b2TimeOfImpact,
        kc = Box2D.Collision.b2TOIInput,
        lc = Box2D.Collision.b2WorldManifold,
        mc = Box2D.Collision.ClipVertex,
        nc = Box2D.Collision.Features,
        oc = Box2D.Collision.IBroadPhase;
    l.b2AABB = function() {
        this.lowerBound = new h;
        this.upperBound = new h
    };
    l.prototype.IsValid = function() {
        var a = this.upperBound.y - this.lowerBound.y;
        return 0 <= this.upperBound.x - this.lowerBound.x && 0 <= a && this.lowerBound.IsValid() && this.upperBound.IsValid()
    };
    l.prototype.GetCenter = function() {
        return new h((this.lowerBound.x +
            this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2)
    };
    l.prototype.GetExtents = function() {
        return new h((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2)
    };
    l.prototype.Contains = function(a) {
        return this.lowerBound.x <= a.lowerBound.x && this.lowerBound.y <= a.lowerBound.y && a.upperBound.x <= this.upperBound.x && a.upperBound.y <= this.upperBound.y
    };
    l.prototype.RayCast = function(a, b) {
        var c = -Number.MAX_VALUE,
            d = Number.MAX_VALUE,
            e = b.p1.x,
            f = b.p1.y,
            g = b.p2.x - b.p1.x,
            h = b.p2.y - b.p1.y,
            l =
            Math.abs(h),
            m = a.normal,
            p;
        if (Math.abs(g) < Number.MIN_VALUE) {
            if (e < this.lowerBound.x || this.upperBound.x < e) return !1
        } else if (g = 1 / g, p = (this.lowerBound.x - e) * g, g *= this.upperBound.x - e, e = -1, p > g && (e = p, p = g, g = e, e = 1), p > c && (m.x = e, m.y = 0, c = p), d = Math.min(d, g), c > d) return !1;
        if (l < Number.MIN_VALUE) {
            if (f < this.lowerBound.y || this.upperBound.y < f) return !1
        } else if (g = 1 / h, p = (this.lowerBound.y - f) * g, g *= this.upperBound.y - f, e = -1, p > g && (e = p, p = g, g = e, e = 1), p > c && (m.y = e, m.x = 0, c = p), d = Math.min(d, g), c > d) return !1;
        a.fraction = c;
        return !0
    };
    l.prototype.TestOverlap =
        function(a) {
            var b = a.lowerBound.y - this.upperBound.y,
                c = this.lowerBound.y - a.upperBound.y;
            return 0 < a.lowerBound.x - this.upperBound.x || 0 < b || 0 < this.lowerBound.x - a.upperBound.x || 0 < c ? !1 : !0
        };
    l.Combine = function(a, b) {
        var c = new l;
        c.Combine(a, b);
        return c
    };
    l.prototype.Combine = function(a, b) {
        this.lowerBound.x = Math.min(a.lowerBound.x, b.lowerBound.x);
        this.lowerBound.y = Math.min(a.lowerBound.y, b.lowerBound.y);
        this.upperBound.x = Math.max(a.upperBound.x, b.upperBound.x);
        this.upperBound.y = Math.max(a.upperBound.y, b.upperBound.y)
    };
    m.b2Bound = function() {};
    m.prototype.IsLower = function() {
        return 0 == (this.value & 1)
    };
    m.prototype.IsUpper = function() {
        return 1 == (this.value & 1)
    };
    m.prototype.Swap = function(a) {
        var b = this.value,
            c = this.proxy,
            d = this.stabbingCount;
        this.value = a.value;
        this.proxy = a.proxy;
        this.stabbingCount = a.stabbingCount;
        a.value = b;
        a.proxy = c;
        a.stabbingCount = d
    };
    q.b2BoundValues = function() {};
    q.prototype.b2BoundValues = function() {
        this.lowerValues = new Vector_a2j_Number;
        this.lowerValues[0] = 0;
        this.lowerValues[1] = 0;
        this.upperValues = new Vector_a2j_Number;
        this.upperValues[0] = 0;
        this.upperValues[1] = 0
    };
    p.b2Collision = function() {};
    p.ClipSegmentToLine = function(a, b, c, d) {
        void 0 === d && (d = 0);
        var e, f = 0;
        e = b[0];
        var g = e.v;
        e = b[1];
        var h = e.v,
            l = c.x * g.x + c.y * g.y - d;
        e = c.x * h.x + c.y * h.y - d;
        0 >= l && a[f++].Set(b[0]);
        0 >= e && a[f++].Set(b[1]);
        0 > l * e && (c = l / (l - e), e = a[f], e = e.v, e.x = g.x + c * (h.x - g.x), e.y = g.y + c * (h.y - g.y), e = a[f], e.id = (0 < l ? b[0] : b[1]).id, ++f);
        return f
    };
    p.EdgeSeparation = function(a, b, c, d, e) {
        void 0 === c && (c = 0);
        parseInt(a.m_vertexCount);
        var f = a.m_vertices;
        a = a.m_normals;
        var g = parseInt(d.m_vertexCount),
            h = d.m_vertices,
            l, m;
        l = b.R;
        m = a[c];
        a = l.col1.x * m.x + l.col2.x * m.y;
        d = l.col1.y * m.x + l.col2.y * m.y;
        l = e.R;
        var p = l.col1.x * a + l.col1.y * d;
        l = l.col2.x * a + l.col2.y * d;
        for (var q = 0, y = Number.MAX_VALUE, A = 0; A < g; ++A) m = h[A], m = m.x * p + m.y * l, m < y && (y = m, q = A);
        m = f[c];
        l = b.R;
        c = b.position.x + (l.col1.x * m.x + l.col2.x * m.y);
        b = b.position.y + (l.col1.y * m.x + l.col2.y * m.y);
        m = h[q];
        l = e.R;
        f = e.position.x + (l.col1.x * m.x + l.col2.x * m.y);
        e = e.position.y + (l.col1.y * m.x + l.col2.y * m.y);
        return (f - c) * a + (e - b) * d
    };
    p.FindMaxSeparation = function(a, b, c, d, e) {
        var f = parseInt(b.m_vertexCount),
            g = b.m_normals,
            h, l;
        l = e.R;
        h = d.m_centroid;
        var m = e.position.x + (l.col1.x * h.x + l.col2.x * h.y),
            q = e.position.y + (l.col1.y * h.x + l.col2.y * h.y);
        l = c.R;
        h = b.m_centroid;
        m -= c.position.x + (l.col1.x * h.x + l.col2.x * h.y);
        q -= c.position.y + (l.col1.y * h.x + l.col2.y * h.y);
        l = m * c.R.col1.x + q * c.R.col1.y;
        for (var q = m * c.R.col2.x + q * c.R.col2.y, m = 0, y = -Number.MAX_VALUE, A = 0; A < f; ++A) h = g[A], h = h.x * l + h.y * q, h > y && (y = h, m = A);
        g = p.EdgeSeparation(b, c, m, d, e);
        h = parseInt(0 <= m - 1 ? m - 1 : f - 1);
        l = p.EdgeSeparation(b, c, h, d, e);
        var q = parseInt(m + 1 < f ? m + 1 : 0),
            y = p.EdgeSeparation(b,
                c, q, d, e),
            B;
        if (l > g && l > y) B = -1, A = h, h = l;
        else if (y > g) B = 1, A = q, h = y;
        else return a[0] = m, g;
        for (;;)
            if (m = -1 == B ? 0 <= A - 1 ? A - 1 : f - 1 : A + 1 < f ? A + 1 : 0, g = p.EdgeSeparation(b, c, m, d, e), g > h) A = m, h = g;
            else break;
        a[0] = A;
        return h
    };
    p.FindIncidentEdge = function(a, b, c, d, e, f) {
        void 0 === d && (d = 0);
        parseInt(b.m_vertexCount);
        var g = b.m_normals,
            h = parseInt(e.m_vertexCount);
        b = e.m_vertices;
        e = e.m_normals;
        var l;
        l = c.R;
        c = g[d];
        var g = l.col1.x * c.x + l.col2.x * c.y,
            m = l.col1.y * c.x + l.col2.y * c.y;
        l = f.R;
        c = l.col1.x * g + l.col1.y * m;
        m = l.col2.x * g + l.col2.y * m;
        g = c;
        l = 0;
        for (var p =
                Number.MAX_VALUE, q = 0; q < h; ++q) c = e[q], c = g * c.x + m * c.y, c < p && (p = c, l = q);
        e = parseInt(l);
        g = parseInt(e + 1 < h ? e + 1 : 0);
        h = a[0];
        c = b[e];
        l = f.R;
        h.v.x = f.position.x + (l.col1.x * c.x + l.col2.x * c.y);
        h.v.y = f.position.y + (l.col1.y * c.x + l.col2.y * c.y);
        h.id.features.referenceEdge = d;
        h.id.features.incidentEdge = e;
        h.id.features.incidentVertex = 0;
        h = a[1];
        c = b[g];
        l = f.R;
        h.v.x = f.position.x + (l.col1.x * c.x + l.col2.x * c.y);
        h.v.y = f.position.y + (l.col1.y * c.x + l.col2.y * c.y);
        h.id.features.referenceEdge = d;
        h.id.features.incidentEdge = g;
        h.id.features.incidentVertex =
            1
    };
    p.MakeClipPointVector = function() {
        var a = new Vector(2);
        a[0] = new mc;
        a[1] = new mc;
        return a
    };
    p.CollidePolygons = function(a, b, c, e, f) {
        var g;
        a.m_pointCount = 0;
        var h = b.m_radius + e.m_radius;
        p.s_edgeAO[0] = 0;
        var l = p.FindMaxSeparation(p.s_edgeAO, b, c, e, f);
        g = p.s_edgeAO[0];
        if (!(l > h)) {
            var m;
            p.s_edgeBO[0] = 0;
            var q = p.FindMaxSeparation(p.s_edgeBO, e, f, b, c);
            m = p.s_edgeBO[0];
            if (!(q > h)) {
                var y, A;
                q > .98 * l + .001 ? (l = e, e = b, b = f, y = m, a.m_type = Yb.e_faceB, A = 1) : (l = b, b = c, c = f, y = g, a.m_type = Yb.e_faceA, A = 0);
                g = p.s_incidentEdge;
                p.FindIncidentEdge(g,
                    l, b, y, e, c);
                m = parseInt(l.m_vertexCount);
                f = l.m_vertices;
                var l = f[y],
                    B;
                B = y + 1 < m ? f[parseInt(y + 1)] : f[0];
                y = p.s_localTangent;
                y.Set(B.x - l.x, B.y - l.y);
                y.Normalize();
                f = p.s_localNormal;
                f.x = y.y;
                f.y = -y.x;
                e = p.s_planePoint;
                e.Set(.5 * (l.x + B.x), .5 * (l.y + B.y));
                q = p.s_tangent;
                m = b.R;
                q.x = m.col1.x * y.x + m.col2.x * y.y;
                q.y = m.col1.y * y.x + m.col2.y * y.y;
                var H = p.s_tangent2;
                H.x = -q.x;
                H.y = -q.y;
                y = p.s_normal;
                y.x = q.y;
                y.y = -q.x;
                var E = p.s_v11,
                    M = p.s_v12;
                E.x = b.position.x + (m.col1.x * l.x + m.col2.x * l.y);
                E.y = b.position.y + (m.col1.y * l.x + m.col2.y * l.y);
                M.x =
                    b.position.x + (m.col1.x * B.x + m.col2.x * B.y);
                M.y = b.position.y + (m.col1.y * B.x + m.col2.y * B.y);
                b = y.x * E.x + y.y * E.y;
                m = q.x * M.x + q.y * M.y + h;
                B = p.s_clipPoints1;
                l = p.s_clipPoints2;
                M = p.ClipSegmentToLine(B, g, H, -q.x * E.x - q.y * E.y + h);
                if (!(2 > M || (M = p.ClipSegmentToLine(l, B, q, m), 2 > M))) {
                    a.m_localPlaneNormal.SetV(f);
                    a.m_localPoint.SetV(e);
                    for (e = f = 0; e < d.b2_maxManifoldPoints; ++e) g = l[e], y.x * g.v.x + y.y * g.v.y - b <= h && (q = a.m_points[f], m = c.R, H = g.v.x - c.position.x, E = g.v.y - c.position.y, q.m_localPoint.x = H * m.col1.x + E * m.col1.y, q.m_localPoint.y =
                        H * m.col2.x + E * m.col2.y, q.m_id.Set(g.id), q.m_id.features.flip = A, ++f);
                    a.m_pointCount = f
                }
            }
        }
    };
    p.CollideCircles = function(a, b, c, d, e) {
        a.m_pointCount = 0;
        var f, g;
        f = c.R;
        g = b.m_p;
        var h = c.position.x + (f.col1.x * g.x + f.col2.x * g.y);
        c = c.position.y + (f.col1.y * g.x + f.col2.y * g.y);
        f = e.R;
        g = d.m_p;
        h = e.position.x + (f.col1.x * g.x + f.col2.x * g.y) - h;
        e = e.position.y + (f.col1.y * g.x + f.col2.y * g.y) - c;
        f = b.m_radius + d.m_radius;
        h * h + e * e > f * f || (a.m_type = Yb.e_circles, a.m_localPoint.SetV(b.m_p), a.m_localPlaneNormal.SetZero(), a.m_pointCount = 1, a.m_points[0].m_localPoint.SetV(d.m_p),
            a.m_points[0].m_id.key = 0)
    };
    p.CollidePolygonAndCircle = function(a, b, c, d, e) {
        var f;
        a.m_pointCount = 0;
        var g, h, l;
        l = e.R;
        h = d.m_p;
        var m = e.position.y + (l.col1.y * h.x + l.col2.y * h.y);
        f = e.position.x + (l.col1.x * h.x + l.col2.x * h.y) - c.position.x;
        g = m - c.position.y;
        l = c.R;
        c = f * l.col1.x + g * l.col1.y;
        l = f * l.col2.x + g * l.col2.y;
        var p = 0,
            m = -Number.MAX_VALUE;
        e = b.m_radius + d.m_radius;
        var q = parseInt(b.m_vertexCount),
            y = b.m_vertices;
        b = b.m_normals;
        for (var A = 0; A < q; ++A) {
            h = y[A];
            f = c - h.x;
            g = l - h.y;
            h = b[A];
            f = h.x * f + h.y * g;
            if (f > e) return;
            f > m && (m = f, p = A)
        }
        f =
            parseInt(p);
        g = parseInt(f + 1 < q ? f + 1 : 0);
        h = y[f];
        y = y[g];
        if (m < Number.MIN_VALUE) a.m_pointCount = 1, a.m_type = Yb.e_faceA, a.m_localPlaneNormal.SetV(b[p]), a.m_localPoint.x = .5 * (h.x + y.x), a.m_localPoint.y = .5 * (h.y + y.y);
        else if (m = (c - y.x) * (h.x - y.x) + (l - y.y) * (h.y - y.y), 0 >= (c - h.x) * (y.x - h.x) + (l - h.y) * (y.y - h.y)) {
            if ((c - h.x) * (c - h.x) + (l - h.y) * (l - h.y) > e * e) return;
            a.m_pointCount = 1;
            a.m_type = Yb.e_faceA;
            a.m_localPlaneNormal.x = c - h.x;
            a.m_localPlaneNormal.y = l - h.y;
            a.m_localPlaneNormal.Normalize();
            a.m_localPoint.SetV(h)
        } else if (0 >= m) {
            if ((c -
                    y.x) * (c - y.x) + (l - y.y) * (l - y.y) > e * e) return;
            a.m_pointCount = 1;
            a.m_type = Yb.e_faceA;
            a.m_localPlaneNormal.x = c - y.x;
            a.m_localPlaneNormal.y = l - y.y;
            a.m_localPlaneNormal.Normalize();
            a.m_localPoint.SetV(y)
        } else {
            p = .5 * (h.x + y.x);
            h = .5 * (h.y + y.y);
            m = (c - p) * b[f].x + (l - h) * b[f].y;
            if (m > e) return;
            a.m_pointCount = 1;
            a.m_type = Yb.e_faceA;
            a.m_localPlaneNormal.x = b[f].x;
            a.m_localPlaneNormal.y = b[f].y;
            a.m_localPlaneNormal.Normalize();
            a.m_localPoint.Set(p, h)
        }
        a.m_points[0].m_localPoint.SetV(d.m_p);
        a.m_points[0].m_id.key = 0
    };
    p.TestOverlap =
        function(a, b) {
            var c = b.lowerBound,
                d = a.upperBound,
                e = c.x - d.x,
                f = c.y - d.y,
                c = a.lowerBound,
                d = b.upperBound,
                g = c.y - d.y;
            return 0 < e || 0 < f || 0 < c.x - d.x || 0 < g ? !1 : !0
        };
    Box2D.postDefs.push(function() {
        Box2D.Collision.b2Collision.s_incidentEdge = p.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_clipPoints1 = p.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_clipPoints2 = p.MakeClipPointVector();
        Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
        Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
        Box2D.Collision.b2Collision.s_localTangent = new h;
        Box2D.Collision.b2Collision.s_localNormal = new h;
        Box2D.Collision.b2Collision.s_planePoint = new h;
        Box2D.Collision.b2Collision.s_normal = new h;
        Box2D.Collision.b2Collision.s_tangent = new h;
        Box2D.Collision.b2Collision.s_tangent2 = new h;
        Box2D.Collision.b2Collision.s_v11 = new h;
        Box2D.Collision.b2Collision.s_v12 = new h;
        Box2D.Collision.b2Collision.b2CollidePolyTempVec = new h;
        Box2D.Collision.b2Collision.b2_nullFeature = 255
    });
    y.b2ContactID = function() {
        this.features = new nc
    };
    y.prototype.b2ContactID = function() {
        this.features._m_id = this
    };
    y.prototype.Set = function(a) {
        this.key = a._key
    };
    y.prototype.Copy = function() {
        var a = new y;
        a.key = this.key;
        return a
    };
    Object.defineProperty(y.prototype, "key", {
        enumerable: !1,
        configurable: !0,
        get: function() {
            return this._key
        }
    });
    Object.defineProperty(y.prototype, "key", {
        enumerable: !1,
        configurable: !0,
        set: function(a) {
            void 0 === a && (a = 0);
            this._key = a;
            this.features._referenceEdge = this._key & 255;
            this.features._incidentEdge = (this._key & 65280) >> 8 & 255;
            this.features._incidentVertex =
                (this._key & 16711680) >> 16 & 255;
            this.features._flip = (this._key & 4278190080) >> 24 & 255
        }
    });
    A.b2ContactPoint = function() {
        this.position = new h;
        this.velocity = new h;
        this.normal = new h;
        this.id = new y
    };
    B.b2Distance = function() {};
    B.Distance = function(a, b, c) {
        ++B.b2_gjkCalls;
        var f = c.proxyA,
            g = c.proxyB,
            l = c.transformA,
            m = c.transformB,
            p = B.s_simplex;
        p.ReadCache(b, f, l, g, m);
        var q = p.m_vertices,
            y = B.s_saveA,
            A = B.s_saveB,
            H;
        p.GetClosestPoint().LengthSquared();
        for (var E, M, K = 0; 20 > K;) {
            H = p.m_count;
            for (E = 0; E < H; E++) y[E] = q[E].indexA, A[E] = q[E].indexB;
            switch (p.m_count) {
                case 1:
                    break;
                case 2:
                    p.Solve2();
                    break;
                case 3:
                    p.Solve3();
                    break;
                default:
                    d.b2Assert(!1)
            }
            if (3 == p.m_count) break;
            M = p.GetClosestPoint();
            M.LengthSquared();
            E = p.GetSearchDirection();
            if (E.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) break;
            M = q[p.m_count];
            M.indexA = f.GetSupport(e.MulTMV(l.R, E.GetNegative()));
            M.wA = e.MulX(l, f.GetVertex(M.indexA));
            M.indexB = g.GetSupport(e.MulTMV(m.R, E));
            M.wB = e.MulX(m, g.GetVertex(M.indexB));
            M.w = e.SubtractVV(M.wB, M.wA);
            ++K;
            ++B.b2_gjkIters;
            var aa = !1;
            for (E = 0; E < H; E++)
                if (M.indexA ==
                    y[E] && M.indexB == A[E]) {
                    aa = !0;
                    break
                }
            if (aa) break;
            ++p.m_count
        }
        B.b2_gjkMaxIters = e.Max(B.b2_gjkMaxIters, K);
        p.GetWitnessPoints(a.pointA, a.pointB);
        a.distance = e.SubtractVV(a.pointA, a.pointB).Length();
        a.iterations = K;
        p.WriteCache(b);
        c.useRadii && (b = f.m_radius, g = g.m_radius, a.distance > b + g && a.distance > Number.MIN_VALUE ? (a.distance -= b + g, c = e.SubtractVV(a.pointB, a.pointA), c.Normalize(), a.pointA.x += b * c.x, a.pointA.y += b * c.y, a.pointB.x -= g * c.x, a.pointB.y -= g * c.y) : (M = new h, M.x = .5 * (a.pointA.x + a.pointB.x), M.y = .5 * (a.pointA.y +
            a.pointB.y), a.pointA.x = a.pointB.x = M.x, a.pointA.y = a.pointB.y = M.y, a.distance = 0))
    };
    Box2D.postDefs.push(function() {
        Box2D.Collision.b2Distance.s_simplex = new dc;
        Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
        Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3)
    });
    K.b2DistanceInput = function() {};
    H.b2DistanceOutput = function() {
        this.pointA = new h;
        this.pointB = new h
    };
    E.b2DistanceProxy = function() {};
    E.prototype.Set = function(e) {
        switch (e.GetType()) {
            case b.e_circleShape:
                e = e instanceof a ? e : null;
                this.m_vertices =
                    new Vector(1, !0);
                this.m_vertices[0] = e.m_p;
                this.m_count = 1;
                this.m_radius = e.m_radius;
                break;
            case b.e_polygonShape:
                e = e instanceof c ? e : null;
                this.m_vertices = e.m_vertices;
                this.m_count = e.m_vertexCount;
                this.m_radius = e.m_radius;
                break;
            default:
                d.b2Assert(!1)
        }
    };
    E.prototype.GetSupport = function(a) {
        for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_count; ++d) {
            var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;
            e > c && (b = d, c = e)
        }
        return b
    };
    E.prototype.GetSupportVertex = function(a) {
        for (var b =
                0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_count; ++d) {
            var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;
            e > c && (b = d, c = e)
        }
        return this.m_vertices[b]
    };
    E.prototype.GetVertexCount = function() {
        return this.m_count
    };
    E.prototype.GetVertex = function(a) {
        void 0 === a && (a = 0);
        d.b2Assert(0 <= a && a < this.m_count);
        return this.m_vertices[a]
    };
    M.b2DynamicTree = function() {};
    M.prototype.b2DynamicTree = function() {
        this.m_freeList = this.m_root = null;
        this.m_insertionCount = this.m_path = 0
    };
    M.prototype.CreateProxy =
        function(a, b) {
            var c = this.AllocateNode(),
                e = d.b2_aabbExtension,
                f = d.b2_aabbExtension;
            c.aabb.lowerBound.x = a.lowerBound.x - e;
            c.aabb.lowerBound.y = a.lowerBound.y - f;
            c.aabb.upperBound.x = a.upperBound.x + e;
            c.aabb.upperBound.y = a.upperBound.y + f;
            c.userData = b;
            this.InsertLeaf(c);
            return c
        };
    M.prototype.DestroyProxy = function(a) {
        this.RemoveLeaf(a);
        this.FreeNode(a)
    };
    M.prototype.MoveProxy = function(a, b, c) {
        d.b2Assert(a.IsLeaf());
        if (a.aabb.Contains(b)) return !1;
        this.RemoveLeaf(a);
        var e = d.b2_aabbExtension + d.b2_aabbMultiplier *
            (0 < c.x ? c.x : -c.x);
        c = d.b2_aabbExtension + d.b2_aabbMultiplier * (0 < c.y ? c.y : -c.y);
        a.aabb.lowerBound.x = b.lowerBound.x - e;
        a.aabb.lowerBound.y = b.lowerBound.y - c;
        a.aabb.upperBound.x = b.upperBound.x + e;
        a.aabb.upperBound.y = b.upperBound.y + c;
        this.InsertLeaf(a);
        return !0
    };
    M.prototype.Rebalance = function(a) {
        void 0 === a && (a = 0);
        if (null != this.m_root)
            for (var b = 0; b < a; b++) {
                for (var c = this.m_root, d = 0; 0 == c.IsLeaf();) c = this.m_path >> d & 1 ? c.child2 : c.child1, d = d + 1 & 31;
                ++this.m_path;
                this.RemoveLeaf(c);
                this.InsertLeaf(c)
            }
    };
    M.prototype.GetFatAABB =
        function(a) {
            return a.aabb
        };
    M.prototype.GetUserData = function(a) {
        return a.userData
    };
    M.prototype.Query = function(a, b) {
        if (null != this.m_root) {
            var c = new Vector,
                d = 0;
            for (c[d++] = this.m_root; 0 < d;) {
                var e = c[--d];
                if (e.aabb.TestOverlap(b))
                    if (e.IsLeaf()) {
                        if (!a(e)) break
                    } else c[d++] = e.child1, c[d++] = e.child2
            }
        }
    };
    M.prototype.RayCast = function(a, b) {
        if (null != this.m_root) {
            var c = b.p1,
                d = b.p2,
                f = e.SubtractVV(c, d);
            f.Normalize();
            var f = e.CrossFV(1, f),
                g = e.AbsV(f),
                h = b.maxFraction,
                m = new l,
                p, q;
            p = c.x + h * (d.x - c.x);
            q = c.y + h * (d.y - c.y);
            m.lowerBound.x =
                Math.min(c.x, p);
            m.lowerBound.y = Math.min(c.y, q);
            m.upperBound.x = Math.max(c.x, p);
            m.upperBound.y = Math.max(c.y, q);
            var y = new Vector,
                A = 0;
            for (y[A++] = this.m_root; 0 < A;)
                if (h = y[--A], 0 != h.aabb.TestOverlap(m) && (p = h.aabb.GetCenter(), q = h.aabb.GetExtents(), !(0 < Math.abs(f.x * (c.x - p.x) + f.y * (c.y - p.y)) - g.x * q.x - g.y * q.y)))
                    if (h.IsLeaf()) {
                        p = new bc;
                        p.p1 = b.p1;
                        p.p2 = b.p2;
                        p.maxFraction = b.maxFraction;
                        h = a(p, h);
                        if (0 == h) break;
                        0 < h && (p = c.x + h * (d.x - c.x), q = c.y + h * (d.y - c.y), m.lowerBound.x = Math.min(c.x, p), m.lowerBound.y = Math.min(c.y, q), m.upperBound.x =
                            Math.max(c.x, p), m.upperBound.y = Math.max(c.y, q))
                    } else y[A++] = h.child1, y[A++] = h.child2
        }
    };
    M.prototype.AllocateNode = function() {
        if (this.m_freeList) {
            var a = this.m_freeList;
            this.m_freeList = a.parent;
            a.parent = null;
            a.child1 = null;
            a.child2 = null;
            return a
        }
        return new Zb
    };
    M.prototype.FreeNode = function(a) {
        a.parent = this.m_freeList;
        this.m_freeList = a
    };
    M.prototype.InsertLeaf = function(a) {
        ++this.m_insertionCount;
        if (null == this.m_root) this.m_root = a, this.m_root.parent = null;
        else {
            var b = a.aabb.GetCenter(),
                c = this.m_root;
            if (0 ==
                c.IsLeaf()) {
                do var d = c.child1,
                    c = c.child2,
                    c = Math.abs((d.aabb.lowerBound.x + d.aabb.upperBound.x) / 2 - b.x) + Math.abs((d.aabb.lowerBound.y + d.aabb.upperBound.y) / 2 - b.y) < Math.abs((c.aabb.lowerBound.x + c.aabb.upperBound.x) / 2 - b.x) + Math.abs((c.aabb.lowerBound.y + c.aabb.upperBound.y) / 2 - b.y) ? d : c; while (0 == c.IsLeaf())
            }
            b = c.parent;
            d = this.AllocateNode();
            d.parent = b;
            d.userData = null;
            d.aabb.Combine(a.aabb, c.aabb);
            if (b) {
                c.parent.child1 == c ? b.child1 = d : b.child2 = d;
                d.child1 = c;
                d.child2 = a;
                c.parent = d;
                a.parent = d;
                do {
                    if (b.aabb.Contains(d.aabb)) break;
                    b.aabb.Combine(b.child1.aabb, b.child2.aabb);
                    d = b;
                    b = b.parent
                } while (b)
            } else d.child1 = c, d.child2 = a, c.parent = d, this.m_root = a.parent = d
        }
    };
    M.prototype.RemoveLeaf = function(a) {
        if (a == this.m_root) this.m_root = null;
        else {
            var b = a.parent,
                c = b.parent;
            a = b.child1 == a ? b.child2 : b.child1;
            if (c)
                for (c.child1 == b ? c.child1 = a : c.child2 = a, a.parent = c, this.FreeNode(b); c;) {
                    b = c.aabb;
                    c.aabb = l.Combine(c.child1.aabb, c.child2.aabb);
                    if (b.Contains(c.aabb)) break;
                    c = c.parent
                } else this.m_root = a, a.parent = null, this.FreeNode(b)
        }
    };
    Xb.b2DynamicTreeBroadPhase =
        function() {
            this.m_tree = new M;
            this.m_moveBuffer = new Vector;
            this.m_pairBuffer = new Vector;
            this.m_pairCount = 0
        };
    Xb.prototype.CreateProxy = function(a, b) {
        var c = this.m_tree.CreateProxy(a, b);
        ++this.m_proxyCount;
        this.BufferMove(c);
        return c
    };
    Xb.prototype.DestroyProxy = function(a) {
        this.UnBufferMove(a);
        --this.m_proxyCount;
        this.m_tree.DestroyProxy(a)
    };
    Xb.prototype.MoveProxy = function(a, b, c) {
        this.m_tree.MoveProxy(a, b, c) && this.BufferMove(a)
    };
    Xb.prototype.TestOverlap = function(a, b) {
        var c = this.m_tree.GetFatAABB(a),
            d = this.m_tree.GetFatAABB(b);
        return c.TestOverlap(d)
    };
    Xb.prototype.GetUserData = function(a) {
        return this.m_tree.GetUserData(a)
    };
    Xb.prototype.GetFatAABB = function(a) {
        return this.m_tree.GetFatAABB(a)
    };
    Xb.prototype.GetProxyCount = function() {
        return this.m_proxyCount
    };
    Xb.prototype.UpdatePairs = function(a) {
        for (var b = this, c = b.m_pairCount = 0, d, c = 0; c < b.m_moveBuffer.length; ++c) {
            d = b.m_moveBuffer[c];
            var e = b.m_tree.GetFatAABB(d);
            b.m_tree.Query(function(a) {
                if (a == d) return !0;
                b.m_pairCount == b.m_pairBuffer.length && (b.m_pairBuffer[b.m_pairCount] = new aa);
                var c = b.m_pairBuffer[b.m_pairCount];
                c.proxyA = a < d ? a : d;
                c.proxyB = a >= d ? a : d;
                ++b.m_pairCount;
                return !0
            }, e)
        }
        for (c = b.m_moveBuffer.length = 0; c < b.m_pairCount;) {
            var e = b.m_pairBuffer[c],
                f = b.m_tree.GetUserData(e.proxyA),
                g = b.m_tree.GetUserData(e.proxyB);
            a(f, g);
            for (++c; c < b.m_pairCount;) {
                f = b.m_pairBuffer[c];
                if (f.proxyA != e.proxyA || f.proxyB != e.proxyB) break;
                ++c
            }
        }
    };
    Xb.prototype.Query = function(a, b) {
        this.m_tree.Query(a, b)
    };
    Xb.prototype.RayCast = function(a, b) {
        this.m_tree.RayCast(a, b)
    };
    Xb.prototype.Validate = function() {};
    Xb.prototype.Rebalance =
        function(a) {
            void 0 === a && (a = 0);
            this.m_tree.Rebalance(a)
        };
    Xb.prototype.BufferMove = function(a) {
        this.m_moveBuffer[this.m_moveBuffer.length] = a
    };
    Xb.prototype.UnBufferMove = function(a) {
        this.m_moveBuffer.splice(parseInt(this.m_moveBuffer.indexOf(a)), 1)
    };
    Xb.prototype.ComparePairs = function() {
        return 0
    };
    Xb.__implements = {};
    Xb.__implements[oc] = !0;
    Zb.b2DynamicTreeNode = function() {
        this.aabb = new l
    };
    Zb.prototype.IsLeaf = function() {
        return null == this.child1
    };
    aa.b2DynamicTreePair = function() {};
    Yb.b2Manifold = function() {
        this.m_pointCount =
            0
    };
    Yb.prototype.b2Manifold = function() {
        this.m_points = new Vector(d.b2_maxManifoldPoints);
        for (var a = 0; a < d.b2_maxManifoldPoints; a++) this.m_points[a] = new $b;
        this.m_localPlaneNormal = new h;
        this.m_localPoint = new h
    };
    Yb.prototype.Reset = function() {
        for (var a = 0; a < d.b2_maxManifoldPoints; a++)(this.m_points[a] instanceof $b ? this.m_points[a] : null).Reset();
        this.m_localPlaneNormal.SetZero();
        this.m_localPoint.SetZero();
        this.m_pointCount = this.m_type = 0
    };
    Yb.prototype.Set = function(a) {
        this.m_pointCount = a.m_pointCount;
        for (var b =
                0; b < d.b2_maxManifoldPoints; b++)(this.m_points[b] instanceof $b ? this.m_points[b] : null).Set(a.m_points[b]);
        this.m_localPlaneNormal.SetV(a.m_localPlaneNormal);
        this.m_localPoint.SetV(a.m_localPoint);
        this.m_type = a.m_type
    };
    Yb.prototype.Copy = function() {
        var a = new Yb;
        a.Set(this);
        return a
    };
    Box2D.postDefs.push(function() {
        Box2D.Collision.b2Manifold.e_circles = 1;
        Box2D.Collision.b2Manifold.e_faceA = 2;
        Box2D.Collision.b2Manifold.e_faceB = 4
    });
    $b.b2ManifoldPoint = function() {
        this.m_localPoint = new h;
        this.m_id = new y
    };
    $b.prototype.b2ManifoldPoint =
        function() {
            this.Reset()
        };
    $b.prototype.Reset = function() {
        this.m_localPoint.SetZero();
        this.m_tangentImpulse = this.m_normalImpulse = 0;
        this.m_id.key = 0
    };
    $b.prototype.Set = function(a) {
        this.m_localPoint.SetV(a.m_localPoint);
        this.m_normalImpulse = a.m_normalImpulse;
        this.m_tangentImpulse = a.m_tangentImpulse;
        this.m_id.Set(a.m_id)
    };
    ac.b2Point = function() {
        this.p = new h
    };
    ac.prototype.Support = function() {
        return this.p
    };
    ac.prototype.GetFirstVertex = function() {
        return this.p
    };
    bc.b2RayCastInput = function() {
        this.p1 = new h;
        this.p2 =
            new h
    };
    bc.prototype.b2RayCastInput = function(a, b, c) {
        void 0 === a && (a = null);
        void 0 === b && (b = null);
        void 0 === c && (c = 1);
        a && this.p1.SetV(a);
        b && this.p2.SetV(b);
        this.maxFraction = c
    };
    ec.b2RayCastOutput = function() {
        this.normal = new h
    };
    jc.b2Segment = function() {
        this.p1 = new h;
        this.p2 = new h
    };
    jc.prototype.TestSegment = function(a, b, c, d) {
        void 0 === d && (d = 0);
        var e = c.p1,
            f = c.p2.x - e.x,
            g = c.p2.y - e.y;
        c = this.p2.y - this.p1.y;
        var h = -(this.p2.x - this.p1.x),
            l = 100 * Number.MIN_VALUE,
            m = -(f * c + g * h);
        if (m > l) {
            var p = e.x - this.p1.x,
                q = e.y - this.p1.y,
                e =
                p * c + q * h;
            if (0 <= e && e <= d * m && (d = -f * q + g * p, -l * m <= d && d <= m * (1 + l))) return d = Math.sqrt(c * c + h * h), a[0] = e / m, b.Set(c / d, h / d), !0
        }
        return !1
    };
    jc.prototype.Extend = function(a) {
        this.ExtendForward(a);
        this.ExtendBackward(a)
    };
    jc.prototype.ExtendForward = function(a) {
        var b = this.p2.x - this.p1.x,
            c = this.p2.y - this.p1.y;
        a = Math.min(0 < b ? (a.upperBound.x - this.p1.x) / b : 0 > b ? (a.lowerBound.x - this.p1.x) / b : Number.POSITIVE_INFINITY, 0 < c ? (a.upperBound.y - this.p1.y) / c : 0 > c ? (a.lowerBound.y - this.p1.y) / c : Number.POSITIVE_INFINITY);
        this.p2.x = this.p1.x +
            b * a;
        this.p2.y = this.p1.y + c * a
    };
    jc.prototype.ExtendBackward = function(a) {
        var b = -this.p2.x + this.p1.x,
            c = -this.p2.y + this.p1.y;
        a = Math.min(0 < b ? (a.upperBound.x - this.p2.x) / b : 0 > b ? (a.lowerBound.x - this.p2.x) / b : Number.POSITIVE_INFINITY, 0 < c ? (a.upperBound.y - this.p2.y) / c : 0 > c ? (a.lowerBound.y - this.p2.y) / c : Number.POSITIVE_INFINITY);
        this.p1.x = this.p2.x + b * a;
        this.p1.y = this.p2.y + c * a
    };
    cc.b2SeparationFunction = function() {
        this.m_localPoint = new h;
        this.m_axis = new h
    };
    cc.prototype.Initialize = function(a, b, c, f, g) {
        this.m_proxyA = b;
        this.m_proxyB =
            f;
        var l = parseInt(a.count);
        d.b2Assert(0 < l && 3 > l);
        var m, p, q, y, A, B;
        1 == l ? (this.m_type = cc.e_points, m = this.m_proxyA.GetVertex(a.indexA[0]), p = this.m_proxyB.GetVertex(a.indexB[0]), l = m, a = c.R, b = c.position.x + (a.col1.x * l.x + a.col2.x * l.y), f = c.position.y + (a.col1.y * l.x + a.col2.y * l.y), l = p, a = g.R, q = g.position.x + (a.col1.x * l.x + a.col2.x * l.y), y = g.position.y + (a.col1.y * l.x + a.col2.y * l.y), this.m_axis.x = q - b, this.m_axis.y = y - f, this.m_axis.Normalize()) : (a.indexB[0] == a.indexB[1] ? (this.m_type = cc.e_faceA, b = this.m_proxyA.GetVertex(a.indexA[0]),
            f = this.m_proxyA.GetVertex(a.indexA[1]), p = this.m_proxyB.GetVertex(a.indexB[0]), this.m_localPoint.x = .5 * (b.x + f.x), this.m_localPoint.y = .5 * (b.y + f.y), this.m_axis = e.CrossVF(e.SubtractVV(f, b), 1), this.m_axis.Normalize(), l = this.m_axis, a = c.R, A = a.col1.x * l.x + a.col2.x * l.y, B = a.col1.y * l.x + a.col2.y * l.y, l = this.m_localPoint, a = c.R, b = c.position.x + (a.col1.x * l.x + a.col2.x * l.y), f = c.position.y + (a.col1.y * l.x + a.col2.y * l.y), l = p, a = g.R, q = g.position.x + (a.col1.x * l.x + a.col2.x * l.y), y = g.position.y + (a.col1.y * l.x + a.col2.y * l.y), A = (q - b) *
            A + (y - f) * B) : a.indexA[0] == a.indexA[0] ? (this.m_type = cc.e_faceB, q = this.m_proxyB.GetVertex(a.indexB[0]), y = this.m_proxyB.GetVertex(a.indexB[1]), m = this.m_proxyA.GetVertex(a.indexA[0]), this.m_localPoint.x = .5 * (q.x + y.x), this.m_localPoint.y = .5 * (q.y + y.y), this.m_axis = e.CrossVF(e.SubtractVV(y, q), 1), this.m_axis.Normalize(), l = this.m_axis, a = g.R, A = a.col1.x * l.x + a.col2.x * l.y, B = a.col1.y * l.x + a.col2.y * l.y, l = this.m_localPoint, a = g.R, q = g.position.x + (a.col1.x * l.x + a.col2.x * l.y), y = g.position.y + (a.col1.y * l.x + a.col2.y * l.y), l = m,
            a = c.R, b = c.position.x + (a.col1.x * l.x + a.col2.x * l.y), f = c.position.y + (a.col1.y * l.x + a.col2.y * l.y), A = (b - q) * A + (f - y) * B) : (b = this.m_proxyA.GetVertex(a.indexA[0]), f = this.m_proxyA.GetVertex(a.indexA[1]), q = this.m_proxyB.GetVertex(a.indexB[0]), y = this.m_proxyB.GetVertex(a.indexB[1]), e.MulX(c, m), m = e.MulMV(c.R, e.SubtractVV(f, b)), e.MulX(g, p), A = e.MulMV(g.R, e.SubtractVV(y, q)), g = m.x * m.x + m.y * m.y, p = A.x * A.x + A.y * A.y, a = e.SubtractVV(A, m), c = m.x * a.x + m.y * a.y, a = A.x * a.x + A.y * a.y, m = m.x * A.x + m.y * A.y, B = g * p - m * m, A = 0, 0 != B && (A = e.Clamp((m *
            a - c * p) / B, 0, 1)), 0 > (m * A + a) / p && (A = e.Clamp((m - c) / g, 0, 1)), m = new h, m.x = b.x + A * (f.x - b.x), m.y = b.y + A * (f.y - b.y), p = new h, p.x = q.x + A * (y.x - q.x), p.y = q.y + A * (y.y - q.y), 0 == A || 1 == A ? (this.m_type = cc.e_faceB, this.m_axis = e.CrossVF(e.SubtractVV(y, q), 1), this.m_axis.Normalize(), this.m_localPoint = p) : (this.m_type = cc.e_faceA, this.m_axis = e.CrossVF(e.SubtractVV(f, b), 1), this.m_localPoint = m)), 0 > A && this.m_axis.NegativeSelf())
    };
    cc.prototype.Evaluate = function(a, b) {
        var c, f, g;
        switch (this.m_type) {
            case cc.e_points:
                return c = e.MulTMV(a.R, this.m_axis),
                    f = e.MulTMV(b.R, this.m_axis.GetNegative()), c = this.m_proxyA.GetSupportVertex(c), f = this.m_proxyB.GetSupportVertex(f), c = e.MulX(a, c), f = e.MulX(b, f), (f.x - c.x) * this.m_axis.x + (f.y - c.y) * this.m_axis.y;
            case cc.e_faceA:
                return g = e.MulMV(a.R, this.m_axis), c = e.MulX(a, this.m_localPoint), f = e.MulTMV(b.R, g.GetNegative()), f = this.m_proxyB.GetSupportVertex(f), f = e.MulX(b, f), (f.x - c.x) * g.x + (f.y - c.y) * g.y;
            case cc.e_faceB:
                return g = e.MulMV(b.R, this.m_axis), f = e.MulX(b, this.m_localPoint), c = e.MulTMV(a.R, g.GetNegative()), c = this.m_proxyA.GetSupportVertex(c),
                    c = e.MulX(a, c), (c.x - f.x) * g.x + (c.y - f.y) * g.y;
            default:
                return d.b2Assert(!1), 0
        }
    };
    Box2D.postDefs.push(function() {
        Box2D.Collision.b2SeparationFunction.e_points = 1;
        Box2D.Collision.b2SeparationFunction.e_faceA = 2;
        Box2D.Collision.b2SeparationFunction.e_faceB = 4
    });
    dc.b2Simplex = function() {
        this.m_v1 = new hc;
        this.m_v2 = new hc;
        this.m_v3 = new hc;
        this.m_vertices = new Vector(3)
    };
    dc.prototype.b2Simplex = function() {
        this.m_vertices[0] = this.m_v1;
        this.m_vertices[1] = this.m_v2;
        this.m_vertices[2] = this.m_v3
    };
    dc.prototype.ReadCache =
        function(a, b, c, f, g) {
            d.b2Assert(0 <= a.count && 3 >= a.count);
            var h, l;
            this.m_count = a.count;
            for (var m = this.m_vertices, p = 0; p < this.m_count; p++) {
                var q = m[p];
                q.indexA = a.indexA[p];
                q.indexB = a.indexB[p];
                h = b.GetVertex(q.indexA);
                l = f.GetVertex(q.indexB);
                q.wA = e.MulX(c, h);
                q.wB = e.MulX(g, l);
                q.w = e.SubtractVV(q.wB, q.wA);
                q.a = 0
            }
            1 < this.m_count && (a = a.metric, h = this.GetMetric(), h < .5 * a || 2 * a < h || h < Number.MIN_VALUE) && (this.m_count = 0);
            0 == this.m_count && (q = m[0], q.indexA = 0, q.indexB = 0, h = b.GetVertex(0), l = f.GetVertex(0), q.wA = e.MulX(c, h),
                q.wB = e.MulX(g, l), q.w = e.SubtractVV(q.wB, q.wA), this.m_count = 1)
        };
    dc.prototype.WriteCache = function(a) {
        a.metric = this.GetMetric();
        a.count = Box2D.parseUInt(this.m_count);
        for (var b = this.m_vertices, c = 0; c < this.m_count; c++) a.indexA[c] = Box2D.parseUInt(b[c].indexA), a.indexB[c] = Box2D.parseUInt(b[c].indexB)
    };
    dc.prototype.GetSearchDirection = function() {
        switch (this.m_count) {
            case 1:
                return this.m_v1.w.GetNegative();
            case 2:
                var a = e.SubtractVV(this.m_v2.w, this.m_v1.w);
                return 0 < e.CrossVV(a, this.m_v1.w.GetNegative()) ? e.CrossFV(1,
                    a) : e.CrossVF(a, 1);
            default:
                return d.b2Assert(!1), new h
        }
    };
    dc.prototype.GetClosestPoint = function() {
        switch (this.m_count) {
            case 0:
                return d.b2Assert(!1), new h;
            case 1:
                return this.m_v1.w;
            case 2:
                return new h(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
            default:
                return d.b2Assert(!1), new h
        }
    };
    dc.prototype.GetWitnessPoints = function(a, b) {
        switch (this.m_count) {
            case 0:
                d.b2Assert(!1);
                break;
            case 1:
                a.SetV(this.m_v1.wA);
                b.SetV(this.m_v1.wB);
                break;
            case 2:
                a.x = this.m_v1.a *
                    this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
                a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
                b.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
                b.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
                break;
            case 3:
                b.x = a.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
                b.y = a.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
                break;
            default:
                d.b2Assert(!1)
        }
    };
    dc.prototype.GetMetric = function() {
        switch (this.m_count) {
            case 0:
                return d.b2Assert(!1),
                    0;
            case 1:
                return 0;
            case 2:
                return e.SubtractVV(this.m_v1.w, this.m_v2.w).Length();
            case 3:
                return e.CrossVV(e.SubtractVV(this.m_v2.w, this.m_v1.w), e.SubtractVV(this.m_v3.w, this.m_v1.w));
            default:
                return d.b2Assert(!1), 0
        }
    };
    dc.prototype.Solve2 = function() {
        var a = this.m_v1.w,
            b = this.m_v2.w,
            c = e.SubtractVV(b, a),
            a = -(a.x * c.x + a.y * c.y);
        0 >= a ? this.m_count = this.m_v1.a = 1 : (b = b.x * c.x + b.y * c.y, 0 >= b ? (this.m_count = this.m_v2.a = 1, this.m_v1.Set(this.m_v2)) : (c = 1 / (b + a), this.m_v1.a = b * c, this.m_v2.a = a * c, this.m_count = 2))
    };
    dc.prototype.Solve3 =
        function() {
            var a = this.m_v1.w,
                b = this.m_v2.w,
                c = this.m_v3.w,
                d = e.SubtractVV(b, a),
                f = e.Dot(a, d),
                g = e.Dot(b, d),
                f = -f,
                h = e.SubtractVV(c, a),
                l = e.Dot(a, h),
                m = e.Dot(c, h),
                l = -l,
                p = e.SubtractVV(c, b),
                q = e.Dot(b, p),
                p = e.Dot(c, p),
                q = -q,
                h = e.CrossVV(d, h),
                d = h * e.CrossVV(b, c),
                c = h * e.CrossVV(c, a),
                a = h * e.CrossVV(a, b);
            0 >= f && 0 >= l ? this.m_count = this.m_v1.a = 1 : 0 < g && 0 < f && 0 >= a ? (m = 1 / (g + f), this.m_v1.a = g * m, this.m_v2.a = f * m, this.m_count = 2) : 0 < m && 0 < l && 0 >= c ? (g = 1 / (m + l), this.m_v1.a = m * g, this.m_v3.a = l * g, this.m_count = 2, this.m_v2.Set(this.m_v3)) : 0 >= g &&
                0 >= q ? (this.m_count = this.m_v2.a = 1, this.m_v1.Set(this.m_v2)) : 0 >= m && 0 >= p ? (this.m_count = this.m_v3.a = 1, this.m_v1.Set(this.m_v3)) : 0 < p && 0 < q && 0 >= d ? (g = 1 / (p + q), this.m_v2.a = p * g, this.m_v3.a = q * g, this.m_count = 2, this.m_v1.Set(this.m_v3)) : (g = 1 / (d + c + a), this.m_v1.a = d * g, this.m_v2.a = c * g, this.m_v3.a = a * g, this.m_count = 3)
        };
    gc.b2SimplexCache = function() {
        this.indexA = new Vector_a2j_Number(3);
        this.indexB = new Vector_a2j_Number(3)
    };
    hc.b2SimplexVertex = function() {};
    hc.prototype.Set = function(a) {
        this.wA.SetV(a.wA);
        this.wB.SetV(a.wB);
        this.w.SetV(a.w);
        this.a = a.a;
        this.indexA = a.indexA;
        this.indexB = a.indexB
    };
    fc.b2TimeOfImpact = function() {};
    fc.TimeOfImpact = function(a) {
        ++fc.b2_toiCalls;
        var b = a.proxyA,
            c = a.proxyB,
            f = a.sweepA,
            g = a.sweepB;
        d.b2Assert(f.t0 == g.t0);
        d.b2Assert(1 - f.t0 > Number.MIN_VALUE);
        var h = b.m_radius + c.m_radius;
        a = a.tolerance;
        var l = 0,
            m = 0,
            p = 0;
        fc.s_cache.count = 0;
        for (fc.s_distanceInput.useRadii = !1;;) {
            f.GetTransform(fc.s_xfA, l);
            g.GetTransform(fc.s_xfB, l);
            fc.s_distanceInput.proxyA = b;
            fc.s_distanceInput.proxyB = c;
            fc.s_distanceInput.transformA =
                fc.s_xfA;
            fc.s_distanceInput.transformB = fc.s_xfB;
            B.Distance(fc.s_distanceOutput, fc.s_cache, fc.s_distanceInput);
            if (0 >= fc.s_distanceOutput.distance) {
                l = 1;
                break
            }
            fc.s_fcn.Initialize(fc.s_cache, b, fc.s_xfA, c, fc.s_xfB);
            var q = fc.s_fcn.Evaluate(fc.s_xfA, fc.s_xfB);
            if (0 >= q) {
                l = 1;
                break
            }
            0 == m && (p = q > h ? e.Max(h - a, .75 * h) : e.Max(q - a, .02 * h));
            if (q - p < .5 * a) {
                if (0 == m) {
                    l = 1;
                    break
                }
                break
            }
            var y = l,
                A = l,
                H = 1;
            f.GetTransform(fc.s_xfA, H);
            g.GetTransform(fc.s_xfB, H);
            var E = fc.s_fcn.Evaluate(fc.s_xfA, fc.s_xfB);
            if (E >= p) {
                l = 1;
                break
            }
            for (var M = 0;;) {
                var K;
                K = M & 1 ? A + (p - q) * (H - A) / (E - q) : .5 * (A + H);
                f.GetTransform(fc.s_xfA, K);
                g.GetTransform(fc.s_xfB, K);
                var aa = fc.s_fcn.Evaluate(fc.s_xfA, fc.s_xfB);
                if (e.Abs(aa - p) < .025 * a) {
                    y = K;
                    break
                }
                aa > p ? (A = K, q = aa) : (H = K, E = aa);
                ++M;
                ++fc.b2_toiRootIters;
                if (50 == M) break
            }
            fc.b2_toiMaxRootIters = e.Max(fc.b2_toiMaxRootIters, M);
            if (y < (1 + 100 * Number.MIN_VALUE) * l) break;
            l = y;
            m++;
            ++fc.b2_toiIters;
            if (1E3 == m) break
        }
        fc.b2_toiMaxIters = e.Max(fc.b2_toiMaxIters, m);
        return l
    };
    Box2D.postDefs.push(function() {
        Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiIters =
            0;
        Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
        Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
        Box2D.Collision.b2TimeOfImpact.s_cache = new gc;
        Box2D.Collision.b2TimeOfImpact.s_distanceInput = new K;
        Box2D.Collision.b2TimeOfImpact.s_xfA = new g;
        Box2D.Collision.b2TimeOfImpact.s_xfB = new g;
        Box2D.Collision.b2TimeOfImpact.s_fcn = new cc;
        Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new H
    });
    kc.b2TOIInput = function() {
        this.proxyA = new E;
        this.proxyB = new E;
        this.sweepA =
            new f;
        this.sweepB = new f
    };
    lc.b2WorldManifold = function() {
        this.m_normal = new h
    };
    lc.prototype.b2WorldManifold = function() {
        this.m_points = new Vector(d.b2_maxManifoldPoints);
        for (var a = 0; a < d.b2_maxManifoldPoints; a++) this.m_points[a] = new h
    };
    lc.prototype.Initialize = function(a, b, c, d, e) {
        void 0 === c && (c = 0);
        void 0 === e && (e = 0);
        if (0 != a.m_pointCount) {
            var f, g, h, l, m, p, q, y;
            switch (a.m_type) {
                case Yb.e_circles:
                    h = b.R;
                    g = a.m_localPoint;
                    f = b.position.x + h.col1.x * g.x + h.col2.x * g.y;
                    b = b.position.y + h.col1.y * g.x + h.col2.y * g.y;
                    h = d.R;
                    g = a.m_points[0].m_localPoint;
                    a = d.position.x + h.col1.x * g.x + h.col2.x * g.y;
                    d = d.position.y + h.col1.y * g.x + h.col2.y * g.y;
                    g = a - f;
                    h = d - b;
                    l = g * g + h * h;
                    l > Number.MIN_VALUE * Number.MIN_VALUE ? (l = Math.sqrt(l), this.m_normal.x = g / l, this.m_normal.y = h / l) : (this.m_normal.x = 1, this.m_normal.y = 0);
                    g = b + c * this.m_normal.y;
                    d -= e * this.m_normal.y;
                    this.m_points[0].x = .5 * (f + c * this.m_normal.x + (a - e * this.m_normal.x));
                    this.m_points[0].y = .5 * (g + d);
                    break;
                case Yb.e_faceA:
                    h = b.R;
                    g = a.m_localPlaneNormal;
                    l = h.col1.x * g.x + h.col2.x * g.y;
                    m = h.col1.y * g.x + h.col2.y * g.y;
                    h = b.R;
                    g = a.m_localPoint;
                    p = b.position.x + h.col1.x * g.x + h.col2.x * g.y;
                    q = b.position.y + h.col1.y * g.x + h.col2.y * g.y;
                    this.m_normal.x = l;
                    this.m_normal.y = m;
                    for (f = 0; f < a.m_pointCount; f++) h = d.R, g = a.m_points[f].m_localPoint, y = d.position.x + h.col1.x * g.x + h.col2.x * g.y, g = d.position.y + h.col1.y * g.x + h.col2.y * g.y, this.m_points[f].x = y + .5 * (c - (y - p) * l - (g - q) * m - e) * l, this.m_points[f].y = g + .5 * (c - (y - p) * l - (g - q) * m - e) * m;
                    break;
                case Yb.e_faceB:
                    for (h = d.R, g = a.m_localPlaneNormal, l = h.col1.x * g.x + h.col2.x * g.y, m = h.col1.y * g.x + h.col2.y * g.y, h = d.R, g = a.m_localPoint, p = d.position.x +
                        h.col1.x * g.x + h.col2.x * g.y, q = d.position.y + h.col1.y * g.x + h.col2.y * g.y, this.m_normal.x = -l, this.m_normal.y = -m, f = 0; f < a.m_pointCount; f++) h = b.R, g = a.m_points[f].m_localPoint, y = b.position.x + h.col1.x * g.x + h.col2.x * g.y, g = b.position.y + h.col1.y * g.x + h.col2.y * g.y, this.m_points[f].x = y + .5 * (e - (y - p) * l - (g - q) * m - c) * l, this.m_points[f].y = g + .5 * (e - (y - p) * l - (g - q) * m - c) * m
            }
        }
    };
    mc.ClipVertex = function() {
        this.v = new h;
        this.id = new y
    };
    mc.prototype.Set = function(a) {
        this.v.SetV(a.v);
        this.id.Set(a.id)
    };
    nc.Features = function() {};
    Object.defineProperty(nc.prototype,
        "referenceEdge", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._referenceEdge
            }
        });
    Object.defineProperty(nc.prototype, "referenceEdge", {
        enumerable: !1,
        configurable: !0,
        set: function(a) {
            void 0 === a && (a = 0);
            this._referenceEdge = a;
            this._m_id._key = this._m_id._key & 4294967040 | this._referenceEdge & 255
        }
    });
    Object.defineProperty(nc.prototype, "incidentEdge", {
        enumerable: !1,
        configurable: !0,
        get: function() {
            return this._incidentEdge
        }
    });
    Object.defineProperty(nc.prototype, "incidentEdge", {
        enumerable: !1,
        configurable: !0,
        set: function(a) {
            void 0 === a && (a = 0);
            this._incidentEdge = a;
            this._m_id._key = this._m_id._key & 4294902015 | this._incidentEdge << 8 & 65280
        }
    });
    Object.defineProperty(nc.prototype, "incidentVertex", {
        enumerable: !1,
        configurable: !0,
        get: function() {
            return this._incidentVertex
        }
    });
    Object.defineProperty(nc.prototype, "incidentVertex", {
        enumerable: !1,
        configurable: !0,
        set: function(a) {
            void 0 === a && (a = 0);
            this._incidentVertex = a;
            this._m_id._key = this._m_id._key & 4278255615 | this._incidentVertex << 16 & 16711680
        }
    });
    Object.defineProperty(nc.prototype,
        "flip", {
            enumerable: !1,
            configurable: !0,
            get: function() {
                return this._flip
            }
        });
    Object.defineProperty(nc.prototype, "flip", {
        enumerable: !1,
        configurable: !0,
        set: function(a) {
            void 0 === a && (a = 0);
            this._flip = a;
            this._m_id._key = this._m_id._key & 16777215 | this._flip << 24 & 4278190080
        }
    })
})();
(function() {
    var a = Box2D.Common.b2Settings,
        c = Box2D.Collision.Shapes.b2CircleShape,
        b = Box2D.Collision.Shapes.b2EdgeChainDef,
        d = Box2D.Collision.Shapes.b2EdgeShape,
        e = Box2D.Collision.Shapes.b2MassData,
        f = Box2D.Collision.Shapes.b2PolygonShape,
        g = Box2D.Collision.Shapes.b2Shape,
        h = Box2D.Common.Math.b2Mat22,
        l = Box2D.Common.Math.b2Math,
        m = Box2D.Common.Math.b2Transform,
        q = Box2D.Common.Math.b2Vec2,
        p = Box2D.Collision.b2Distance,
        y = Box2D.Collision.b2DistanceInput,
        A = Box2D.Collision.b2DistanceOutput,
        B = Box2D.Collision.b2DistanceProxy,
        K = Box2D.Collision.b2SimplexCache;
    Box2D.inherit(c, Box2D.Collision.Shapes.b2Shape);
    c.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    c.b2CircleShape = function() {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
        this.m_p = new q
    };
    c.prototype.Copy = function() {
        var a = new c;
        a.Set(this);
        return a
    };
    c.prototype.Set = function(a) {
        this.__super.Set.call(this, a);
        Box2D.is(a, c) && this.m_p.SetV((a instanceof c ? a : null).m_p)
    };
    c.prototype.TestPoint = function(a, b) {
        var c = a.R,
            d = a.position.x + (c.col1.x * this.m_p.x +
                c.col2.x * this.m_p.y),
            c = a.position.y + (c.col1.y * this.m_p.x + c.col2.y * this.m_p.y),
            d = b.x - d,
            c = b.y - c;
        return d * d + c * c <= this.m_radius * this.m_radius
    };
    c.prototype.RayCast = function(a, b, c) {
        var d = c.R,
            e = b.p1.x - (c.position.x + (d.col1.x * this.m_p.x + d.col2.x * this.m_p.y));
        c = b.p1.y - (c.position.y + (d.col1.y * this.m_p.x + d.col2.y * this.m_p.y));
        var d = b.p2.x - b.p1.x,
            f = b.p2.y - b.p1.y,
            g = e * d + c * f,
            h = d * d + f * f,
            l = g * g - h * (e * e + c * c - this.m_radius * this.m_radius);
        if (0 > l || h < Number.MIN_VALUE) return !1;
        g = -(g + Math.sqrt(l));
        return 0 <= g && g <= b.maxFraction *
            h ? (g /= h, a.fraction = g, a.normal.x = e + g * d, a.normal.y = c + g * f, a.normal.Normalize(), !0) : !1
    };
    c.prototype.ComputeAABB = function(a, b) {
        var c = b.R,
            d = b.position.x + (c.col1.x * this.m_p.x + c.col2.x * this.m_p.y),
            c = b.position.y + (c.col1.y * this.m_p.x + c.col2.y * this.m_p.y);
        a.lowerBound.Set(d - this.m_radius, c - this.m_radius);
        a.upperBound.Set(d + this.m_radius, c + this.m_radius)
    };
    c.prototype.ComputeMass = function(b, c) {
        void 0 === c && (c = 0);
        b.mass = c * a.b2_pi * this.m_radius * this.m_radius;
        b.center.SetV(this.m_p);
        b.I = b.mass * (.5 * this.m_radius *
            this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y))
    };
    c.prototype.ComputeSubmergedArea = function(a, b, c, d) {
        void 0 === b && (b = 0);
        c = l.MulX(c, this.m_p);
        var e = -(l.Dot(a, c) - b);
        if (e < -this.m_radius + Number.MIN_VALUE) return 0;
        if (e > this.m_radius) return d.SetV(c), Math.PI * this.m_radius * this.m_radius;
        b = this.m_radius * this.m_radius;
        var f = e * e,
            e = b * (Math.asin(e / this.m_radius) + Math.PI / 2) + e * Math.sqrt(b - f);
        b = -2 / 3 * Math.pow(b - f, 1.5) / e;
        d.x = c.x + a.x * b;
        d.y = c.y + a.y * b;
        return e
    };
    c.prototype.GetLocalPosition = function() {
        return this.m_p
    };
    c.prototype.SetLocalPosition = function(a) {
        this.m_p.SetV(a)
    };
    c.prototype.GetRadius = function() {
        return this.m_radius
    };
    c.prototype.SetRadius = function(a) {
        void 0 === a && (a = 0);
        this.m_radius = a
    };
    c.prototype.b2CircleShape = function(a) {
        void 0 === a && (a = 0);
        this.__super.b2Shape.call(this);
        this.m_type = g.e_circleShape;
        this.m_radius = a
    };
    b.b2EdgeChainDef = function() {};
    b.prototype.b2EdgeChainDef = function() {
        this.vertexCount = 0;
        this.isALoop = !0;
        this.vertices = []
    };
    Box2D.inherit(d, Box2D.Collision.Shapes.b2Shape);
    d.prototype.__super =
        Box2D.Collision.Shapes.b2Shape.prototype;
    d.b2EdgeShape = function() {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
        this.s_supportVec = new q;
        this.m_v1 = new q;
        this.m_v2 = new q;
        this.m_coreV1 = new q;
        this.m_coreV2 = new q;
        this.m_normal = new q;
        this.m_direction = new q;
        this.m_cornerDir1 = new q;
        this.m_cornerDir2 = new q
    };
    d.prototype.TestPoint = function() {
        return !1
    };
    d.prototype.RayCast = function(a, b, c) {
        var d, e = b.p2.x - b.p1.x,
            f = b.p2.y - b.p1.y;
        d = c.R;
        var g = c.position.x + (d.col1.x * this.m_v1.x + d.col2.x * this.m_v1.y),
            h = c.position.y + (d.col1.y * this.m_v1.x + d.col2.y * this.m_v1.y),
            l = c.position.y + (d.col1.y * this.m_v2.x + d.col2.y * this.m_v2.y) - h;
        c = -(c.position.x + (d.col1.x * this.m_v2.x + d.col2.x * this.m_v2.y) - g);
        d = 100 * Number.MIN_VALUE;
        var m = -(e * l + f * c);
        if (m > d) {
            var g = b.p1.x - g,
                p = b.p1.y - h,
                h = g * l + p * c;
            if (0 <= h && h <= b.maxFraction * m && (b = -e * p + f * g, -d * m <= b && b <= m * (1 + d))) return a.fraction = h / m, b = Math.sqrt(l * l + c * c), a.normal.x = l / b, a.normal.y = c / b, !0
        }
        return !1
    };
    d.prototype.ComputeAABB = function(a, b) {
        var c = b.R,
            d = b.position.x + (c.col1.x * this.m_v1.x +
                c.col2.x * this.m_v1.y),
            e = b.position.y + (c.col1.y * this.m_v1.x + c.col2.y * this.m_v1.y),
            f = b.position.x + (c.col1.x * this.m_v2.x + c.col2.x * this.m_v2.y),
            c = b.position.y + (c.col1.y * this.m_v2.x + c.col2.y * this.m_v2.y);
        d < f ? (a.lowerBound.x = d, a.upperBound.x = f) : (a.lowerBound.x = f, a.upperBound.x = d);
        e < c ? (a.lowerBound.y = e, a.upperBound.y = c) : (a.lowerBound.y = c, a.upperBound.y = e)
    };
    d.prototype.ComputeMass = function(a) {
        a.mass = 0;
        a.center.SetV(this.m_v1);
        a.I = 0
    };
    d.prototype.ComputeSubmergedArea = function(a, b, c, d) {
        void 0 === b && (b = 0);
        var e =
            new q(a.x * b, a.y * b),
            f = l.MulX(c, this.m_v1);
        c = l.MulX(c, this.m_v2);
        var g = l.Dot(a, f) - b;
        a = l.Dot(a, c) - b;
        if (0 < g) {
            if (0 < a) return 0;
            f.x = -a / (g - a) * f.x + g / (g - a) * c.x;
            f.y = -a / (g - a) * f.y + g / (g - a) * c.y
        } else 0 < a && (c.x = -a / (g - a) * f.x + g / (g - a) * c.x, c.y = -a / (g - a) * f.y + g / (g - a) * c.y);
        d.x = (e.x + f.x + c.x) / 3;
        d.y = (e.y + f.y + c.y) / 3;
        return .5 * ((f.x - e.x) * (c.y - e.y) - (f.y - e.y) * (c.x - e.x))
    };
    d.prototype.GetLength = function() {
        return this.m_length
    };
    d.prototype.GetVertex1 = function() {
        return this.m_v1
    };
    d.prototype.GetVertex2 = function() {
        return this.m_v2
    };
    d.prototype.GetCoreVertex1 =
        function() {
            return this.m_coreV1
        };
    d.prototype.GetCoreVertex2 = function() {
        return this.m_coreV2
    };
    d.prototype.GetNormalVector = function() {
        return this.m_normal
    };
    d.prototype.GetDirectionVector = function() {
        return this.m_direction
    };
    d.prototype.GetCorner1Vector = function() {
        return this.m_cornerDir1
    };
    d.prototype.GetCorner2Vector = function() {
        return this.m_cornerDir2
    };
    d.prototype.Corner1IsConvex = function() {
        return this.m_cornerConvex1
    };
    d.prototype.Corner2IsConvex = function() {
        return this.m_cornerConvex2
    };
    d.prototype.GetFirstVertex =
        function(a) {
            var b = a.R;
            return new q(a.position.x + (b.col1.x * this.m_coreV1.x + b.col2.x * this.m_coreV1.y), a.position.y + (b.col1.y * this.m_coreV1.x + b.col2.y * this.m_coreV1.y))
        };
    d.prototype.GetNextEdge = function() {
        return this.m_nextEdge
    };
    d.prototype.GetPrevEdge = function() {
        return this.m_prevEdge
    };
    d.prototype.Support = function(a, b, c) {
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        var d = a.R,
            e = a.position.x + (d.col1.x * this.m_coreV1.x + d.col2.x * this.m_coreV1.y),
            f = a.position.y + (d.col1.y * this.m_coreV1.x + d.col2.y * this.m_coreV1.y),
            g = a.position.x + (d.col1.x * this.m_coreV2.x + d.col2.x * this.m_coreV2.y);
        a = a.position.y + (d.col1.y * this.m_coreV2.x + d.col2.y * this.m_coreV2.y);
        e * b + f * c > g * b + a * c ? (this.s_supportVec.x = e, this.s_supportVec.y = f) : (this.s_supportVec.x = g, this.s_supportVec.y = a);
        return this.s_supportVec
    };
    d.prototype.b2EdgeShape = function(b, c) {
        this.__super.b2Shape.call(this);
        this.m_type = g.e_edgeShape;
        this.m_nextEdge = this.m_prevEdge = null;
        this.m_v1 = b;
        this.m_v2 = c;
        this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
        this.m_length =
            this.m_direction.Normalize();
        this.m_normal.Set(this.m_direction.y, -this.m_direction.x);
        this.m_coreV1.Set(-a.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -a.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y);
        this.m_coreV2.Set(-a.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -a.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y);
        this.m_cornerDir1 = this.m_normal;
        this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y)
    };
    d.prototype.SetPrevEdge = function(a,
        b, c, d) {
        this.m_prevEdge = a;
        this.m_coreV1 = b;
        this.m_cornerDir1 = c;
        this.m_cornerConvex1 = d
    };
    d.prototype.SetNextEdge = function(a, b, c, d) {
        this.m_nextEdge = a;
        this.m_coreV2 = b;
        this.m_cornerDir2 = c;
        this.m_cornerConvex2 = d
    };
    e.b2MassData = function() {
        this.mass = 0;
        this.center = new q(0, 0);
        this.I = 0
    };
    Box2D.inherit(f, Box2D.Collision.Shapes.b2Shape);
    f.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;
    f.b2PolygonShape = function() {
        Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments)
    };
    f.prototype.Copy = function() {
        var a =
            new f;
        a.Set(this);
        return a
    };
    f.prototype.Set = function(a) {
        this.__super.Set.call(this, a);
        if (Box2D.is(a, f)) {
            a = a instanceof f ? a : null;
            this.m_centroid.SetV(a.m_centroid);
            this.m_vertexCount = a.m_vertexCount;
            this.Reserve(this.m_vertexCount);
            for (var b = 0; b < this.m_vertexCount; b++) this.m_vertices[b].SetV(a.m_vertices[b]), this.m_normals[b].SetV(a.m_normals[b])
        }
    };
    f.prototype.SetAsArray = function(a, b) {
        void 0 === b && (b = 0);
        var c = new Vector,
            d, e;
        for (d = 0; d < a.length; ++d) e = a[d], c.push(e);
        this.SetAsVector(c, b)
    };
    f.AsArray = function(a,
        b) {
        void 0 === b && (b = 0);
        var c = new f;
        c.SetAsArray(a, b);
        return c
    };
    f.prototype.SetAsVector = function(b, c) {
        void 0 === c && (c = 0);
        0 == c && (c = b.length);
        a.b2Assert(2 <= c);
        this.m_vertexCount = c;
        this.Reserve(c);
        var d;
        for (d = 0; d < this.m_vertexCount; d++) this.m_vertices[d].SetV(b[d]);
        for (d = 0; d < this.m_vertexCount; ++d) {
            var e = parseInt(d),
                g = parseInt(d + 1 < this.m_vertexCount ? d + 1 : 0),
                e = l.SubtractVV(this.m_vertices[g], this.m_vertices[e]);
            a.b2Assert(e.LengthSquared() > Number.MIN_VALUE);
            this.m_normals[d].SetV(l.CrossVF(e, 1));
            this.m_normals[d].Normalize()
        }
        this.m_centroid =
            f.ComputeCentroid(this.m_vertices, this.m_vertexCount)
    };
    f.AsVector = function(a, b) {
        void 0 === b && (b = 0);
        var c = new f;
        c.SetAsVector(a, b);
        return c
    };
    f.prototype.SetAsBox = function(a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.m_vertexCount = 4;
        this.Reserve(4);
        this.m_vertices[0].Set(-a, -b);
        this.m_vertices[1].Set(a, -b);
        this.m_vertices[2].Set(a, b);
        this.m_vertices[3].Set(-a, b);
        this.m_normals[0].Set(0, -1);
        this.m_normals[1].Set(1, 0);
        this.m_normals[2].Set(0, 1);
        this.m_normals[3].Set(-1, 0);
        this.m_centroid.SetZero()
    };
    f.AsBox =
        function(a, b) {
            void 0 === a && (a = 0);
            void 0 === b && (b = 0);
            var c = new f;
            c.SetAsBox(a, b);
            return c
        };
    f.prototype.SetAsOrientedBox = function(a, b, c, d) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === c && (c = null);
        void 0 === d && (d = 0);
        this.m_vertexCount = 4;
        this.Reserve(4);
        this.m_vertices[0].Set(-a, -b);
        this.m_vertices[1].Set(a, -b);
        this.m_vertices[2].Set(a, b);
        this.m_vertices[3].Set(-a, b);
        this.m_normals[0].Set(0, -1);
        this.m_normals[1].Set(1, 0);
        this.m_normals[2].Set(0, 1);
        this.m_normals[3].Set(-1, 0);
        this.m_centroid = c;
        a = new m;
        a.position =
            c;
        a.R.Set(d);
        for (c = 0; c < this.m_vertexCount; ++c) this.m_vertices[c] = l.MulX(a, this.m_vertices[c]), this.m_normals[c] = l.MulMV(a.R, this.m_normals[c])
    };
    f.AsOrientedBox = function(a, b, c, d) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === c && (c = null);
        void 0 === d && (d = 0);
        var e = new f;
        e.SetAsOrientedBox(a, b, c, d);
        return e
    };
    f.prototype.SetAsEdge = function(a, b) {
        this.m_vertexCount = 2;
        this.Reserve(2);
        this.m_vertices[0].SetV(a);
        this.m_vertices[1].SetV(b);
        this.m_centroid.x = .5 * (a.x + b.x);
        this.m_centroid.y = .5 * (a.y + b.y);
        this.m_normals[0] =
            l.CrossVF(l.SubtractVV(b, a), 1);
        this.m_normals[0].Normalize();
        this.m_normals[1].x = -this.m_normals[0].x;
        this.m_normals[1].y = -this.m_normals[0].y
    };
    f.AsEdge = function(a, b) {
        var c = new f;
        c.SetAsEdge(a, b);
        return c
    };
    f.prototype.TestPoint = function(a, b) {
        var c;
        c = a.R;
        for (var d = b.x - a.position.x, e = b.y - a.position.y, f = d * c.col1.x + e * c.col1.y, g = d * c.col2.x + e * c.col2.y, h = 0; h < this.m_vertexCount; ++h)
            if (c = this.m_vertices[h], d = f - c.x, e = g - c.y, c = this.m_normals[h], 0 < c.x * d + c.y * e) return !1;
        return !0
    };
    f.prototype.RayCast = function(a,
        b, c) {
        var d = 0,
            e = b.maxFraction,
            f, g, h, l;
        f = b.p1.x - c.position.x;
        g = b.p1.y - c.position.y;
        h = c.R;
        var m = f * h.col1.x + g * h.col1.y,
            p = f * h.col2.x + g * h.col2.y;
        f = b.p2.x - c.position.x;
        g = b.p2.y - c.position.y;
        h = c.R;
        b = f * h.col1.x + g * h.col1.y - m;
        h = f * h.col2.x + g * h.col2.y - p;
        for (var q = -1, y = 0; y < this.m_vertexCount; ++y) {
            l = this.m_vertices[y];
            f = l.x - m;
            g = l.y - p;
            l = this.m_normals[y];
            f = l.x * f + l.y * g;
            g = l.x * b + l.y * h;
            if (0 == g) {
                if (0 > f) return !1
            } else 0 > g && f < d * g ? (d = f / g, q = y) : 0 < g && f < e * g && (e = f / g);
            if (e < d - Number.MIN_VALUE) return !1
        }
        return 0 <= q ? (a.fraction = d,
            h = c.R, l = this.m_normals[q], a.normal.x = h.col1.x * l.x + h.col2.x * l.y, a.normal.y = h.col1.y * l.x + h.col2.y * l.y, !0) : !1
    };
    f.prototype.ComputeAABB = function(a, b) {
        for (var c = b.R, d = this.m_vertices[0], e = b.position.x + (c.col1.x * d.x + c.col2.x * d.y), f = b.position.y + (c.col1.y * d.x + c.col2.y * d.y), g = e, h = f, l = 1; l < this.m_vertexCount; ++l) var d = this.m_vertices[l],
            m = b.position.x + (c.col1.x * d.x + c.col2.x * d.y),
            d = b.position.y + (c.col1.y * d.x + c.col2.y * d.y),
            e = e < m ? e : m,
            f = f < d ? f : d,
            g = g > m ? g : m,
            h = h > d ? h : d;
        a.lowerBound.x = e - this.m_radius;
        a.lowerBound.y =
            f - this.m_radius;
        a.upperBound.x = g + this.m_radius;
        a.upperBound.y = h + this.m_radius
    };
    f.prototype.ComputeMass = function(a, b) {
        void 0 === b && (b = 0);
        if (2 == this.m_vertexCount) a.center.x = .5 * (this.m_vertices[0].x + this.m_vertices[1].x), a.center.y = .5 * (this.m_vertices[0].y + this.m_vertices[1].y), a.mass = 0, a.I = 0;
        else {
            for (var c = 0, d = 0, e = 0, f = 0, g = 1 / 3, h = 0; h < this.m_vertexCount; ++h) var l = this.m_vertices[h],
                m = h + 1 < this.m_vertexCount ? this.m_vertices[parseInt(h + 1)] : this.m_vertices[0],
                p = l.x - 0,
                q = l.y - 0,
                y = m.x - 0,
                A = m.y - 0,
                B = p * A - q * y,
                K = .5 *
                B,
                e = e + K,
                c = c + K * g * (0 + l.x + m.x),
                d = d + K * g * (0 + l.y + m.y),
                l = p,
                f = f + B * (g * (.25 * (l * l + y * l + y * y) + (0 * l + 0 * y)) + 0 + (g * (.25 * (q * q + A * q + A * A) + (0 * q + 0 * A)) + 0));
            a.mass = b * e;
            a.center.Set(1 / e * c, 1 / e * d);
            a.I = b * f
        }
    };
    f.prototype.ComputeSubmergedArea = function(a, b, c, d) {
        void 0 === b && (b = 0);
        var f = l.MulTMV(c.R, a),
            g = b - l.Dot(a, c.position),
            h = new Vector_a2j_Number,
            m = 0,
            p = -1;
        b = -1;
        var y = !1;
        for (a = a = 0; a < this.m_vertexCount; ++a) {
            h[a] = l.Dot(f, this.m_vertices[a]) - g;
            var A = h[a] < -Number.MIN_VALUE;
            0 < a && (A ? y || (p = a - 1, m++) : y && (b = a - 1, m++));
            y = A
        }
        switch (m) {
            case 0:
                return y ?
                    (a = new e, this.ComputeMass(a, 1), d.SetV(l.MulX(c, a.center)), a.mass) : 0;
            case 1:
                -1 == p ? p = this.m_vertexCount - 1 : b = this.m_vertexCount - 1
        }
        a = parseInt((p + 1) % this.m_vertexCount);
        f = parseInt((b + 1) % this.m_vertexCount);
        g = (0 - h[p]) / (h[a] - h[p]);
        h = (0 - h[b]) / (h[f] - h[b]);
        p = new q(this.m_vertices[p].x * (1 - g) + this.m_vertices[a].x * g, this.m_vertices[p].y * (1 - g) + this.m_vertices[a].y * g);
        b = new q(this.m_vertices[b].x * (1 - h) + this.m_vertices[f].x * h, this.m_vertices[b].y * (1 - h) + this.m_vertices[f].y * h);
        h = 0;
        g = new q;
        for (m = this.m_vertices[a]; a !=
            f;) a = (a + 1) % this.m_vertexCount, y = a == f ? b : this.m_vertices[a], A = .5 * ((m.x - p.x) * (y.y - p.y) - (m.y - p.y) * (y.x - p.x)), h += A, g.x += A * (p.x + m.x + y.x) / 3, g.y += A * (p.y + m.y + y.y) / 3, m = y;
        g.Multiply(1 / h);
        d.SetV(l.MulX(c, g));
        return h
    };
    f.prototype.GetVertexCount = function() {
        return this.m_vertexCount
    };
    f.prototype.GetVertices = function() {
        return this.m_vertices
    };
    f.prototype.GetNormals = function() {
        return this.m_normals
    };
    f.prototype.GetSupport = function(a) {
        for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_vertexCount; ++d) {
            var e =
                this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;
            e > c && (b = d, c = e)
        }
        return b
    };
    f.prototype.GetSupportVertex = function(a) {
        for (var b = 0, c = this.m_vertices[0].x * a.x + this.m_vertices[0].y * a.y, d = 1; d < this.m_vertexCount; ++d) {
            var e = this.m_vertices[d].x * a.x + this.m_vertices[d].y * a.y;
            e > c && (b = d, c = e)
        }
        return this.m_vertices[b]
    };
    f.prototype.Validate = function() {
        return !1
    };
    f.prototype.b2PolygonShape = function() {
        this.__super.b2Shape.call(this);
        this.m_type = g.e_polygonShape;
        this.m_centroid = new q;
        this.m_vertices = new Vector;
        this.m_normals =
            new Vector
    };
    f.prototype.Reserve = function(a) {
        void 0 === a && (a = 0);
        for (var b = parseInt(this.m_vertices.length); b < a; b++) this.m_vertices[b] = new q, this.m_normals[b] = new q
    };
    f.ComputeCentroid = function(a, b) {
        void 0 === b && (b = 0);
        for (var c = new q, d = 0, e = 1 / 3, f = 0; f < b; ++f) {
            var g = a[f],
                h = f + 1 < b ? a[parseInt(f + 1)] : a[0],
                l = .5 * ((g.x - 0) * (h.y - 0) - (g.y - 0) * (h.x - 0)),
                d = d + l;
            c.x += l * e * (0 + g.x + h.x);
            c.y += l * e * (0 + g.y + h.y)
        }
        c.x *= 1 / d;
        c.y *= 1 / d;
        return c
    };
    f.ComputeOBB = function(a, b, c) {
        void 0 === c && (c = 0);
        var d, e = new Vector(c + 1);
        for (d = 0; d < c; ++d) e[d] = b[d];
        e[c] = e[0];
        b = Number.MAX_VALUE;
        for (d = 1; d <= c; ++d) {
            for (var f = e[parseInt(d - 1)], g = e[d].x - f.x, h = e[d].y - f.y, l = Math.sqrt(g * g + h * h), g = g / l, h = h / l, m = -h, p = g, q = l = Number.MAX_VALUE, y = -Number.MAX_VALUE, A = -Number.MAX_VALUE, B = 0; B < c; ++B) {
                var K = e[B].x - f.x,
                    fc = e[B].y - f.y,
                    kc = g * K + h * fc,
                    K = m * K + p * fc;
                kc < l && (l = kc);
                K < q && (q = K);
                kc > y && (y = kc);
                K > A && (A = K)
            }
            B = (y - l) * (A - q);
            B < .95 * b && (b = B, a.R.col1.x = g, a.R.col1.y = h, a.R.col2.x = m, a.R.col2.y = p, g = .5 * (l + y), h = .5 * (q + A), m = a.R, a.center.x = f.x + (m.col1.x * g + m.col2.x * h), a.center.y = f.y + (m.col1.y * g + m.col2.y *
                h), a.extents.x = .5 * (y - l), a.extents.y = .5 * (A - q))
        }
    };
    Box2D.postDefs.push(function() {
        Box2D.Collision.Shapes.b2PolygonShape.s_mat = new h
    });
    g.b2Shape = function() {};
    g.prototype.Copy = function() {
        return null
    };
    g.prototype.Set = function(a) {
        this.m_radius = a.m_radius
    };
    g.prototype.GetType = function() {
        return this.m_type
    };
    g.prototype.TestPoint = function() {
        return !1
    };
    g.prototype.RayCast = function() {
        return !1
    };
    g.prototype.ComputeAABB = function() {};
    g.prototype.ComputeMass = function() {};
    g.prototype.ComputeSubmergedArea = function() {
        return 0
    };
    g.TestOverlap = function(a, b, c, d) {
        var e = new y;
        e.proxyA = new B;
        e.proxyA.Set(a);
        e.proxyB = new B;
        e.proxyB.Set(c);
        e.transformA = b;
        e.transformB = d;
        e.useRadii = !0;
        a = new K;
        a.count = 0;
        b = new A;
        p.Distance(b, a, e);
        return b.distance < 10 * Number.MIN_VALUE
    };
    g.prototype.b2Shape = function() {
        this.m_type = g.e_unknownShape;
        this.m_radius = a.b2_linearSlop
    };
    Box2D.postDefs.push(function() {
        Box2D.Collision.Shapes.b2Shape.e_unknownShape = -1;
        Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
        Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
        Box2D.Collision.Shapes.b2Shape.e_edgeShape =
            2;
        Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
        Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
        Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
        Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = -1
    })
})();
(function() {
    var a = Box2D.Common.b2Color,
        c = Box2D.Common.b2Settings,
        b = Box2D.Common.Math.b2Math;
    a.b2Color = function() {
        this._b = this._g = this._r = 0
    };
    a.prototype.b2Color = function(a, c, f) {
        void 0 === a && (a = 0);
        void 0 === c && (c = 0);
        void 0 === f && (f = 0);
        this._r = Box2D.parseUInt(255 * b.Clamp(a, 0, 1));
        this._g = Box2D.parseUInt(255 * b.Clamp(c, 0, 1));
        this._b = Box2D.parseUInt(255 * b.Clamp(f, 0, 1))
    };
    a.prototype.Set = function(a, c, f) {
        void 0 === a && (a = 0);
        void 0 === c && (c = 0);
        void 0 === f && (f = 0);
        this._r = Box2D.parseUInt(255 * b.Clamp(a, 0, 1));
        this._g =
            Box2D.parseUInt(255 * b.Clamp(c, 0, 1));
        this._b = Box2D.parseUInt(255 * b.Clamp(f, 0, 1))
    };
    Object.defineProperty(a.prototype, "r", {
        enumerable: !1,
        configurable: !0,
        set: function(a) {
            void 0 === a && (a = 0);
            this._r = Box2D.parseUInt(255 * b.Clamp(a, 0, 1))
        }
    });
    Object.defineProperty(a.prototype, "g", {
        enumerable: !1,
        configurable: !0,
        set: function(a) {
            void 0 === a && (a = 0);
            this._g = Box2D.parseUInt(255 * b.Clamp(a, 0, 1))
        }
    });
    Object.defineProperty(a.prototype, "b", {
        enumerable: !1,
        configurable: !0,
        set: function(a) {
            void 0 === a && (a = 0);
            this._b = Box2D.parseUInt(255 *
                b.Clamp(a, 0, 1))
        }
    });
    Object.defineProperty(a.prototype, "color", {
        enumerable: !1,
        configurable: !0,
        get: function() {
            return this._r << 16 | this._g << 8 | this._b
        }
    });
    c.b2Settings = function() {};
    c.b2MixFriction = function(a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        return Math.sqrt(a * b)
    };
    c.b2MixRestitution = function(a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        return a > b ? a : b
    };
    c.b2Assert = function(a) {
        if (!a) throw "Assertion Failed";
    };
    Box2D.postDefs.push(function() {
        Box2D.Common.b2Settings.VERSION = "2.1alpha";
        Box2D.Common.b2Settings.USHRT_MAX =
            65535;
        Box2D.Common.b2Settings.b2_pi = Math.PI;
        Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
        Box2D.Common.b2Settings.b2_aabbExtension = .1;
        Box2D.Common.b2Settings.b2_aabbMultiplier = 2;
        Box2D.Common.b2Settings.b2_polygonRadius = 2 * c.b2_linearSlop;
        Box2D.Common.b2Settings.b2_linearSlop = .005;
        Box2D.Common.b2Settings.b2_angularSlop = 2 / 180 * c.b2_pi;
        Box2D.Common.b2Settings.b2_toiSlop = 8 * c.b2_linearSlop;
        Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
        Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
        Box2D.Common.b2Settings.b2_velocityThreshold =
            1;
        Box2D.Common.b2Settings.b2_maxLinearCorrection = .2;
        Box2D.Common.b2Settings.b2_maxAngularCorrection = 8 / 180 * c.b2_pi;
        Box2D.Common.b2Settings.b2_maxTranslation = 2;
        Box2D.Common.b2Settings.b2_maxTranslationSquared = c.b2_maxTranslation * c.b2_maxTranslation;
        Box2D.Common.b2Settings.b2_maxRotation = .5 * c.b2_pi;
        Box2D.Common.b2Settings.b2_maxRotationSquared = c.b2_maxRotation * c.b2_maxRotation;
        Box2D.Common.b2Settings.b2_contactBaumgarte = .2;
        Box2D.Common.b2Settings.b2_timeToSleep = .5;
        Box2D.Common.b2Settings.b2_linearSleepTolerance =
            .01;
        Box2D.Common.b2Settings.b2_angularSleepTolerance = 2 / 180 * c.b2_pi
    })
})();
(function() {
    var a = Box2D.Common.Math.b2Mat22,
        c = Box2D.Common.Math.b2Mat33,
        b = Box2D.Common.Math.b2Math,
        d = Box2D.Common.Math.b2Sweep,
        e = Box2D.Common.Math.b2Transform,
        f = Box2D.Common.Math.b2Vec2,
        g = Box2D.Common.Math.b2Vec3;
    a.b2Mat22 = function() {
        this.col1 = new f;
        this.col2 = new f
    };
    a.prototype.b2Mat22 = function() {
        this.SetIdentity()
    };
    a.FromAngle = function(b) {
        void 0 === b && (b = 0);
        var c = new a;
        c.Set(b);
        return c
    };
    a.FromVV = function(b, c) {
        var d = new a;
        d.SetVV(b, c);
        return d
    };
    a.prototype.Set = function(a) {
        void 0 === a && (a = 0);
        var b =
            Math.cos(a);
        a = Math.sin(a);
        this.col1.x = b;
        this.col2.x = -a;
        this.col1.y = a;
        this.col2.y = b
    };
    a.prototype.SetVV = function(a, b) {
        this.col1.SetV(a);
        this.col2.SetV(b)
    };
    a.prototype.Copy = function() {
        var b = new a;
        b.SetM(this);
        return b
    };
    a.prototype.SetM = function(a) {
        this.col1.SetV(a.col1);
        this.col2.SetV(a.col2)
    };
    a.prototype.AddM = function(a) {
        this.col1.x += a.col1.x;
        this.col1.y += a.col1.y;
        this.col2.x += a.col2.x;
        this.col2.y += a.col2.y
    };
    a.prototype.SetIdentity = function() {
        this.col1.x = 1;
        this.col2.x = 0;
        this.col1.y = 0;
        this.col2.y = 1
    };
    a.prototype.SetZero = function() {
        this.col1.x = 0;
        this.col2.x = 0;
        this.col1.y = 0;
        this.col2.y = 0
    };
    a.prototype.GetAngle = function() {
        return Math.atan2(this.col1.y, this.col1.x)
    };
    a.prototype.GetInverse = function(a) {
        var b = this.col1.x,
            c = this.col2.x,
            d = this.col1.y,
            e = this.col2.y,
            f = b * e - c * d;
        0 != f && (f = 1 / f);
        a.col1.x = f * e;
        a.col2.x = -f * c;
        a.col1.y = -f * d;
        a.col2.y = f * b;
        return a
    };
    a.prototype.Solve = function(a, b, c) {
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        var d = this.col1.x,
            e = this.col2.x,
            f = this.col1.y,
            g = this.col2.y,
            B = d * g - e * f;
        0 != B && (B = 1 / B);
        a.x = B * (g * b - e * c);
        a.y = B * (d * c - f * b);
        return a
    };
    a.prototype.Abs = function() {
        this.col1.Abs();
        this.col2.Abs()
    };
    c.b2Mat33 = function() {
        this.col1 = new g;
        this.col2 = new g;
        this.col3 = new g
    };
    c.prototype.b2Mat33 = function(a, b, c) {
        void 0 === a && (a = null);
        void 0 === b && (b = null);
        void 0 === c && (c = null);
        a || b || c ? (this.col1.SetV(a), this.col2.SetV(b), this.col3.SetV(c)) : (this.col1.SetZero(), this.col2.SetZero(), this.col3.SetZero())
    };
    c.prototype.SetVVV = function(a, b, c) {
        this.col1.SetV(a);
        this.col2.SetV(b);
        this.col3.SetV(c)
    };
    c.prototype.Copy =
        function() {
            return new c(this.col1, this.col2, this.col3)
        };
    c.prototype.SetM = function(a) {
        this.col1.SetV(a.col1);
        this.col2.SetV(a.col2);
        this.col3.SetV(a.col3)
    };
    c.prototype.AddM = function(a) {
        this.col1.x += a.col1.x;
        this.col1.y += a.col1.y;
        this.col1.z += a.col1.z;
        this.col2.x += a.col2.x;
        this.col2.y += a.col2.y;
        this.col2.z += a.col2.z;
        this.col3.x += a.col3.x;
        this.col3.y += a.col3.y;
        this.col3.z += a.col3.z
    };
    c.prototype.SetIdentity = function() {
        this.col1.x = 1;
        this.col2.x = 0;
        this.col3.x = 0;
        this.col1.y = 0;
        this.col2.y = 1;
        this.col3.y = 0;
        this.col1.z = 0;
        this.col2.z = 0;
        this.col3.z = 1
    };
    c.prototype.SetZero = function() {
        this.col1.x = 0;
        this.col2.x = 0;
        this.col3.x = 0;
        this.col1.y = 0;
        this.col2.y = 0;
        this.col3.y = 0;
        this.col1.z = 0;
        this.col2.z = 0;
        this.col3.z = 0
    };
    c.prototype.Solve22 = function(a, b, c) {
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        var d = this.col1.x,
            e = this.col2.x,
            f = this.col1.y,
            g = this.col2.y,
            B = d * g - e * f;
        0 != B && (B = 1 / B);
        a.x = B * (g * b - e * c);
        a.y = B * (d * c - f * b);
        return a
    };
    c.prototype.Solve33 = function(a, b, c, d) {
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        void 0 === d && (d = 0);
        var e = this.col1.x,
            f = this.col1.y,
            g = this.col1.z,
            B = this.col2.x,
            K = this.col2.y,
            H = this.col2.z,
            E = this.col3.x,
            M = this.col3.y,
            Xb = this.col3.z,
            Zb = e * (K * Xb - H * M) + f * (H * E - B * Xb) + g * (B * M - K * E);
        0 != Zb && (Zb = 1 / Zb);
        a.x = Zb * (b * (K * Xb - H * M) + c * (H * E - B * Xb) + d * (B * M - K * E));
        a.y = Zb * (e * (c * Xb - d * M) + f * (d * E - b * Xb) + g * (b * M - c * E));
        a.z = Zb * (e * (K * d - H * c) + f * (H * b - B * d) + g * (B * c - K * b));
        return a
    };
    b.b2Math = function() {};
    b.IsValid = function(a) {
        void 0 === a && (a = 0);
        return isFinite(a)
    };
    b.Dot = function(a, b) {
        return a.x * b.x + a.y * b.y
    };
    b.CrossVV = function(a, b) {
        return a.x * b.y - a.y * b.x
    };
    b.CrossVF =
        function(a, b) {
            void 0 === b && (b = 0);
            return new f(b * a.y, -b * a.x)
        };
    b.CrossFV = function(a, b) {
        void 0 === a && (a = 0);
        return new f(-a * b.y, a * b.x)
    };
    b.MulMV = function(a, b) {
        return new f(a.col1.x * b.x + a.col2.x * b.y, a.col1.y * b.x + a.col2.y * b.y)
    };
    b.MulTMV = function(a, c) {
        return new f(b.Dot(c, a.col1), b.Dot(c, a.col2))
    };
    b.MulX = function(a, c) {
        var d = b.MulMV(a.R, c);
        d.x += a.position.x;
        d.y += a.position.y;
        return d
    };
    b.MulXT = function(a, c) {
        var d = b.SubtractVV(c, a.position),
            e = d.x * a.R.col1.x + d.y * a.R.col1.y;
        d.y = d.x * a.R.col2.x + d.y * a.R.col2.y;
        d.x =
            e;
        return d
    };
    b.AddVV = function(a, b) {
        return new f(a.x + b.x, a.y + b.y)
    };
    b.SubtractVV = function(a, b) {
        return new f(a.x - b.x, a.y - b.y)
    };
    b.Distance = function(a, b) {
        var c = a.x - b.x,
            d = a.y - b.y;
        return Math.sqrt(c * c + d * d)
    };
    b.DistanceSquared = function(a, b) {
        var c = a.x - b.x,
            d = a.y - b.y;
        return c * c + d * d
    };
    b.MulFV = function(a, b) {
        void 0 === a && (a = 0);
        return new f(a * b.x, a * b.y)
    };
    b.AddMM = function(c, d) {
        return a.FromVV(b.AddVV(c.col1, d.col1), b.AddVV(c.col2, d.col2))
    };
    b.MulMM = function(c, d) {
        return a.FromVV(b.MulMV(c, d.col1), b.MulMV(c, d.col2))
    };
    b.MulTMM =
        function(c, d) {
            var e = new f(b.Dot(c.col1, d.col1), b.Dot(c.col2, d.col1)),
                g = new f(b.Dot(c.col1, d.col2), b.Dot(c.col2, d.col2));
            return a.FromVV(e, g)
        };
    b.Abs = function(a) {
        void 0 === a && (a = 0);
        return 0 < a ? a : -a
    };
    b.AbsV = function(a) {
        return new f(b.Abs(a.x), b.Abs(a.y))
    };
    b.AbsM = function(c) {
        return a.FromVV(b.AbsV(c.col1), b.AbsV(c.col2))
    };
    b.Min = function(a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        return a < b ? a : b
    };
    b.MinV = function(a, c) {
        return new f(b.Min(a.x, c.x), b.Min(a.y, c.y))
    };
    b.Max = function(a, b) {
        void 0 === a && (a = 0);
        void 0 ===
            b && (b = 0);
        return a > b ? a : b
    };
    b.MaxV = function(a, c) {
        return new f(b.Max(a.x, c.x), b.Max(a.y, c.y))
    };
    b.Clamp = function(a, b, c) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        return a < b ? b : a > c ? c : a
    };
    b.ClampV = function(a, c, d) {
        return b.MaxV(c, b.MinV(a, d))
    };
    b.Swap = function(a, b) {
        var c = a[0];
        a[0] = b[0];
        b[0] = c
    };
    b.Random = function() {
        return 2 * Math.random() - 1
    };
    b.RandomRange = function(a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        return (b - a) * Math.random() + a
    };
    b.NextPowerOfTwo = function(a) {
        void 0 === a && (a = 0);
        a |= a >> 1 & 2147483647;
        a |= a >> 2 & 1073741823;
        a |= a >> 4 & 268435455;
        a |= a >> 8 & 16777215;
        return (a | a >> 16 & 65535) + 1
    };
    b.IsPowerOfTwo = function(a) {
        void 0 === a && (a = 0);
        return 0 < a && 0 == (a & a - 1)
    };
    Box2D.postDefs.push(function() {
        Box2D.Common.Math.b2Math.b2Vec2_zero = new f(0, 0);
        Box2D.Common.Math.b2Math.b2Mat22_identity = a.FromVV(new f(1, 0), new f(0, 1));
        Box2D.Common.Math.b2Math.b2Transform_identity = new e(b.b2Vec2_zero, b.b2Mat22_identity)
    });
    d.b2Sweep = function() {
        this.localCenter = new f;
        this.c0 = new f;
        this.c = new f
    };
    d.prototype.Set = function(a) {
        this.localCenter.SetV(a.localCenter);
        this.c0.SetV(a.c0);
        this.c.SetV(a.c);
        this.a0 = a.a0;
        this.a = a.a;
        this.t0 = a.t0
    };
    d.prototype.Copy = function() {
        var a = new d;
        a.localCenter.SetV(this.localCenter);
        a.c0.SetV(this.c0);
        a.c.SetV(this.c);
        a.a0 = this.a0;
        a.a = this.a;
        a.t0 = this.t0;
        return a
    };
    d.prototype.GetTransform = function(a, b) {
        void 0 === b && (b = 0);
        a.position.x = (1 - b) * this.c0.x + b * this.c.x;
        a.position.y = (1 - b) * this.c0.y + b * this.c.y;
        a.R.Set((1 - b) * this.a0 + b * this.a);
        var c = a.R;
        a.position.x -= c.col1.x * this.localCenter.x + c.col2.x * this.localCenter.y;
        a.position.y -= c.col1.y *
            this.localCenter.x + c.col2.y * this.localCenter.y
    };
    d.prototype.Advance = function(a) {
        void 0 === a && (a = 0);
        if (this.t0 < a && 1 - this.t0 > Number.MIN_VALUE) {
            var b = (a - this.t0) / (1 - this.t0);
            this.c0.x = (1 - b) * this.c0.x + b * this.c.x;
            this.c0.y = (1 - b) * this.c0.y + b * this.c.y;
            this.a0 = (1 - b) * this.a0 + b * this.a;
            this.t0 = a
        }
    };
    e.b2Transform = function() {
        this.position = new f;
        this.R = new a
    };
    e.prototype.b2Transform = function(a, b) {
        void 0 === a && (a = null);
        void 0 === b && (b = null);
        a && (this.position.SetV(a), this.R.SetM(b))
    };
    e.prototype.Initialize = function(a,
        b) {
        this.position.SetV(a);
        this.R.SetM(b)
    };
    e.prototype.SetIdentity = function() {
        this.position.SetZero();
        this.R.SetIdentity()
    };
    e.prototype.Set = function(a) {
        this.position.SetV(a.position);
        this.R.SetM(a.R)
    };
    e.prototype.GetAngle = function() {
        return Math.atan2(this.R.col1.y, this.R.col1.x)
    };
    f.b2Vec2 = function() {};
    f.prototype.b2Vec2 = function(a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.x = a;
        this.y = b
    };
    f.prototype.SetZero = function() {
        this.y = this.x = 0
    };
    f.prototype.Set = function(a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.x = a;
        this.y = b
    };
    f.prototype.SetV = function(a) {
        this.x = a.x;
        this.y = a.y
    };
    f.prototype.GetNegative = function() {
        return new f(-this.x, -this.y)
    };
    f.prototype.NegativeSelf = function() {
        this.x = -this.x;
        this.y = -this.y
    };
    f.Make = function(a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        return new f(a, b)
    };
    f.prototype.Copy = function() {
        return new f(this.x, this.y)
    };
    f.prototype.Add = function(a) {
        this.x += a.x;
        this.y += a.y
    };
    f.prototype.Subtract = function(a) {
        this.x -= a.x;
        this.y -= a.y
    };
    f.prototype.Multiply = function(a) {
        void 0 === a && (a = 0);
        this.x *=
            a;
        this.y *= a
    };
    f.prototype.MulM = function(a) {
        var b = this.x;
        this.x = a.col1.x * b + a.col2.x * this.y;
        this.y = a.col1.y * b + a.col2.y * this.y
    };
    f.prototype.MulTM = function(a) {
        var c = b.Dot(this, a.col1);
        this.y = b.Dot(this, a.col2);
        this.x = c
    };
    f.prototype.CrossVF = function(a) {
        void 0 === a && (a = 0);
        var b = this.x;
        this.x = a * this.y;
        this.y = -a * b
    };
    f.prototype.CrossFV = function(a) {
        void 0 === a && (a = 0);
        var b = this.x;
        this.x = -a * this.y;
        this.y = a * b
    };
    f.prototype.MinV = function(a) {
        this.x = this.x < a.x ? this.x : a.x;
        this.y = this.y < a.y ? this.y : a.y
    };
    f.prototype.MaxV =
        function(a) {
            this.x = this.x > a.x ? this.x : a.x;
            this.y = this.y > a.y ? this.y : a.y
        };
    f.prototype.Abs = function() {
        0 > this.x && (this.x = -this.x);
        0 > this.y && (this.y = -this.y)
    };
    f.prototype.Length = function() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    };
    f.prototype.LengthSquared = function() {
        return this.x * this.x + this.y * this.y
    };
    f.prototype.Normalize = function() {
        var a = Math.sqrt(this.x * this.x + this.y * this.y);
        if (a < Number.MIN_VALUE) return 0;
        var b = 1 / a;
        this.x *= b;
        this.y *= b;
        return a
    };
    f.prototype.IsValid = function() {
        return b.IsValid(this.x) &&
            b.IsValid(this.y)
    };
    g.b2Vec3 = function() {};
    g.prototype.b2Vec3 = function(a, b, c) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        this.x = a;
        this.y = b;
        this.z = c
    };
    g.prototype.SetZero = function() {
        this.x = this.y = this.z = 0
    };
    g.prototype.Set = function(a, b, c) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        this.x = a;
        this.y = b;
        this.z = c
    };
    g.prototype.SetV = function(a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z
    };
    g.prototype.GetNegative = function() {
        return new g(-this.x, -this.y, -this.z)
    };
    g.prototype.NegativeSelf = function() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z
    };
    g.prototype.Copy = function() {
        return new g(this.x, this.y, this.z)
    };
    g.prototype.Add = function(a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z
    };
    g.prototype.Subtract = function(a) {
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z
    };
    g.prototype.Multiply = function(a) {
        void 0 === a && (a = 0);
        this.x *= a;
        this.y *= a;
        this.z *= a
    }
})();
(function() {
    var a = Box2D.Common.Math.b2Math,
        c = Box2D.Common.Math.b2Sweep,
        b = Box2D.Common.Math.b2Transform,
        d = Box2D.Common.Math.b2Vec2,
        e = Box2D.Common.b2Color,
        f = Box2D.Common.b2Settings,
        g = Box2D.Collision.b2AABB,
        h = Box2D.Collision.b2ContactPoint,
        l = Box2D.Collision.b2DynamicTreeBroadPhase,
        m = Box2D.Collision.b2RayCastInput,
        q = Box2D.Collision.b2RayCastOutput,
        p = Box2D.Collision.Shapes.b2CircleShape,
        y = Box2D.Collision.Shapes.b2EdgeShape,
        A = Box2D.Collision.Shapes.b2MassData,
        B = Box2D.Collision.Shapes.b2PolygonShape,
        K = Box2D.Collision.Shapes.b2Shape,
        H = Box2D.Dynamics.b2Body,
        E = Box2D.Dynamics.b2BodyDef,
        M = Box2D.Dynamics.b2ContactFilter,
        Xb = Box2D.Dynamics.b2ContactImpulse,
        Zb = Box2D.Dynamics.b2ContactListener,
        aa = Box2D.Dynamics.b2ContactManager,
        Yb = Box2D.Dynamics.b2DebugDraw,
        $b = Box2D.Dynamics.b2DestructionListener,
        ac = Box2D.Dynamics.b2FilterData,
        bc = Box2D.Dynamics.b2Fixture,
        ec = Box2D.Dynamics.b2FixtureDef,
        jc = Box2D.Dynamics.b2Island,
        cc = Box2D.Dynamics.b2TimeStep,
        dc = Box2D.Dynamics.b2World,
        gc = Box2D.Dynamics.Contacts.b2Contact,
        hc = Box2D.Dynamics.Contacts.b2ContactFactory,
        fc = Box2D.Dynamics.Contacts.b2ContactSolver,
        kc = Box2D.Dynamics.Joints.b2Joint,
        lc = Box2D.Dynamics.Joints.b2PulleyJoint;
    H.b2Body = function() {
        this.m_xf = new b;
        this.m_sweep = new c;
        this.m_linearVelocity = new d;
        this.m_force = new d
    };
    H.prototype.connectEdges = function(b, c, d) {
        void 0 === d && (d = 0);
        var e = Math.atan2(c.GetDirectionVector().y, c.GetDirectionVector().x);
        d = a.MulFV(Math.tan(.5 * (e - d)), c.GetDirectionVector());
        d = a.SubtractVV(d, c.GetNormalVector());
        d = a.MulFV(f.b2_toiSlop, d);
        d = a.AddVV(d, c.GetVertex1());
        var g = a.AddVV(b.GetDirectionVector(),
            c.GetDirectionVector());
        g.Normalize();
        var h = 0 < a.Dot(b.GetDirectionVector(), c.GetNormalVector());
        b.SetNextEdge(c, d, g, h);
        c.SetPrevEdge(b, d, g, h);
        return e
    };
    H.prototype.CreateFixture = function(a) {
        if (1 == this.m_world.IsLocked()) return null;
        var b = new bc;
        b.Create(this, this.m_xf, a);
        this.m_flags & H.e_activeFlag && b.CreateProxy(this.m_world.m_contactManager.m_broadPhase, this.m_xf);
        b.m_next = this.m_fixtureList;
        this.m_fixtureList = b;
        ++this.m_fixtureCount;
        b.m_body = this;
        0 < b.m_density && this.ResetMassData();
        this.m_world.m_flags |=
            dc.e_newFixture;
        return b
    };
    H.prototype.CreateFixture2 = function(a, b) {
        void 0 === b && (b = 0);
        var c = new ec;
        c.shape = a;
        c.density = b;
        return this.CreateFixture(c)
    };
    H.prototype.DestroyFixture = function(a) {
        if (1 != this.m_world.IsLocked()) {
            for (var b = this.m_fixtureList, c = null; null != b;) {
                if (b == a) {
                    c ? c.m_next = a.m_next : this.m_fixtureList = a.m_next;
                    break
                }
                c = b;
                b = b.m_next
            }
            for (b = this.m_contactList; b;) {
                var c = b.contact,
                    b = b.next,
                    d = c.GetFixtureA(),
                    e = c.GetFixtureB();
                a != d && a != e || this.m_world.m_contactManager.Destroy(c)
            }
            this.m_flags & H.e_activeFlag &&
                a.DestroyProxy(this.m_world.m_contactManager.m_broadPhase);
            a.Destroy();
            a.m_body = null;
            a.m_next = null;
            --this.m_fixtureCount;
            this.ResetMassData()
        }
    };
    H.prototype.SetPositionAndAngle = function(a, b) {
        void 0 === b && (b = 0);
        var c;
        if (1 != this.m_world.IsLocked()) {
            this.m_xf.R.Set(b);
            this.m_xf.position.SetV(a);
            c = this.m_xf.R;
            var d = this.m_sweep.localCenter;
            this.m_sweep.c.x = c.col1.x * d.x + c.col2.x * d.y;
            this.m_sweep.c.y = c.col1.y * d.x + c.col2.y * d.y;
            this.m_sweep.c.x += this.m_xf.position.x;
            this.m_sweep.c.y += this.m_xf.position.y;
            this.m_sweep.c0.SetV(this.m_sweep.c);
            this.m_sweep.a0 = this.m_sweep.a = b;
            d = this.m_world.m_contactManager.m_broadPhase;
            for (c = this.m_fixtureList; c; c = c.m_next) c.Synchronize(d, this.m_xf, this.m_xf);
            this.m_world.m_contactManager.FindNewContacts()
        }
    };
    H.prototype.SetTransform = function(a) {
        this.SetPositionAndAngle(a.position, a.GetAngle())
    };
    H.prototype.GetTransform = function() {
        return this.m_xf
    };
    H.prototype.GetPosition = function() {
        return this.m_xf.position
    };
    H.prototype.SetPosition = function(a) {
        this.SetPositionAndAngle(a, this.GetAngle())
    };
    H.prototype.GetAngle =
        function() {
            return this.m_sweep.a
        };
    H.prototype.SetAngle = function(a) {
        void 0 === a && (a = 0);
        this.SetPositionAndAngle(this.GetPosition(), a)
    };
    H.prototype.GetWorldCenter = function() {
        return this.m_sweep.c
    };
    H.prototype.GetLocalCenter = function() {
        return this.m_sweep.localCenter
    };
    H.prototype.SetLinearVelocity = function(a) {
        this.m_type != H.b2_staticBody && this.m_linearVelocity.SetV(a)
    };
    H.prototype.GetLinearVelocity = function() {
        return this.m_linearVelocity
    };
    H.prototype.SetAngularVelocity = function(a) {
        void 0 === a && (a = 0);
        this.m_type !=
            H.b2_staticBody && (this.m_angularVelocity = a)
    };
    H.prototype.GetAngularVelocity = function() {
        return this.m_angularVelocity
    };
    H.prototype.GetDefinition = function() {
        var a = new E;
        a.type = this.GetType();
        a.allowSleep = (this.m_flags & H.e_allowSleepFlag) == H.e_allowSleepFlag;
        a.angle = this.GetAngle();
        a.angularDamping = this.m_angularDamping;
        a.angularVelocity = this.m_angularVelocity;
        a.fixedRotation = (this.m_flags & H.e_fixedRotationFlag) == H.e_fixedRotationFlag;
        a.bullet = (this.m_flags & H.e_bulletFlag) == H.e_bulletFlag;
        a.awake = (this.m_flags &
            H.e_awakeFlag) == H.e_awakeFlag;
        a.linearDamping = this.m_linearDamping;
        a.linearVelocity.SetV(this.GetLinearVelocity());
        a.position = this.GetPosition();
        a.userData = this.GetUserData();
        return a
    };
    H.prototype.ApplyForce = function(a, b) {
        this.m_type == H.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_force.x += a.x, this.m_force.y += a.y, this.m_torque += (b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x)
    };
    H.prototype.ApplyTorque = function(a) {
        void 0 === a && (a = 0);
        this.m_type == H.b2_dynamicBody && (0 == this.IsAwake() &&
            this.SetAwake(!0), this.m_torque += a)
    };
    H.prototype.ApplyImpulse = function(a, b) {
        this.m_type == H.b2_dynamicBody && (0 == this.IsAwake() && this.SetAwake(!0), this.m_linearVelocity.x += this.m_invMass * a.x, this.m_linearVelocity.y += this.m_invMass * a.y, this.m_angularVelocity += this.m_invI * ((b.x - this.m_sweep.c.x) * a.y - (b.y - this.m_sweep.c.y) * a.x))
    };
    H.prototype.Split = function(b) {
        for (var c = this.GetLinearVelocity().Copy(), d = this.GetAngularVelocity(), e = this.GetWorldCenter(), f = this.m_world.CreateBody(this.GetDefinition()), g,
                h = this.m_fixtureList; h;)
            if (b(h)) {
                var l = h.m_next;
                g ? g.m_next = l : this.m_fixtureList = l;
                this.m_fixtureCount--;
                h.m_next = f.m_fixtureList;
                f.m_fixtureList = h;
                f.m_fixtureCount++;
                h.m_body = f;
                h = l
            } else g = h, h = h.m_next;
        this.ResetMassData();
        f.ResetMassData();
        g = this.GetWorldCenter();
        b = f.GetWorldCenter();
        g = a.AddVV(c, a.CrossFV(d, a.SubtractVV(g, e)));
        c = a.AddVV(c, a.CrossFV(d, a.SubtractVV(b, e)));
        this.SetLinearVelocity(g);
        f.SetLinearVelocity(c);
        this.SetAngularVelocity(d);
        f.SetAngularVelocity(d);
        this.SynchronizeFixtures();
        f.SynchronizeFixtures();
        return f
    };
    H.prototype.Merge = function(a) {
        var b;
        for (b = a.m_fixtureList; b;) {
            var c = b.m_next;
            a.m_fixtureCount--;
            b.m_next = this.m_fixtureList;
            this.m_fixtureList = b;
            this.m_fixtureCount++;
            b.m_body = e;
            b = c
        }
        d.m_fixtureCount = 0;
        var d = this,
            e = a;
        d.GetWorldCenter();
        e.GetWorldCenter();
        d.GetLinearVelocity().Copy();
        e.GetLinearVelocity().Copy();
        d.GetAngularVelocity();
        e.GetAngularVelocity();
        d.ResetMassData();
        this.SynchronizeFixtures()
    };
    H.prototype.GetMass = function() {
        return this.m_mass
    };
    H.prototype.GetInertia = function() {
        return this.m_I
    };
    H.prototype.GetMassData = function(a) {
        a.mass = this.m_mass;
        a.I = this.m_I;
        a.center.SetV(this.m_sweep.localCenter)
    };
    H.prototype.SetMassData = function(b) {
        f.b2Assert(0 == this.m_world.IsLocked());
        if (1 != this.m_world.IsLocked() && this.m_type == H.b2_dynamicBody) {
            this.m_invI = this.m_I = this.m_invMass = 0;
            this.m_mass = b.mass;
            0 >= this.m_mass && (this.m_mass = 1);
            this.m_invMass = 1 / this.m_mass;
            0 < b.I && 0 == (this.m_flags & H.e_fixedRotationFlag) && (this.m_I = b.I - this.m_mass * (b.center.x * b.center.x + b.center.y * b.center.y), this.m_invI = 1 / this.m_I);
            var c = this.m_sweep.c.Copy();
            this.m_sweep.localCenter.SetV(b.center);
            this.m_sweep.c0.SetV(a.MulX(this.m_xf, this.m_sweep.localCenter));
            this.m_sweep.c.SetV(this.m_sweep.c0);
            this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - c.y);
            this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - c.x)
        }
    };
    H.prototype.ResetMassData = function() {
        this.m_invI = this.m_I = this.m_invMass = this.m_mass = 0;
        this.m_sweep.localCenter.SetZero();
        if (this.m_type != H.b2_staticBody && this.m_type != H.b2_kinematicBody) {
            for (var b =
                    d.Make(0, 0), c = this.m_fixtureList; c; c = c.m_next)
                if (0 != c.m_density) {
                    var e = c.GetMassData();
                    this.m_mass += e.mass;
                    b.x += e.center.x * e.mass;
                    b.y += e.center.y * e.mass;
                    this.m_I += e.I
                }
            0 < this.m_mass ? (this.m_invMass = 1 / this.m_mass, b.x *= this.m_invMass, b.y *= this.m_invMass) : this.m_invMass = this.m_mass = 1;
            0 < this.m_I && 0 == (this.m_flags & H.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * (b.x * b.x + b.y * b.y), this.m_I *= this.m_inertiaScale, f.b2Assert(0 < this.m_I), this.m_invI = 1 / this.m_I) : this.m_invI = this.m_I = 0;
            c = this.m_sweep.c.Copy();
            this.m_sweep.localCenter.SetV(b);
            this.m_sweep.c0.SetV(a.MulX(this.m_xf, this.m_sweep.localCenter));
            this.m_sweep.c.SetV(this.m_sweep.c0);
            this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - c.y);
            this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - c.x)
        }
    };
    H.prototype.GetWorldPoint = function(a) {
        var b = this.m_xf.R;
        a = new d(b.col1.x * a.x + b.col2.x * a.y, b.col1.y * a.x + b.col2.y * a.y);
        a.x += this.m_xf.position.x;
        a.y += this.m_xf.position.y;
        return a
    };
    H.prototype.GetWorldVector = function(b) {
        return a.MulMV(this.m_xf.R, b)
    };
    H.prototype.GetLocalPoint =
        function(b) {
            return a.MulXT(this.m_xf, b)
        };
    H.prototype.GetLocalVector = function(b) {
        return a.MulTMV(this.m_xf.R, b)
    };
    H.prototype.GetLinearVelocityFromWorldPoint = function(a) {
        return new d(this.m_linearVelocity.x - this.m_angularVelocity * (a.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (a.x - this.m_sweep.c.x))
    };
    H.prototype.GetLinearVelocityFromLocalPoint = function(a) {
        var b = this.m_xf.R;
        a = new d(b.col1.x * a.x + b.col2.x * a.y, b.col1.y * a.x + b.col2.y * a.y);
        a.x += this.m_xf.position.x;
        a.y += this.m_xf.position.y;
        return new d(this.m_linearVelocity.x - this.m_angularVelocity * (a.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (a.x - this.m_sweep.c.x))
    };
    H.prototype.GetLinearDamping = function() {
        return this.m_linearDamping
    };
    H.prototype.SetLinearDamping = function(a) {
        void 0 === a && (a = 0);
        this.m_linearDamping = a
    };
    H.prototype.GetAngularDamping = function() {
        return this.m_angularDamping
    };
    H.prototype.SetAngularDamping = function(a) {
        void 0 === a && (a = 0);
        this.m_angularDamping = a
    };
    H.prototype.SetType = function(a) {
        void 0 ===
            a && (a = 0);
        if (this.m_type != a)
            for (this.m_type = a, this.ResetMassData(), this.m_type == H.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0), this.SetAwake(!0), this.m_force.SetZero(), this.m_torque = 0, a = this.m_contactList; a; a = a.next) a.contact.FlagForFiltering()
    };
    H.prototype.GetType = function() {
        return this.m_type
    };
    H.prototype.SetBullet = function(a) {
        this.m_flags = a ? this.m_flags | H.e_bulletFlag : this.m_flags & ~H.e_bulletFlag
    };
    H.prototype.IsBullet = function() {
        return (this.m_flags & H.e_bulletFlag) ==
            H.e_bulletFlag
    };
    H.prototype.SetSleepingAllowed = function(a) {
        a ? this.m_flags |= H.e_allowSleepFlag : (this.m_flags &= ~H.e_allowSleepFlag, this.SetAwake(!0))
    };
    H.prototype.SetAwake = function(a) {
        a ? (this.m_flags |= H.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~H.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0)
    };
    H.prototype.IsAwake = function() {
        return (this.m_flags & H.e_awakeFlag) == H.e_awakeFlag
    };
    H.prototype.SetFixedRotation = function(a) {
        this.m_flags =
            a ? this.m_flags | H.e_fixedRotationFlag : this.m_flags & ~H.e_fixedRotationFlag;
        this.ResetMassData()
    };
    H.prototype.IsFixedRotation = function() {
        return (this.m_flags & H.e_fixedRotationFlag) == H.e_fixedRotationFlag
    };
    H.prototype.SetActive = function(a) {
        if (a != this.IsActive()) {
            var b;
            if (a)
                for (this.m_flags |= H.e_activeFlag, a = this.m_world.m_contactManager.m_broadPhase, b = this.m_fixtureList; b; b = b.m_next) b.CreateProxy(a, this.m_xf);
            else {
                this.m_flags &= ~H.e_activeFlag;
                a = this.m_world.m_contactManager.m_broadPhase;
                for (b = this.m_fixtureList; b; b =
                    b.m_next) b.DestroyProxy(a);
                for (a = this.m_contactList; a;) b = a, a = a.next, this.m_world.m_contactManager.Destroy(b.contact);
                this.m_contactList = null
            }
        }
    };
    H.prototype.IsActive = function() {
        return (this.m_flags & H.e_activeFlag) == H.e_activeFlag
    };
    H.prototype.IsSleepingAllowed = function() {
        return (this.m_flags & H.e_allowSleepFlag) == H.e_allowSleepFlag
    };
    H.prototype.GetFixtureList = function() {
        return this.m_fixtureList
    };
    H.prototype.GetJointList = function() {
        return this.m_jointList
    };
    H.prototype.GetControllerList = function() {
        return this.m_controllerList
    };
    H.prototype.GetContactList = function() {
        return this.m_contactList
    };
    H.prototype.GetNext = function() {
        return this.m_next
    };
    H.prototype.GetUserData = function() {
        return this.m_userData
    };
    H.prototype.SetUserData = function(a) {
        this.m_userData = a
    };
    H.prototype.GetWorld = function() {
        return this.m_world
    };
    H.prototype.b2Body = function(a, b) {
        this.m_flags = 0;
        a.bullet && (this.m_flags |= H.e_bulletFlag);
        a.fixedRotation && (this.m_flags |= H.e_fixedRotationFlag);
        a.allowSleep && (this.m_flags |= H.e_allowSleepFlag);
        a.awake && (this.m_flags |= H.e_awakeFlag);
        a.active && (this.m_flags |= H.e_activeFlag);
        this.m_world = b;
        this.m_xf.position.SetV(a.position);
        this.m_xf.R.Set(a.angle);
        this.m_sweep.localCenter.SetZero();
        this.m_sweep.t0 = 1;
        this.m_sweep.a0 = this.m_sweep.a = a.angle;
        var c = this.m_xf.R,
            d = this.m_sweep.localCenter;
        this.m_sweep.c.x = c.col1.x * d.x + c.col2.x * d.y;
        this.m_sweep.c.y = c.col1.y * d.x + c.col2.y * d.y;
        this.m_sweep.c.x += this.m_xf.position.x;
        this.m_sweep.c.y += this.m_xf.position.y;
        this.m_sweep.c0.SetV(this.m_sweep.c);
        this.m_contactList = this.m_controllerList = this.m_jointList =
            null;
        this.m_controllerCount = 0;
        this.m_next = this.m_prev = null;
        this.m_linearVelocity.SetV(a.linearVelocity);
        this.m_angularVelocity = a.angularVelocity;
        this.m_linearDamping = a.linearDamping;
        this.m_angularDamping = a.angularDamping;
        this.m_force.Set(0, 0);
        this.m_sleepTime = this.m_torque = 0;
        this.m_type = a.type;
        this.m_invMass = this.m_type == H.b2_dynamicBody ? this.m_mass = 1 : this.m_mass = 0;
        this.m_invI = this.m_I = 0;
        this.m_inertiaScale = a.inertiaScale;
        this.m_userData = a.userData;
        this.m_fixtureList = null;
        this.m_fixtureCount = 0
    };
    H.prototype.SynchronizeFixtures =
        function() {
            var a = H.s_xf1;
            a.R.Set(this.m_sweep.a0);
            var b = a.R,
                c = this.m_sweep.localCenter;
            a.position.x = this.m_sweep.c0.x - (b.col1.x * c.x + b.col2.x * c.y);
            a.position.y = this.m_sweep.c0.y - (b.col1.y * c.x + b.col2.y * c.y);
            c = this.m_world.m_contactManager.m_broadPhase;
            for (b = this.m_fixtureList; b; b = b.m_next) b.Synchronize(c, a, this.m_xf)
        };
    H.prototype.SynchronizeTransform = function() {
        this.m_xf.R.Set(this.m_sweep.a);
        var a = this.m_xf.R,
            b = this.m_sweep.localCenter;
        this.m_xf.position.x = this.m_sweep.c.x - (a.col1.x * b.x + a.col2.x * b.y);
        this.m_xf.position.y = this.m_sweep.c.y - (a.col1.y * b.x + a.col2.y * b.y)
    };
    H.prototype.ShouldCollide = function(a) {
        if (this.m_type != H.b2_dynamicBody && a.m_type != H.b2_dynamicBody) return !1;
        for (var b = this.m_jointList; b; b = b.next)
            if (b.other == a && 0 == b.joint.m_collideConnected) return !1;
        return !0
    };
    H.prototype.Advance = function(a) {
        void 0 === a && (a = 0);
        this.m_sweep.Advance(a);
        this.m_sweep.c.SetV(this.m_sweep.c0);
        this.m_sweep.a = this.m_sweep.a0;
        this.SynchronizeTransform()
    };
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.b2Body.s_xf1 =
            new b;
        Box2D.Dynamics.b2Body.e_islandFlag = 1;
        Box2D.Dynamics.b2Body.e_awakeFlag = 2;
        Box2D.Dynamics.b2Body.e_allowSleepFlag = 4;
        Box2D.Dynamics.b2Body.e_bulletFlag = 8;
        Box2D.Dynamics.b2Body.e_fixedRotationFlag = 16;
        Box2D.Dynamics.b2Body.e_activeFlag = 32;
        Box2D.Dynamics.b2Body.b2_staticBody = 0;
        Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
        Box2D.Dynamics.b2Body.b2_dynamicBody = 2
    });
    E.b2BodyDef = function() {
        this.position = new d;
        this.linearVelocity = new d
    };
    E.prototype.b2BodyDef = function() {
        this.userData = null;
        this.position.Set(0,
            0);
        this.angle = 0;
        this.linearVelocity.Set(0, 0);
        this.angularDamping = this.linearDamping = this.angularVelocity = 0;
        this.awake = this.allowSleep = !0;
        this.bullet = this.fixedRotation = !1;
        this.type = H.b2_staticBody;
        this.active = !0;
        this.inertiaScale = 1
    };
    M.b2ContactFilter = function() {};
    M.prototype.ShouldCollide = function(a, b) {
        var c = a.GetFilterData(),
            d = b.GetFilterData();
        return c.groupIndex == d.groupIndex && 0 != c.groupIndex ? 0 < c.groupIndex : 0 != (c.maskBits & d.categoryBits) && 0 != (c.categoryBits & d.maskBits)
    };
    M.prototype.RayCollide =
        function(a, b) {
            return a ? this.ShouldCollide(a instanceof bc ? a : null, b) : !0
        };
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new M
    });
    Xb.b2ContactImpulse = function() {
        this.normalImpulses = new Vector_a2j_Number(f.b2_maxManifoldPoints);
        this.tangentImpulses = new Vector_a2j_Number(f.b2_maxManifoldPoints)
    };
    Zb.b2ContactListener = function() {};
    Zb.prototype.BeginContact = function() {};
    Zb.prototype.EndContact = function() {};
    Zb.prototype.PreSolve = function() {};
    Zb.prototype.PostSolve = function() {};
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.b2ContactListener.b2_defaultListener = new Zb
    });
    aa.b2ContactManager = function() {};
    aa.prototype.b2ContactManager = function() {
        this.m_world = null;
        this.m_contactCount = 0;
        this.m_contactFilter = M.b2_defaultFilter;
        this.m_contactListener = Zb.b2_defaultListener;
        this.m_contactFactory = new hc(this.m_allocator);
        this.m_broadPhase = new l
    };
    aa.prototype.AddPair = function(a, b) {
        var c = a instanceof bc ? a : null,
            d = b instanceof bc ? b : null,
            e = c.GetBody(),
            f = d.GetBody();
        if (e != f) {
            for (var g = f.GetContactList(); g;) {
                if (g.other ==
                    e) {
                    var h = g.contact.GetFixtureA(),
                        l = g.contact.GetFixtureB();
                    if (h == c && l == d || h == d && l == c) return
                }
                g = g.next
            }
            0 != f.ShouldCollide(e) && 0 != this.m_contactFilter.ShouldCollide(c, d) && (g = this.m_contactFactory.Create(c, d), c = g.GetFixtureA(), d = g.GetFixtureB(), e = c.m_body, f = d.m_body, g.m_prev = null, g.m_next = this.m_world.m_contactList, null != this.m_world.m_contactList && (this.m_world.m_contactList.m_prev = g), this.m_world.m_contactList = g, g.m_nodeA.contact = g, g.m_nodeA.other = f, g.m_nodeA.prev = null, g.m_nodeA.next = e.m_contactList,
                null != e.m_contactList && (e.m_contactList.prev = g.m_nodeA), e.m_contactList = g.m_nodeA, g.m_nodeB.contact = g, g.m_nodeB.other = e, g.m_nodeB.prev = null, g.m_nodeB.next = f.m_contactList, null != f.m_contactList && (f.m_contactList.prev = g.m_nodeB), f.m_contactList = g.m_nodeB, ++this.m_world.m_contactCount)
        }
    };
    aa.prototype.FindNewContacts = function() {
        this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair))
    };
    aa.prototype.Destroy = function(a) {
        var b = a.GetFixtureA(),
            c = a.GetFixtureB(),
            b = b.GetBody(),
            c = c.GetBody();
        a.IsTouching() && this.m_contactListener.EndContact(a);
        a.m_prev && (a.m_prev.m_next = a.m_next);
        a.m_next && (a.m_next.m_prev = a.m_prev);
        a == this.m_world.m_contactList && (this.m_world.m_contactList = a.m_next);
        a.m_nodeA.prev && (a.m_nodeA.prev.next = a.m_nodeA.next);
        a.m_nodeA.next && (a.m_nodeA.next.prev = a.m_nodeA.prev);
        a.m_nodeA == b.m_contactList && (b.m_contactList = a.m_nodeA.next);
        a.m_nodeB.prev && (a.m_nodeB.prev.next = a.m_nodeB.next);
        a.m_nodeB.next && (a.m_nodeB.next.prev = a.m_nodeB.prev);
        a.m_nodeB == c.m_contactList && (c.m_contactList =
            a.m_nodeB.next);
        this.m_contactFactory.Destroy(a);
        --this.m_contactCount
    };
    aa.prototype.Collide = function() {
        for (var a = this.m_world.m_contactList; a;) {
            var b = a.GetFixtureA(),
                c = a.GetFixtureB(),
                d = b.GetBody(),
                e = c.GetBody();
            if (0 == d.IsAwake() && 0 == e.IsAwake()) a = a.GetNext();
            else {
                if (a.m_flags & gc.e_filterFlag) {
                    if (0 == e.ShouldCollide(d)) {
                        b = a;
                        a = b.GetNext();
                        this.Destroy(b);
                        continue
                    }
                    if (0 == this.m_contactFilter.ShouldCollide(b, c)) {
                        b = a;
                        a = b.GetNext();
                        this.Destroy(b);
                        continue
                    }
                    a.m_flags &= ~gc.e_filterFlag
                }
                0 == this.m_broadPhase.TestOverlap(b.m_proxy,
                    c.m_proxy) ? (b = a, a = b.GetNext(), this.Destroy(b)) : (a.Update(this.m_contactListener), a = a.GetNext())
            }
        }
    };
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.b2ContactManager.s_evalCP = new h
    });
    Yb.b2DebugDraw = function() {};
    Yb.prototype.b2DebugDraw = function() {};
    Yb.prototype.SetFlags = function() {};
    Yb.prototype.GetFlags = function() {};
    Yb.prototype.AppendFlags = function() {};
    Yb.prototype.ClearFlags = function() {};
    Yb.prototype.SetSprite = function() {};
    Yb.prototype.GetSprite = function() {};
    Yb.prototype.SetDrawScale = function() {};
    Yb.prototype.GetDrawScale = function() {};
    Yb.prototype.SetLineThickness = function() {};
    Yb.prototype.GetLineThickness = function() {};
    Yb.prototype.SetAlpha = function() {};
    Yb.prototype.GetAlpha = function() {};
    Yb.prototype.SetFillAlpha = function() {};
    Yb.prototype.GetFillAlpha = function() {};
    Yb.prototype.SetXFormScale = function() {};
    Yb.prototype.GetXFormScale = function() {};
    Yb.prototype.DrawPolygon = function() {};
    Yb.prototype.DrawSolidPolygon = function() {};
    Yb.prototype.DrawCircle = function() {};
    Yb.prototype.DrawSolidCircle = function() {};
    Yb.prototype.DrawSegment = function() {};
    Yb.prototype.DrawTransform = function() {};
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.b2DebugDraw.e_shapeBit = 1;
        Box2D.Dynamics.b2DebugDraw.e_jointBit = 2;
        Box2D.Dynamics.b2DebugDraw.e_aabbBit = 4;
        Box2D.Dynamics.b2DebugDraw.e_pairBit = 8;
        Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 16;
        Box2D.Dynamics.b2DebugDraw.e_controllerBit = 32
    });
    $b.b2DestructionListener = function() {};
    $b.prototype.SayGoodbyeJoint = function() {};
    $b.prototype.SayGoodbyeFixture = function() {};
    ac.b2FilterData =
        function() {
            this.categoryBits = 1;
            this.maskBits = 65535;
            this.groupIndex = 0
        };
    ac.prototype.Copy = function() {
        var a = new ac;
        a.categoryBits = this.categoryBits;
        a.maskBits = this.maskBits;
        a.groupIndex = this.groupIndex;
        return a
    };
    bc.b2Fixture = function() {
        this.m_filter = new ac
    };
    bc.prototype.GetType = function() {
        return this.m_shape.GetType()
    };
    bc.prototype.GetShape = function() {
        return this.m_shape
    };
    bc.prototype.SetSensor = function(a) {
        if (this.m_isSensor != a && (this.m_isSensor = a, null != this.m_body))
            for (a = this.m_body.GetContactList(); a;) {
                var b =
                    a.contact,
                    c = b.GetFixtureA(),
                    d = b.GetFixtureB();
                c != this && d != this || b.SetSensor(c.IsSensor() || d.IsSensor());
                a = a.next
            }
    };
    bc.prototype.IsSensor = function() {
        return this.m_isSensor
    };
    bc.prototype.SetFilterData = function(a) {
        this.m_filter = a.Copy();
        if (!this.m_body)
            for (a = this.m_body.GetContactList(); a;) {
                var b = a.contact,
                    c = b.GetFixtureA(),
                    d = b.GetFixtureB();
                c != this && d != this || b.FlagForFiltering();
                a = a.next
            }
    };
    bc.prototype.GetFilterData = function() {
        return this.m_filter.Copy()
    };
    bc.prototype.GetBody = function() {
        return this.m_body
    };
    bc.prototype.GetNext = function() {
        return this.m_next
    };
    bc.prototype.GetUserData = function() {
        return this.m_userData
    };
    bc.prototype.SetUserData = function(a) {
        this.m_userData = a
    };
    bc.prototype.TestPoint = function(a) {
        return this.m_shape.TestPoint(this.m_body.GetTransform(), a)
    };
    bc.prototype.RayCast = function(a, b) {
        return this.m_shape.RayCast(a, b, this.m_body.GetTransform())
    };
    bc.prototype.GetMassData = function(a) {
        void 0 === a && (a = null);
        null == a && (a = new A);
        this.m_shape.ComputeMass(a, this.m_density);
        return a
    };
    bc.prototype.SetDensity =
        function(a) {
            void 0 === a && (a = 0);
            this.m_density = a
        };
    bc.prototype.GetDensity = function() {
        return this.m_density
    };
    bc.prototype.GetFriction = function() {
        return this.m_friction
    };
    bc.prototype.SetFriction = function(a) {
        void 0 === a && (a = 0);
        this.m_friction = a
    };
    bc.prototype.GetRestitution = function() {
        return this.m_restitution
    };
    bc.prototype.SetRestitution = function(a) {
        void 0 === a && (a = 0);
        this.m_restitution = a
    };
    bc.prototype.GetAABB = function() {
        return this.m_aabb
    };
    bc.prototype.b2Fixture = function() {
        this.m_aabb = new g;
        this.m_shape =
            this.m_next = this.m_body = this.m_userData = null;
        this.m_restitution = this.m_friction = this.m_density = 0
    };
    bc.prototype.Create = function(a, b, c) {
        this.m_userData = c.userData;
        this.m_friction = c.friction;
        this.m_restitution = c.restitution;
        this.m_body = a;
        this.m_next = null;
        this.m_filter = c.filter.Copy();
        this.m_isSensor = c.isSensor;
        this.m_shape = c.shape.Copy();
        this.m_density = c.density
    };
    bc.prototype.Destroy = function() {
        this.m_shape = null
    };
    bc.prototype.CreateProxy = function(a, b) {
        this.m_shape.ComputeAABB(this.m_aabb, b);
        this.m_proxy =
            a.CreateProxy(this.m_aabb, this)
    };
    bc.prototype.DestroyProxy = function(a) {
        null != this.m_proxy && (a.DestroyProxy(this.m_proxy), this.m_proxy = null)
    };
    bc.prototype.Synchronize = function(b, c, d) {
        if (this.m_proxy) {
            var e = new g,
                f = new g;
            this.m_shape.ComputeAABB(e, c);
            this.m_shape.ComputeAABB(f, d);
            this.m_aabb.Combine(e, f);
            c = a.SubtractVV(d.position, c.position);
            b.MoveProxy(this.m_proxy, this.m_aabb, c)
        }
    };
    ec.b2FixtureDef = function() {
        this.filter = new ac
    };
    ec.prototype.b2FixtureDef = function() {
        this.userData = this.shape = null;
        this.friction =
            .2;
        this.density = this.restitution = 0;
        this.filter.categoryBits = 1;
        this.filter.maskBits = 65535;
        this.filter.groupIndex = 0;
        this.isSensor = !1
    };
    jc.b2Island = function() {};
    jc.prototype.b2Island = function() {
        this.m_bodies = new Vector;
        this.m_contacts = new Vector;
        this.m_joints = new Vector
    };
    jc.prototype.Initialize = function(a, b, c, d, e, f) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        this.m_bodyCapacity = a;
        this.m_contactCapacity = b;
        this.m_jointCapacity = c;
        this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0;
        this.m_allocator =
            d;
        this.m_listener = e;
        this.m_contactSolver = f;
        for (d = this.m_bodies.length; d < a; d++) this.m_bodies[d] = null;
        for (d = this.m_contacts.length; d < b; d++) this.m_contacts[d] = null;
        for (d = this.m_joints.length; d < c; d++) this.m_joints[d] = null
    };
    jc.prototype.Clear = function() {
        this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0
    };
    jc.prototype.Solve = function(b, c, d) {
        var e, g, h;
        for (e = 0; e < this.m_bodyCount; ++e) g = this.m_bodies[e], g.GetType() == H.b2_dynamicBody && (g.m_linearVelocity.x += b.dt * (c.x + g.m_invMass * g.m_force.x), g.m_linearVelocity.y +=
            b.dt * (c.y + g.m_invMass * g.m_force.y), g.m_angularVelocity += b.dt * g.m_invI * g.m_torque, g.m_linearVelocity.Multiply(a.Clamp(1 - b.dt * g.m_linearDamping, 0, 1)), g.m_angularVelocity *= a.Clamp(1 - b.dt * g.m_angularDamping, 0, 1));
        this.m_contactSolver.Initialize(b, this.m_contacts, this.m_contactCount, this.m_allocator);
        c = this.m_contactSolver;
        c.InitVelocityConstraints(b);
        for (e = 0; e < this.m_jointCount; ++e) h = this.m_joints[e], h.InitVelocityConstraints(b);
        for (e = 0; e < b.velocityIterations; ++e) {
            for (g = 0; g < this.m_jointCount; ++g) h = this.m_joints[g],
                h.SolveVelocityConstraints(b);
            c.SolveVelocityConstraints()
        }
        for (e = 0; e < this.m_jointCount; ++e) h = this.m_joints[e], h.FinalizeVelocityConstraints();
        c.FinalizeVelocityConstraints();
        for (e = 0; e < this.m_bodyCount; ++e)
            if (g = this.m_bodies[e], g.GetType() != H.b2_staticBody) {
                var l = b.dt * g.m_linearVelocity.x,
                    m = b.dt * g.m_linearVelocity.y;
                l * l + m * m > f.b2_maxTranslationSquared && (g.m_linearVelocity.Normalize(), g.m_linearVelocity.x = g.m_linearVelocity.x * f.b2_maxTranslation * b.inv_dt, g.m_linearVelocity.y = g.m_linearVelocity.y * f.b2_maxTranslation *
                    b.inv_dt);
                l = b.dt * g.m_angularVelocity;
                l * l > f.b2_maxRotationSquared && (g.m_angularVelocity = 0 > g.m_angularVelocity ? -f.b2_maxRotation * b.inv_dt : f.b2_maxRotation * b.inv_dt);
                g.m_sweep.c0.SetV(g.m_sweep.c);
                g.m_sweep.a0 = g.m_sweep.a;
                g.m_sweep.c.x += b.dt * g.m_linearVelocity.x;
                g.m_sweep.c.y += b.dt * g.m_linearVelocity.y;
                g.m_sweep.a += b.dt * g.m_angularVelocity;
                g.SynchronizeTransform()
            }
        for (e = 0; e < b.positionIterations; ++e) {
            l = c.SolvePositionConstraints(f.b2_contactBaumgarte);
            m = !0;
            for (g = 0; g < this.m_jointCount; ++g) h = this.m_joints[g],
                h = h.SolvePositionConstraints(f.b2_contactBaumgarte), m = m && h;
            if (l && m) break
        }
        this.Report(c.m_constraints);
        if (d) {
            d = Number.MAX_VALUE;
            c = f.b2_linearSleepTolerance * f.b2_linearSleepTolerance;
            l = f.b2_angularSleepTolerance * f.b2_angularSleepTolerance;
            for (e = 0; e < this.m_bodyCount; ++e) g = this.m_bodies[e], g.GetType() != H.b2_staticBody && (0 == (g.m_flags & H.e_allowSleepFlag) && (d = g.m_sleepTime = 0), 0 == (g.m_flags & H.e_allowSleepFlag) || g.m_angularVelocity * g.m_angularVelocity > l || a.Dot(g.m_linearVelocity, g.m_linearVelocity) > c ? d = g.m_sleepTime =
                0 : (g.m_sleepTime += b.dt, d = a.Min(d, g.m_sleepTime)));
            if (d >= f.b2_timeToSleep)
                for (e = 0; e < this.m_bodyCount; ++e) g = this.m_bodies[e], g.SetAwake(!1)
        }
    };
    jc.prototype.SolveTOI = function(a) {
        var b, c;
        this.m_contactSolver.Initialize(a, this.m_contacts, this.m_contactCount, this.m_allocator);
        var d = this.m_contactSolver;
        for (b = 0; b < this.m_jointCount; ++b) this.m_joints[b].InitVelocityConstraints(a);
        for (b = 0; b < a.velocityIterations; ++b)
            for (d.SolveVelocityConstraints(), c = 0; c < this.m_jointCount; ++c) this.m_joints[c].SolveVelocityConstraints(a);
        for (b = 0; b < this.m_bodyCount; ++b)
            if (c = this.m_bodies[b], c.GetType() != H.b2_staticBody) {
                var e = a.dt * c.m_linearVelocity.x,
                    g = a.dt * c.m_linearVelocity.y;
                e * e + g * g > f.b2_maxTranslationSquared && (c.m_linearVelocity.Normalize(), c.m_linearVelocity.x = c.m_linearVelocity.x * f.b2_maxTranslation * a.inv_dt, c.m_linearVelocity.y = c.m_linearVelocity.y * f.b2_maxTranslation * a.inv_dt);
                e = a.dt * c.m_angularVelocity;
                e * e > f.b2_maxRotationSquared && (c.m_angularVelocity = 0 > c.m_angularVelocity ? -f.b2_maxRotation * a.inv_dt : f.b2_maxRotation * a.inv_dt);
                c.m_sweep.c0.SetV(c.m_sweep.c);
                c.m_sweep.a0 = c.m_sweep.a;
                c.m_sweep.c.x += a.dt * c.m_linearVelocity.x;
                c.m_sweep.c.y += a.dt * c.m_linearVelocity.y;
                c.m_sweep.a += a.dt * c.m_angularVelocity;
                c.SynchronizeTransform()
            }
        for (b = 0; b < a.positionIterations; ++b) {
            e = d.SolvePositionConstraints(.75);
            g = !0;
            for (c = 0; c < this.m_jointCount; ++c) var h = this.m_joints[c].SolvePositionConstraints(f.b2_contactBaumgarte),
                g = g && h;
            if (e && g) break
        }
        this.Report(d.m_constraints)
    };
    jc.prototype.Report = function(a) {
        if (null != this.m_listener)
            for (var b = 0; b <
                this.m_contactCount; ++b) {
                for (var c = this.m_contacts[b], d = a[b], e = 0; e < d.pointCount; ++e) jc.s_impulse.normalImpulses[e] = d.points[e].normalImpulse, jc.s_impulse.tangentImpulses[e] = d.points[e].tangentImpulse;
                this.m_listener.PostSolve(c, jc.s_impulse)
            }
    };
    jc.prototype.AddBody = function(a) {
        a.m_islandIndex = this.m_bodyCount;
        this.m_bodies[this.m_bodyCount++] = a
    };
    jc.prototype.AddContact = function(a) {
        this.m_contacts[this.m_contactCount++] = a
    };
    jc.prototype.AddJoint = function(a) {
        this.m_joints[this.m_jointCount++] = a
    };
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.b2Island.s_impulse =
            new Xb
    });
    cc.b2TimeStep = function() {};
    cc.prototype.Set = function(a) {
        this.dt = a.dt;
        this.inv_dt = a.inv_dt;
        this.positionIterations = a.positionIterations;
        this.velocityIterations = a.velocityIterations;
        this.warmStarting = a.warmStarting
    };
    dc.b2World = function() {
        this.s_stack = new Vector;
        this.m_contactManager = new aa;
        this.m_contactSolver = new fc;
        this.m_island = new jc
    };
    dc.prototype.b2World = function(a, b) {
        this.m_controllerList = this.m_jointList = this.m_contactList = this.m_bodyList = this.m_debugDraw = this.m_destructionListener =
            null;
        this.m_controllerCount = this.m_jointCount = this.m_contactCount = this.m_bodyCount = 0;
        dc.m_warmStarting = !0;
        dc.m_continuousPhysics = !0;
        this.m_allowSleep = b;
        this.m_gravity = a;
        this.m_inv_dt0 = 0;
        this.m_contactManager.m_world = this;
        this.m_groundBody = this.CreateBody(new E)
    };
    dc.prototype.SetDestructionListener = function(a) {
        this.m_destructionListener = a
    };
    dc.prototype.SetContactFilter = function(a) {
        this.m_contactManager.m_contactFilter = a
    };
    dc.prototype.SetContactListener = function(a) {
        this.m_contactManager.m_contactListener =
            a
    };
    dc.prototype.SetDebugDraw = function(a) {
        this.m_debugDraw = a
    };
    dc.prototype.SetBroadPhase = function(a) {
        var b = this.m_contactManager.m_broadPhase;
        this.m_contactManager.m_broadPhase = a;
        for (var c = this.m_bodyList; c; c = c.m_next)
            for (var d = c.m_fixtureList; d; d = d.m_next) d.m_proxy = a.CreateProxy(b.GetFatAABB(d.m_proxy), d)
    };
    dc.prototype.Validate = function() {
        this.m_contactManager.m_broadPhase.Validate()
    };
    dc.prototype.GetProxyCount = function() {
        return this.m_contactManager.m_broadPhase.GetProxyCount()
    };
    dc.prototype.CreateBody =
        function(a) {
            if (1 == this.IsLocked()) return null;
            a = new H(a, this);
            a.m_prev = null;
            if (a.m_next = this.m_bodyList) this.m_bodyList.m_prev = a;
            this.m_bodyList = a;
            ++this.m_bodyCount;
            return a
        };
    dc.prototype.DestroyBody = function(a) {
        if (1 != this.IsLocked()) {
            for (var b = a.m_jointList; b;) {
                var c = b,
                    b = b.next;
                this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(c.joint);
                this.DestroyJoint(c.joint)
            }
            for (b = a.m_controllerList; b;) c = b, b = b.nextController, c.controller.RemoveBody(a);
            for (b = a.m_contactList; b;) c = b, b = b.next,
                this.m_contactManager.Destroy(c.contact);
            a.m_contactList = null;
            for (b = a.m_fixtureList; b;) c = b, b = b.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(c), c.DestroyProxy(this.m_contactManager.m_broadPhase), c.Destroy();
            a.m_fixtureList = null;
            a.m_fixtureCount = 0;
            a.m_prev && (a.m_prev.m_next = a.m_next);
            a.m_next && (a.m_next.m_prev = a.m_prev);
            a == this.m_bodyList && (this.m_bodyList = a.m_next);
            --this.m_bodyCount
        }
    };
    dc.prototype.CreateJoint = function(a) {
        var b = kc.Create(a, null);
        b.m_prev = null;
        if (b.m_next =
            this.m_jointList) this.m_jointList.m_prev = b;
        this.m_jointList = b;
        ++this.m_jointCount;
        b.m_edgeA.joint = b;
        b.m_edgeA.other = b.m_bodyB;
        b.m_edgeA.prev = null;
        if (b.m_edgeA.next = b.m_bodyA.m_jointList) b.m_bodyA.m_jointList.prev = b.m_edgeA;
        b.m_bodyA.m_jointList = b.m_edgeA;
        b.m_edgeB.joint = b;
        b.m_edgeB.other = b.m_bodyA;
        b.m_edgeB.prev = null;
        if (b.m_edgeB.next = b.m_bodyB.m_jointList) b.m_bodyB.m_jointList.prev = b.m_edgeB;
        b.m_bodyB.m_jointList = b.m_edgeB;
        var c = a.bodyA,
            d = a.bodyB;
        if (0 == a.collideConnected)
            for (a = d.GetContactList(); a;) a.other ==
                c && a.contact.FlagForFiltering(), a = a.next;
        return b
    };
    dc.prototype.DestroyJoint = function(a) {
        var b = a.m_collideConnected;
        a.m_prev && (a.m_prev.m_next = a.m_next);
        a.m_next && (a.m_next.m_prev = a.m_prev);
        a == this.m_jointList && (this.m_jointList = a.m_next);
        var c = a.m_bodyA,
            d = a.m_bodyB;
        c.SetAwake(!0);
        d.SetAwake(!0);
        a.m_edgeA.prev && (a.m_edgeA.prev.next = a.m_edgeA.next);
        a.m_edgeA.next && (a.m_edgeA.next.prev = a.m_edgeA.prev);
        a.m_edgeA == c.m_jointList && (c.m_jointList = a.m_edgeA.next);
        a.m_edgeA.prev = null;
        a.m_edgeA.next = null;
        a.m_edgeB.prev &&
            (a.m_edgeB.prev.next = a.m_edgeB.next);
        a.m_edgeB.next && (a.m_edgeB.next.prev = a.m_edgeB.prev);
        a.m_edgeB == d.m_jointList && (d.m_jointList = a.m_edgeB.next);
        a.m_edgeB.prev = null;
        a.m_edgeB.next = null;
        kc.Destroy(a, null);
        --this.m_jointCount;
        if (0 == b)
            for (a = d.GetContactList(); a;) a.other == c && a.contact.FlagForFiltering(), a = a.next
    };
    dc.prototype.AddController = function(a) {
        a.m_next = this.m_controllerList;
        a.m_prev = null;
        this.m_controllerList = a;
        a.m_world = this;
        this.m_controllerCount++;
        return a
    };
    dc.prototype.RemoveController =
        function(a) {
            a.m_prev && (a.m_prev.m_next = a.m_next);
            a.m_next && (a.m_next.m_prev = a.m_prev);
            this.m_controllerList == a && (this.m_controllerList = a.m_next);
            this.m_controllerCount--
        };
    dc.prototype.CreateController = function(a) {
        if (a.m_world != this) throw Error("Controller can only be a member of one world");
        a.m_next = this.m_controllerList;
        a.m_prev = null;
        this.m_controllerList && (this.m_controllerList.m_prev = a);
        this.m_controllerList = a;
        ++this.m_controllerCount;
        a.m_world = this;
        return a
    };
    dc.prototype.DestroyController = function(a) {
        a.Clear();
        a.m_next && (a.m_next.m_prev = a.m_prev);
        a.m_prev && (a.m_prev.m_next = a.m_next);
        a == this.m_controllerList && (this.m_controllerList = a.m_next);
        --this.m_controllerCount
    };
    dc.prototype.SetWarmStarting = function(a) {
        dc.m_warmStarting = a
    };
    dc.prototype.SetContinuousPhysics = function(a) {
        dc.m_continuousPhysics = a
    };
    dc.prototype.GetBodyCount = function() {
        return this.m_bodyCount
    };
    dc.prototype.GetJointCount = function() {
        return this.m_jointCount
    };
    dc.prototype.GetContactCount = function() {
        return this.m_contactCount
    };
    dc.prototype.SetGravity =
        function(a) {
            this.m_gravity = a
        };
    dc.prototype.GetGravity = function() {
        return this.m_gravity
    };
    dc.prototype.GetGroundBody = function() {
        return this.m_groundBody
    };
    dc.prototype.Step = function(a, b, c) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        void 0 === c && (c = 0);
        this.m_flags & dc.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~dc.e_newFixture);
        this.m_flags |= dc.e_locked;
        var d = dc.s_timestep2;
        d.dt = a;
        d.velocityIterations = b;
        d.positionIterations = c;
        d.inv_dt = 0 < a ? 1 / a : 0;
        d.dtRatio = this.m_inv_dt0 * a;
        d.warmStarting =
            dc.m_warmStarting;
        this.m_contactManager.Collide();
        0 < d.dt && this.Solve(d);
        dc.m_continuousPhysics && 0 < d.dt && this.SolveTOI(d);
        0 < d.dt && (this.m_inv_dt0 = d.inv_dt);
        this.m_flags &= ~dc.e_locked
    };
    dc.prototype.ClearForces = function() {
        for (var a = this.m_bodyList; a; a = a.m_next) a.m_force.SetZero(), a.m_torque = 0
    };
    dc.prototype.DrawDebugData = function() {
        if (null != this.m_debugDraw) {
            this.m_debugDraw.m_sprite.graphics.clear();
            var a = this.m_debugDraw.GetFlags(),
                b, c, f;
            new d;
            new d;
            new d;
            var h;
            new g;
            new g;
            new d;
            new d;
            new d;
            new d;
            var l =
                new e(0, 0, 0);
            if (a & Yb.e_shapeBit)
                for (b = this.m_bodyList; b; b = b.m_next)
                    for (h = b.m_xf, c = b.GetFixtureList(); c; c = c.m_next) f = c.GetShape(), 0 == b.IsActive() ? l.Set(.5, .5, .3) : b.GetType() == H.b2_staticBody ? l.Set(.5, .9, .5) : b.GetType() == H.b2_kinematicBody ? l.Set(.5, .5, .9) : 0 == b.IsAwake() ? l.Set(.6, .6, .6) : l.Set(.9, .7, .7), this.DrawShape(f, h, l);
            if (a & Yb.e_jointBit)
                for (b = this.m_jointList; b; b = b.m_next) this.DrawJoint(b);
            if (a & Yb.e_controllerBit)
                for (b = this.m_controllerList; b; b = b.m_next) b.Draw(this.m_debugDraw);
            if (a & Yb.e_pairBit)
                for (l.Set(.3,
                        .9, .9), b = this.m_contactManager.m_contactList; b; b = b.GetNext()) f = b.GetFixtureA(), c = b.GetFixtureB(), f = f.GetAABB().GetCenter(), c = c.GetAABB().GetCenter(), this.m_debugDraw.DrawSegment(f, c, l);
            if (a & Yb.e_aabbBit)
                for (f = this.m_contactManager.m_broadPhase, h = [new d, new d, new d, new d], b = this.m_bodyList; b; b = b.GetNext())
                    if (0 != b.IsActive())
                        for (c = b.GetFixtureList(); c; c = c.GetNext()) {
                            var m = f.GetFatAABB(c.m_proxy);
                            h[0].Set(m.lowerBound.x, m.lowerBound.y);
                            h[1].Set(m.upperBound.x, m.lowerBound.y);
                            h[2].Set(m.upperBound.x,
                                m.upperBound.y);
                            h[3].Set(m.lowerBound.x, m.upperBound.y);
                            this.m_debugDraw.DrawPolygon(h, 4, l)
                        }
                    if (a & Yb.e_centerOfMassBit)
                        for (b = this.m_bodyList; b; b = b.m_next) h = dc.s_xf, h.R = b.m_xf.R, h.position = b.GetWorldCenter(), this.m_debugDraw.DrawTransform(h)
        }
    };
    dc.prototype.QueryAABB = function(a, b) {
        var c = this.m_contactManager.m_broadPhase;
        c.Query(function(b) {
            return a(c.GetUserData(b))
        }, b)
    };
    dc.prototype.QueryShape = function(a, c, d) {
        void 0 === d && (d = null);
        null == d && (d = new b, d.SetIdentity());
        var e = this.m_contactManager.m_broadPhase,
            f = new g;
        c.ComputeAABB(f, d);
        e.Query(function(b) {
            b = e.GetUserData(b) instanceof bc ? e.GetUserData(b) : null;
            return K.TestOverlap(c, d, b.GetShape(), b.GetBody().GetTransform()) ? a(b) : !0
        }, f)
    };
    dc.prototype.QueryPoint = function(a, b) {
        var c = this.m_contactManager.m_broadPhase,
            d = new g;
        d.lowerBound.Set(b.x - f.b2_linearSlop, b.y - f.b2_linearSlop);
        d.upperBound.Set(b.x + f.b2_linearSlop, b.y + f.b2_linearSlop);
        c.Query(function(d) {
            d = c.GetUserData(d) instanceof bc ? c.GetUserData(d) : null;
            return d.TestPoint(b) ? a(d) : !0
        }, d)
    };
    dc.prototype.RayCast =
        function(a, b, c) {
            var e = this.m_contactManager.m_broadPhase,
                f = new q,
                g = new m(b, c);
            e.RayCast(function(g, h) {
                var l = e.GetUserData(h),
                    l = l instanceof bc ? l : null;
                if (l.RayCast(f, g)) {
                    var m = f.fraction,
                        p = new d((1 - m) * b.x + m * c.x, (1 - m) * b.y + m * c.y);
                    return a(l, p, f.normal, m)
                }
                return g.maxFraction
            }, g)
        };
    dc.prototype.RayCastOne = function(a, b) {
        var c;
        this.RayCast(function(a, b, d, e) {
            void 0 === e && (e = 0);
            c = a;
            return e
        }, a, b);
        return c
    };
    dc.prototype.RayCastAll = function(a, b) {
        var c = new Vector;
        this.RayCast(function(a) {
                c[c.length] = a;
                return 1
            },
            a, b);
        return c
    };
    dc.prototype.GetBodyList = function() {
        return this.m_bodyList
    };
    dc.prototype.GetJointList = function() {
        return this.m_jointList
    };
    dc.prototype.GetContactList = function() {
        return this.m_contactList
    };
    dc.prototype.IsLocked = function() {
        return 0 < (this.m_flags & dc.e_locked)
    };
    dc.prototype.Solve = function(a) {
        for (var b, c = this.m_controllerList; c; c = c.m_next) c.Step(a);
        c = this.m_island;
        c.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        for (b = this.m_bodyList; b; b = b.m_next) b.m_flags &= ~H.e_islandFlag;
        for (var d = this.m_contactList; d; d = d.m_next) d.m_flags &= ~gc.e_islandFlag;
        for (d = this.m_jointList; d; d = d.m_next) d.m_islandFlag = !1;
        parseInt(this.m_bodyCount);
        for (var d = this.s_stack, e = this.m_bodyList; e; e = e.m_next)
            if (!(e.m_flags & H.e_islandFlag) && 0 != e.IsAwake() && 0 != e.IsActive() && e.GetType() != H.b2_staticBody) {
                c.Clear();
                var f = 0;
                d[f++] = e;
                for (e.m_flags |= H.e_islandFlag; 0 < f;)
                    if (b = d[--f], c.AddBody(b), 0 == b.IsAwake() && b.SetAwake(!0), b.GetType() != H.b2_staticBody) {
                        for (var g,
                                h = b.m_contactList; h; h = h.next) h.contact.m_flags & gc.e_islandFlag || 1 == h.contact.IsSensor() || 0 == h.contact.IsEnabled() || 0 == h.contact.IsTouching() || (c.AddContact(h.contact), h.contact.m_flags |= gc.e_islandFlag, g = h.other, g.m_flags & H.e_islandFlag || (d[f++] = g, g.m_flags |= H.e_islandFlag));
                        for (b = b.m_jointList; b; b = b.next) 1 != b.joint.m_islandFlag && (g = b.other, 0 != g.IsActive() && (c.AddJoint(b.joint), b.joint.m_islandFlag = !0, g.m_flags & H.e_islandFlag || (d[f++] = g, g.m_flags |= H.e_islandFlag)))
                    }
                c.Solve(a, this.m_gravity, this.m_allowSleep);
                for (f = 0; f < c.m_bodyCount; ++f) b = c.m_bodies[f], b.GetType() == H.b2_staticBody && (b.m_flags &= ~H.e_islandFlag)
            }
        for (f = 0; f < d.length && d[f]; ++f) d[f] = null;
        for (b = this.m_bodyList; b; b = b.m_next) 0 == b.IsAwake() || 0 == b.IsActive() || b.GetType() != H.b2_staticBody && b.SynchronizeFixtures();
        this.m_contactManager.FindNewContacts()
    };
    dc.prototype.SolveTOI = function(a) {
        var b, c, d, e = this.m_island;
        e.Initialize(this.m_bodyCount, f.b2_maxTOIContactsPerIsland, f.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
        var g = dc.s_queue;
        for (b = this.m_bodyList; b; b = b.m_next) b.m_flags &= ~H.e_islandFlag, b.m_sweep.t0 = 0;
        for (d = this.m_contactList; d; d = d.m_next) d.m_flags &= ~(gc.e_toiFlag | gc.e_islandFlag);
        for (d = this.m_jointList; d; d = d.m_next) d.m_islandFlag = !1;
        for (;;) {
            var h = null,
                l = 1;
            for (d = this.m_contactList; d; d = d.m_next)
                if (1 != d.IsSensor() && 0 != d.IsEnabled() && 0 != d.IsContinuous()) {
                    if (d.m_flags & gc.e_toiFlag) b = d.m_toi;
                    else {
                        b = d.m_fixtureA;
                        c = d.m_fixtureB;
                        b = b.m_body;
                        c = c.m_body;
                        if (!(b.GetType() == H.b2_dynamicBody && 0 != b.IsAwake() || c.GetType() ==
                                H.b2_dynamicBody && 0 != c.IsAwake())) continue;
                        var m = b.m_sweep.t0;
                        b.m_sweep.t0 < c.m_sweep.t0 ? (m = c.m_sweep.t0, b.m_sweep.Advance(m)) : c.m_sweep.t0 < b.m_sweep.t0 && (m = b.m_sweep.t0, c.m_sweep.Advance(m));
                        b = d.ComputeTOI(b.m_sweep, c.m_sweep);
                        f.b2Assert(0 <= b && 1 >= b);
                        0 < b && 1 > b && (b = (1 - b) * m + b, 1 < b && (b = 1));
                        d.m_toi = b;
                        d.m_flags |= gc.e_toiFlag
                    }
                    Number.MIN_VALUE < b && b < l && (h = d, l = b)
                }
            if (null == h || 1 - 100 * Number.MIN_VALUE < l) break;
            b = h.m_fixtureA;
            c = h.m_fixtureB;
            b = b.m_body;
            c = c.m_body;
            dc.s_backupA.Set(b.m_sweep);
            dc.s_backupB.Set(c.m_sweep);
            b.Advance(l);
            c.Advance(l);
            h.Update(this.m_contactManager.m_contactListener);
            h.m_flags &= ~gc.e_toiFlag;
            if (1 == h.IsSensor() || 0 == h.IsEnabled()) b.m_sweep.Set(dc.s_backupA), c.m_sweep.Set(dc.s_backupB), b.SynchronizeTransform(), c.SynchronizeTransform();
            else if (0 != h.IsTouching()) {
                b.GetType() != H.b2_dynamicBody && (b = c);
                e.Clear();
                h = d = 0;
                g[d + h++] = b;
                for (b.m_flags |= H.e_islandFlag; 0 < h;)
                    if (b = g[d++], --h, e.AddBody(b), 0 == b.IsAwake() && b.SetAwake(!0), b.GetType() == H.b2_dynamicBody) {
                        for (c = b.m_contactList; c && e.m_contactCount !=
                            e.m_contactCapacity; c = c.next) c.contact.m_flags & gc.e_islandFlag || 1 == c.contact.IsSensor() || 0 == c.contact.IsEnabled() || 0 == c.contact.IsTouching() || (e.AddContact(c.contact), c.contact.m_flags |= gc.e_islandFlag, m = c.other, m.m_flags & H.e_islandFlag || (m.GetType() != H.b2_staticBody && (m.Advance(l), m.SetAwake(!0)), g[d + h] = m, ++h, m.m_flags |= H.e_islandFlag));
                        for (b = b.m_jointList; b; b = b.next) e.m_jointCount != e.m_jointCapacity && 1 != b.joint.m_islandFlag && (m = b.other, 0 != m.IsActive() && (e.AddJoint(b.joint), b.joint.m_islandFlag = !0, m.m_flags & H.e_islandFlag || (m.GetType() != H.b2_staticBody && (m.Advance(l), m.SetAwake(!0)), g[d + h] = m, ++h, m.m_flags |= H.e_islandFlag)))
                    }
                d = dc.s_timestep;
                d.warmStarting = !1;
                d.dt = (1 - l) * a.dt;
                d.inv_dt = 1 / d.dt;
                d.dtRatio = 0;
                d.velocityIterations = a.velocityIterations;
                d.positionIterations = a.positionIterations;
                e.SolveTOI(d);
                for (l = l = 0; l < e.m_bodyCount; ++l)
                    if (b = e.m_bodies[l], b.m_flags &= ~H.e_islandFlag, 0 != b.IsAwake() && b.GetType() == H.b2_dynamicBody)
                        for (b.SynchronizeFixtures(), c = b.m_contactList; c; c = c.next) c.contact.m_flags &=
                            ~gc.e_toiFlag;
                for (l = 0; l < e.m_contactCount; ++l) d = e.m_contacts[l], d.m_flags &= ~(gc.e_toiFlag | gc.e_islandFlag);
                for (l = 0; l < e.m_jointCount; ++l) d = e.m_joints[l], d.m_islandFlag = !1;
                this.m_contactManager.FindNewContacts()
            }
        }
    };
    dc.prototype.DrawJoint = function(a) {
        var b = a.GetBodyA(),
            c = a.GetBodyB(),
            d = b.m_xf.position,
            e = c.m_xf.position,
            f = a.GetAnchorA(),
            g = a.GetAnchorB(),
            h = dc.s_jointColor;
        switch (a.m_type) {
            case kc.e_distanceJoint:
                this.m_debugDraw.DrawSegment(f, g, h);
                break;
            case kc.e_pulleyJoint:
                b = a instanceof lc ? a : null;
                a =
                    b.GetGroundAnchorA();
                b = b.GetGroundAnchorB();
                this.m_debugDraw.DrawSegment(a, f, h);
                this.m_debugDraw.DrawSegment(b, g, h);
                this.m_debugDraw.DrawSegment(a, b, h);
                break;
            case kc.e_mouseJoint:
                this.m_debugDraw.DrawSegment(f, g, h);
                break;
            default:
                b != this.m_groundBody && this.m_debugDraw.DrawSegment(d, f, h), this.m_debugDraw.DrawSegment(f, g, h), c != this.m_groundBody && this.m_debugDraw.DrawSegment(e, g, h)
        }
    };
    dc.prototype.DrawShape = function(b, c, d) {
        switch (b.m_type) {
            case K.e_circleShape:
                var e = b instanceof p ? b : null;
                this.m_debugDraw.DrawSolidCircle(a.MulX(c,
                    e.m_p), e.m_radius, c.R.col1, d);
                break;
            case K.e_polygonShape:
                e = b instanceof B ? b : null;
                b = parseInt(e.GetVertexCount());
                for (var f = e.GetVertices(), g = new Vector(b), e = 0; e < b; ++e) g[e] = a.MulX(c, f[e]);
                this.m_debugDraw.DrawSolidPolygon(g, b, d);
                break;
            case K.e_edgeShape:
                e = b instanceof y ? b : null, this.m_debugDraw.DrawSegment(a.MulX(c, e.GetVertex1()), a.MulX(c, e.GetVertex2()), d)
        }
    };
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.b2World.s_timestep2 = new cc;
        Box2D.Dynamics.b2World.s_xf = new b;
        Box2D.Dynamics.b2World.s_backupA =
            new c;
        Box2D.Dynamics.b2World.s_backupB = new c;
        Box2D.Dynamics.b2World.s_timestep = new cc;
        Box2D.Dynamics.b2World.s_queue = new Vector;
        Box2D.Dynamics.b2World.s_jointColor = new e(.5, .8, .8);
        Box2D.Dynamics.b2World.e_newFixture = 1;
        Box2D.Dynamics.b2World.e_locked = 2
    })
})();
(function() {
    var a = Box2D.Collision.Shapes.b2CircleShape,
        c = Box2D.Collision.Shapes.b2EdgeShape,
        b = Box2D.Collision.Shapes.b2PolygonShape,
        d = Box2D.Collision.Shapes.b2Shape,
        e = Box2D.Dynamics.Contacts.b2CircleContact,
        f = Box2D.Dynamics.Contacts.b2Contact,
        g = Box2D.Dynamics.Contacts.b2ContactConstraint,
        h = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
        l = Box2D.Dynamics.Contacts.b2ContactEdge,
        m = Box2D.Dynamics.Contacts.b2ContactFactory,
        q = Box2D.Dynamics.Contacts.b2ContactRegister,
        p = Box2D.Dynamics.Contacts.b2ContactResult,
        y = Box2D.Dynamics.Contacts.b2ContactSolver,
        A = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
        B = Box2D.Dynamics.Contacts.b2NullContact,
        K = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
        H = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
        E = Box2D.Dynamics.Contacts.b2PolygonContact,
        M = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
        Xb = Box2D.Dynamics.b2Body,
        Zb = Box2D.Dynamics.b2TimeStep,
        aa = Box2D.Common.b2Settings,
        Yb = Box2D.Common.Math.b2Mat22,
        $b = Box2D.Common.Math.b2Math,
        ac = Box2D.Common.Math.b2Vec2,
        bc = Box2D.Collision.b2Collision,
        ec = Box2D.Collision.b2ContactID,
        jc = Box2D.Collision.b2Manifold,
        cc = Box2D.Collision.b2TimeOfImpact,
        dc = Box2D.Collision.b2TOIInput,
        gc = Box2D.Collision.b2WorldManifold;
    Box2D.inherit(e, Box2D.Dynamics.Contacts.b2Contact);
    e.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    e.b2CircleContact = function() {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
    };
    e.Create = function() {
        return new e
    };
    e.Destroy = function() {};
    e.prototype.Reset = function(a, b) {
        this.__super.Reset.call(this, a, b)
    };
    e.prototype.Evaluate =
        function() {
            var b = this.m_fixtureA.GetBody(),
                c = this.m_fixtureB.GetBody();
            bc.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape() instanceof a ? this.m_fixtureA.GetShape() : null, b.m_xf, this.m_fixtureB.GetShape() instanceof a ? this.m_fixtureB.GetShape() : null, c.m_xf)
        };
    f.b2Contact = function() {
        this.m_nodeA = new l;
        this.m_nodeB = new l;
        this.m_manifold = new jc;
        this.m_oldManifold = new jc
    };
    f.prototype.GetManifold = function() {
        return this.m_manifold
    };
    f.prototype.GetWorldManifold = function(a) {
        var b = this.m_fixtureA.GetBody(),
            c = this.m_fixtureB.GetBody(),
            d = this.m_fixtureA.GetShape(),
            e = this.m_fixtureB.GetShape();
        a.Initialize(this.m_manifold, b.GetTransform(), d.m_radius, c.GetTransform(), e.m_radius)
    };
    f.prototype.IsTouching = function() {
        return (this.m_flags & f.e_touchingFlag) == f.e_touchingFlag
    };
    f.prototype.IsContinuous = function() {
        return (this.m_flags & f.e_continuousFlag) == f.e_continuousFlag
    };
    f.prototype.SetSensor = function(a) {
        this.m_flags = a ? this.m_flags | f.e_sensorFlag : this.m_flags & ~f.e_sensorFlag
    };
    f.prototype.IsSensor = function() {
        return (this.m_flags &
            f.e_sensorFlag) == f.e_sensorFlag
    };
    f.prototype.SetEnabled = function(a) {
        this.m_flags = a ? this.m_flags | f.e_enabledFlag : this.m_flags & ~f.e_enabledFlag
    };
    f.prototype.IsEnabled = function() {
        return (this.m_flags & f.e_enabledFlag) == f.e_enabledFlag
    };
    f.prototype.GetNext = function() {
        return this.m_next
    };
    f.prototype.GetFixtureA = function() {
        return this.m_fixtureA
    };
    f.prototype.GetFixtureB = function() {
        return this.m_fixtureB
    };
    f.prototype.FlagForFiltering = function() {
        this.m_flags |= f.e_filterFlag
    };
    f.prototype.b2Contact = function() {};
    f.prototype.Reset = function(a, b) {
        void 0 === a && (a = null);
        void 0 === b && (b = null);
        this.m_flags = f.e_enabledFlag;
        if (a && b) {
            if (a.IsSensor() || b.IsSensor()) this.m_flags |= f.e_sensorFlag;
            var c = a.GetBody(),
                d = b.GetBody();
            if (c.GetType() != Xb.b2_dynamicBody || c.IsBullet() || d.GetType() != Xb.b2_dynamicBody || d.IsBullet()) this.m_flags |= f.e_continuousFlag;
            this.m_fixtureA = a;
            this.m_fixtureB = b;
            this.m_manifold.m_pointCount = 0;
            this.m_next = this.m_prev = null;
            this.m_nodeA.contact = null;
            this.m_nodeA.prev = null;
            this.m_nodeA.next = null;
            this.m_nodeA.other =
                null;
            this.m_nodeB.contact = null;
            this.m_nodeB.prev = null;
            this.m_nodeB.next = null;
            this.m_nodeB.other = null
        } else this.m_fixtureB = this.m_fixtureA = null
    };
    f.prototype.Update = function(a) {
        var b = this.m_oldManifold;
        this.m_oldManifold = this.m_manifold;
        this.m_manifold = b;
        this.m_flags |= f.e_enabledFlag;
        var c = !1,
            b = (this.m_flags & f.e_touchingFlag) == f.e_touchingFlag,
            e = this.m_fixtureA.m_body,
            g = this.m_fixtureB.m_body,
            h = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);
        if (this.m_flags & f.e_sensorFlag) h && (c = this.m_fixtureA.GetShape(),
            h = this.m_fixtureB.GetShape(), e = e.GetTransform(), g = g.GetTransform(), c = d.TestOverlap(c, e, h, g)), this.m_manifold.m_pointCount = 0;
        else {
            e.GetType() != Xb.b2_dynamicBody || e.IsBullet() || g.GetType() != Xb.b2_dynamicBody || g.IsBullet() ? this.m_flags |= f.e_continuousFlag : this.m_flags &= ~f.e_continuousFlag;
            if (h)
                for (this.Evaluate(), c = 0 < this.m_manifold.m_pointCount, h = 0; h < this.m_manifold.m_pointCount; ++h) {
                    var l = this.m_manifold.m_points[h];
                    l.m_normalImpulse = 0;
                    l.m_tangentImpulse = 0;
                    for (var m = l.m_id, p = 0; p < this.m_oldManifold.m_pointCount; ++p) {
                        var q =
                            this.m_oldManifold.m_points[p];
                        if (q.m_id.key == m.key) {
                            l.m_normalImpulse = q.m_normalImpulse;
                            l.m_tangentImpulse = q.m_tangentImpulse;
                            break
                        }
                    }
                } else this.m_manifold.m_pointCount = 0;
            c != b && (e.SetAwake(!0), g.SetAwake(!0))
        }
        this.m_flags = c ? this.m_flags | f.e_touchingFlag : this.m_flags & ~f.e_touchingFlag;
        0 == b && 1 == c && a.BeginContact(this);
        1 == b && 0 == c && a.EndContact(this);
        0 == (this.m_flags & f.e_sensorFlag) && a.PreSolve(this, this.m_oldManifold)
    };
    f.prototype.Evaluate = function() {};
    f.prototype.ComputeTOI = function(a, b) {
        f.s_input.proxyA.Set(this.m_fixtureA.GetShape());
        f.s_input.proxyB.Set(this.m_fixtureB.GetShape());
        f.s_input.sweepA = a;
        f.s_input.sweepB = b;
        f.s_input.tolerance = aa.b2_linearSlop;
        return cc.TimeOfImpact(f.s_input)
    };
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 1;
        Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 2;
        Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 4;
        Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 8;
        Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 16;
        Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 32;
        Box2D.Dynamics.Contacts.b2Contact.e_filterFlag =
            64;
        Box2D.Dynamics.Contacts.b2Contact.s_input = new dc
    });
    g.b2ContactConstraint = function() {
        this.localPlaneNormal = new ac;
        this.localPoint = new ac;
        this.normal = new ac;
        this.normalMass = new Yb;
        this.K = new Yb
    };
    g.prototype.b2ContactConstraint = function() {
        this.points = new Vector(aa.b2_maxManifoldPoints);
        for (var a = 0; a < aa.b2_maxManifoldPoints; a++) this.points[a] = new h
    };
    h.b2ContactConstraintPoint = function() {
        this.localPoint = new ac;
        this.rA = new ac;
        this.rB = new ac
    };
    l.b2ContactEdge = function() {};
    m.b2ContactFactory = function() {};
    m.prototype.b2ContactFactory = function(a) {
        this.m_allocator = a;
        this.InitializeRegisters()
    };
    m.prototype.AddType = function(a, b, c, d) {
        void 0 === c && (c = 0);
        void 0 === d && (d = 0);
        this.m_registers[c][d].createFcn = a;
        this.m_registers[c][d].destroyFcn = b;
        this.m_registers[c][d].primary = !0;
        c != d && (this.m_registers[d][c].createFcn = a, this.m_registers[d][c].destroyFcn = b, this.m_registers[d][c].primary = !1)
    };
    m.prototype.InitializeRegisters = function() {
        this.m_registers = new Vector(d.e_shapeTypeCount);
        for (var a = 0; a < d.e_shapeTypeCount; a++) {
            this.m_registers[a] =
                new Vector(d.e_shapeTypeCount);
            for (var b = 0; b < d.e_shapeTypeCount; b++) this.m_registers[a][b] = new q
        }
        this.AddType(e.Create, e.Destroy, d.e_circleShape, d.e_circleShape);
        this.AddType(K.Create, K.Destroy, d.e_polygonShape, d.e_circleShape);
        this.AddType(E.Create, E.Destroy, d.e_polygonShape, d.e_polygonShape);
        this.AddType(A.Create, A.Destroy, d.e_edgeShape, d.e_circleShape);
        this.AddType(H.Create, H.Destroy, d.e_polygonShape, d.e_edgeShape)
    };
    m.prototype.Create = function(a, b) {
        var c = parseInt(a.GetType()),
            d = parseInt(b.GetType()),
            c = this.m_registers[c][d];
        if (c.pool) return d = c.pool, c.pool = d.m_next, c.poolCount--, d.Reset(a, b), d;
        d = c.createFcn;
        return null != d ? (c.primary ? (d = d(this.m_allocator), d.Reset(a, b)) : (d = d(this.m_allocator), d.Reset(b, a)), d) : null
    };
    m.prototype.Destroy = function(a) {
        0 < a.m_manifold.m_pointCount && (a.m_fixtureA.m_body.SetAwake(!0), a.m_fixtureB.m_body.SetAwake(!0));
        var b = parseInt(a.m_fixtureA.GetType()),
            c = parseInt(a.m_fixtureB.GetType()),
            b = this.m_registers[b][c];
        b.poolCount++;
        a.m_next = b.pool;
        b.pool = a;
        b = b.destroyFcn;
        b(a, this.m_allocator)
    };
    q.b2ContactRegister = function() {};
    p.b2ContactResult = function() {
        this.position = new ac;
        this.normal = new ac;
        this.id = new ec
    };
    y.b2ContactSolver = function() {
        this.m_step = new Zb;
        this.m_constraints = new Vector
    };
    y.prototype.b2ContactSolver = function() {};
    y.prototype.Initialize = function(a, b, c, d) {
        void 0 === c && (c = 0);
        var e;
        this.m_step.Set(a);
        this.m_allocator = d;
        for (this.m_constraintCount = c; this.m_constraints.length < this.m_constraintCount;) this.m_constraints[this.m_constraints.length] = new g;
        for (a =
            0; a < c; ++a) {
            e = b[a];
            d = e.m_fixtureA;
            var f = e.m_fixtureB,
                h = d.m_shape.m_radius,
                l = f.m_shape.m_radius,
                m = d.m_body,
                p = f.m_body,
                q = e.GetManifold(),
                A = aa.b2MixFriction(d.GetFriction(), f.GetFriction()),
                B = aa.b2MixRestitution(d.GetRestitution(), f.GetRestitution()),
                H = m.m_linearVelocity.x,
                E = m.m_linearVelocity.y,
                K = p.m_linearVelocity.x,
                M = p.m_linearVelocity.y,
                Yb = m.m_angularVelocity,
                Xb = p.m_angularVelocity;
            aa.b2Assert(0 < q.m_pointCount);
            y.s_worldManifold.Initialize(q, m.m_xf, h, p.m_xf, l);
            f = y.s_worldManifold.m_normal.x;
            e = y.s_worldManifold.m_normal.y;
            d = this.m_constraints[a];
            d.bodyA = m;
            d.bodyB = p;
            d.manifold = q;
            d.normal.x = f;
            d.normal.y = e;
            d.pointCount = q.m_pointCount;
            d.friction = A;
            d.restitution = B;
            d.localPlaneNormal.x = q.m_localPlaneNormal.x;
            d.localPlaneNormal.y = q.m_localPlaneNormal.y;
            d.localPoint.x = q.m_localPoint.x;
            d.localPoint.y = q.m_localPoint.y;
            d.radius = h + l;
            d.type = q.m_type;
            for (h = 0; h < d.pointCount; ++h) {
                A = q.m_points[h];
                l = d.points[h];
                l.normalImpulse = A.m_normalImpulse;
                l.tangentImpulse = A.m_tangentImpulse;
                l.localPoint.SetV(A.m_localPoint);
                var A = l.rA.x = y.s_worldManifold.m_points[h].x -
                    m.m_sweep.c.x,
                    B = l.rA.y = y.s_worldManifold.m_points[h].y - m.m_sweep.c.y,
                    Zb = l.rB.x = y.s_worldManifold.m_points[h].x - p.m_sweep.c.x,
                    $b = l.rB.y = y.s_worldManifold.m_points[h].y - p.m_sweep.c.y,
                    cc = A * e - B * f,
                    ac = Zb * e - $b * f,
                    cc = cc * cc,
                    ac = ac * ac;
                l.normalMass = 1 / (m.m_invMass + p.m_invMass + m.m_invI * cc + p.m_invI * ac);
                var dc = m.m_mass * m.m_invMass + p.m_mass * p.m_invMass,
                    dc = dc + (m.m_mass * m.m_invI * cc + p.m_mass * p.m_invI * ac);
                l.equalizedMass = 1 / dc;
                ac = e;
                dc = -f;
                cc = A * dc - B * ac;
                ac = Zb * dc - $b * ac;
                cc *= cc;
                ac *= ac;
                l.tangentMass = 1 / (m.m_invMass + p.m_invMass +
                    m.m_invI * cc + p.m_invI * ac);
                l.velocityBias = 0;
                A = d.normal.x * (K + -Xb * $b - H - -Yb * B) + d.normal.y * (M + Xb * Zb - E - Yb * A);
                A < -aa.b2_velocityThreshold && (l.velocityBias += -d.restitution * A)
            }
            2 == d.pointCount && (M = d.points[0], K = d.points[1], q = m.m_invMass, m = m.m_invI, H = p.m_invMass, p = p.m_invI, E = M.rA.x * e - M.rA.y * f, M = M.rB.x * e - M.rB.y * f, Yb = K.rA.x * e - K.rA.y * f, K = K.rB.x * e - K.rB.y * f, f = q + H + m * E * E + p * M * M, e = q + H + m * Yb * Yb + p * K * K, p = q + H + m * E * Yb + p * M * K, f * f < 100 * (f * e - p * p) ? (d.K.col1.Set(f, p), d.K.col2.Set(p, e), d.K.GetInverse(d.normalMass)) : d.pointCount = 1)
        }
    };
    y.prototype.InitVelocityConstraints = function(a) {
        for (var b = 0; b < this.m_constraintCount; ++b) {
            var c = this.m_constraints[b],
                d = c.bodyA,
                e = c.bodyB,
                f = d.m_invMass,
                g = d.m_invI,
                h = e.m_invMass,
                l = e.m_invI,
                m = c.normal.x,
                p = c.normal.y,
                q = p,
                y = -m,
                A, B;
            if (a.warmStarting)
                for (B = c.pointCount, A = 0; A < B; ++A) {
                    var H = c.points[A];
                    H.normalImpulse *= a.dtRatio;
                    H.tangentImpulse *= a.dtRatio;
                    var E = H.normalImpulse * m + H.tangentImpulse * q,
                        K = H.normalImpulse * p + H.tangentImpulse * y;
                    d.m_angularVelocity -= g * (H.rA.x * K - H.rA.y * E);
                    d.m_linearVelocity.x -= f * E;
                    d.m_linearVelocity.y -= f * K;
                    e.m_angularVelocity += l * (H.rB.x * K - H.rB.y * E);
                    e.m_linearVelocity.x += h * E;
                    e.m_linearVelocity.y += h * K
                } else
                    for (B = c.pointCount, A = 0; A < B; ++A) d = c.points[A], d.normalImpulse = 0, d.tangentImpulse = 0
        }
    };
    y.prototype.SolveVelocityConstraints = function() {
        for (var a, b, c, d, e, f, g, h, l, m, p = 0; p < this.m_constraintCount; ++p) {
            e = this.m_constraints[p];
            var q = e.bodyA,
                y = e.bodyB,
                A = q.m_angularVelocity,
                B = y.m_angularVelocity,
                H = q.m_linearVelocity,
                E = y.m_linearVelocity,
                K = q.m_invMass,
                M = q.m_invI,
                aa = y.m_invMass,
                Yb = y.m_invI;
            h = e.normal.x;
            var Xb = l = e.normal.y;
            m = -h;
            g = e.friction;
            for (a = 0; a < e.pointCount; a++) b = e.points[a], c = E.x - B * b.rB.y - H.x + A * b.rA.y, d = E.y + B * b.rB.x - H.y - A * b.rA.x, c = c * Xb + d * m, c = b.tangentMass * -c, d = g * b.normalImpulse, d = $b.Clamp(b.tangentImpulse + c, -d, d), c = d - b.tangentImpulse, f = c * Xb, c *= m, H.x -= K * f, H.y -= K * c, A -= M * (b.rA.x * c - b.rA.y * f), E.x += aa * f, E.y += aa * c, B += Yb * (b.rB.x * c - b.rB.y * f), b.tangentImpulse = d;
            parseInt(e.pointCount);
            if (1 == e.pointCount) b = e.points[0], c = E.x + -B * b.rB.y - H.x - -A * b.rA.y, d = E.y + B * b.rB.x - H.y - A * b.rA.x, e = c * h + d * l, c = -b.normalMass * (e - b.velocityBias), d = b.normalImpulse + c, d = 0 < d ? d : 0, c = d - b.normalImpulse, f = c * h, c *= l, H.x -= K * f, H.y -= K * c, A -= M * (b.rA.x * c - b.rA.y * f), E.x += aa * f, E.y += aa * c, B += Yb * (b.rB.x * c - b.rB.y * f), b.normalImpulse = d;
            else {
                b = e.points[0];
                a = e.points[1];
                c = b.normalImpulse;
                g = a.normalImpulse;
                var Zb = (E.x - B * b.rB.y - H.x + A * b.rA.y) * h + (E.y + B * b.rB.x - H.y - A * b.rA.x) * l,
                    cc = (E.x - B * a.rB.y - H.x + A * a.rA.y) * h + (E.y + B * a.rB.x - H.y - A * a.rA.x) * l;
                d = Zb - b.velocityBias;
                f = cc - a.velocityBias;
                m = e.K;
                d -= m.col1.x * c + m.col2.x * g;
                for (f -= m.col1.y * c + m.col2.y * g;;) {
                    m =
                        e.normalMass;
                    Xb = -(m.col1.x * d + m.col2.x * f);
                    m = -(m.col1.y * d + m.col2.y * f);
                    if (0 <= Xb && 0 <= m) {
                        c = Xb - c;
                        g = m - g;
                        e = c * h;
                        c *= l;
                        h *= g;
                        l *= g;
                        H.x -= K * (e + h);
                        H.y -= K * (c + l);
                        A -= M * (b.rA.x * c - b.rA.y * e + a.rA.x * l - a.rA.y * h);
                        E.x += aa * (e + h);
                        E.y += aa * (c + l);
                        B += Yb * (b.rB.x * c - b.rB.y * e + a.rB.x * l - a.rB.y * h);
                        b.normalImpulse = Xb;
                        a.normalImpulse = m;
                        break
                    }
                    Xb = -b.normalMass * d;
                    m = 0;
                    cc = e.K.col1.y * Xb + f;
                    if (0 <= Xb && 0 <= cc) {
                        c = Xb - c;
                        g = m - g;
                        e = c * h;
                        c *= l;
                        h *= g;
                        l *= g;
                        H.x -= K * (e + h);
                        H.y -= K * (c + l);
                        A -= M * (b.rA.x * c - b.rA.y * e + a.rA.x * l - a.rA.y * h);
                        E.x += aa * (e + h);
                        E.y += aa * (c + l);
                        B += Yb * (b.rB.x *
                            c - b.rB.y * e + a.rB.x * l - a.rB.y * h);
                        b.normalImpulse = Xb;
                        a.normalImpulse = m;
                        break
                    }
                    Xb = 0;
                    m = -a.normalMass * f;
                    Zb = e.K.col2.x * m + d;
                    if (0 <= m && 0 <= Zb) {
                        c = Xb - c;
                        g = m - g;
                        e = c * h;
                        c *= l;
                        h *= g;
                        l *= g;
                        H.x -= K * (e + h);
                        H.y -= K * (c + l);
                        A -= M * (b.rA.x * c - b.rA.y * e + a.rA.x * l - a.rA.y * h);
                        E.x += aa * (e + h);
                        E.y += aa * (c + l);
                        B += Yb * (b.rB.x * c - b.rB.y * e + a.rB.x * l - a.rB.y * h);
                        b.normalImpulse = Xb;
                        a.normalImpulse = m;
                        break
                    }
                    m = Xb = 0;
                    Zb = d;
                    cc = f;
                    if (0 <= Zb && 0 <= cc) {
                        c = Xb - c;
                        g = m - g;
                        e = c * h;
                        c *= l;
                        h *= g;
                        l *= g;
                        H.x -= K * (e + h);
                        H.y -= K * (c + l);
                        A -= M * (b.rA.x * c - b.rA.y * e + a.rA.x * l - a.rA.y * h);
                        E.x += aa * (e + h);
                        E.y +=
                            aa * (c + l);
                        B += Yb * (b.rB.x * c - b.rB.y * e + a.rB.x * l - a.rB.y * h);
                        b.normalImpulse = Xb;
                        a.normalImpulse = m;
                        break
                    }
                    break
                }
            }
            q.m_angularVelocity = A;
            y.m_angularVelocity = B
        }
    };
    y.prototype.FinalizeVelocityConstraints = function() {
        for (var a = 0; a < this.m_constraintCount; ++a)
            for (var b = this.m_constraints[a], c = b.manifold, d = 0; d < b.pointCount; ++d) {
                var e = c.m_points[d],
                    f = b.points[d];
                e.m_normalImpulse = f.normalImpulse;
                e.m_tangentImpulse = f.tangentImpulse
            }
    };
    y.prototype.SolvePositionConstraints = function(a) {
        void 0 === a && (a = 0);
        for (var b = 0, c = 0; c <
            this.m_constraintCount; c++) {
            var d = this.m_constraints[c],
                e = d.bodyA,
                f = d.bodyB,
                g = e.m_mass * e.m_invMass,
                h = e.m_mass * e.m_invI,
                l = f.m_mass * f.m_invMass,
                m = f.m_mass * f.m_invI;
            y.s_psm.Initialize(d);
            for (var p = y.s_psm.m_normal, q = 0; q < d.pointCount; q++) {
                var A = d.points[q],
                    B = y.s_psm.m_points[q],
                    H = y.s_psm.m_separations[q],
                    E = B.x - e.m_sweep.c.x,
                    K = B.y - e.m_sweep.c.y,
                    M = B.x - f.m_sweep.c.x,
                    B = B.y - f.m_sweep.c.y,
                    b = b < H ? b : H,
                    H = $b.Clamp(a * (H + aa.b2_linearSlop), -aa.b2_maxLinearCorrection, 0),
                    H = -A.equalizedMass * H,
                    A = H * p.x,
                    H = H * p.y;
                e.m_sweep.c.x -=
                    g * A;
                e.m_sweep.c.y -= g * H;
                e.m_sweep.a -= h * (E * H - K * A);
                e.SynchronizeTransform();
                f.m_sweep.c.x += l * A;
                f.m_sweep.c.y += l * H;
                f.m_sweep.a += m * (M * H - B * A);
                f.SynchronizeTransform()
            }
        }
        return b > -1.5 * aa.b2_linearSlop
    };
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new gc;
        Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new M
    });
    Box2D.inherit(A, Box2D.Dynamics.Contacts.b2Contact);
    A.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    A.b2EdgeAndCircleContact = function() {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this,
            arguments)
    };
    A.Create = function() {
        return new A
    };
    A.Destroy = function() {};
    A.prototype.Reset = function(a, b) {
        this.__super.Reset.call(this, a, b)
    };
    A.prototype.Evaluate = function() {
        var b = this.m_fixtureA.GetBody(),
            d = this.m_fixtureB.GetBody();
        this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof c ? this.m_fixtureA.GetShape() : null, b.m_xf, this.m_fixtureB.GetShape() instanceof a ? this.m_fixtureB.GetShape() : null, d.m_xf)
    };
    A.prototype.b2CollideEdgeAndCircle = function() {};
    Box2D.inherit(B, Box2D.Dynamics.Contacts.b2Contact);
    B.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    B.b2NullContact = function() {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
    };
    B.prototype.b2NullContact = function() {
        this.__super.b2Contact.call(this)
    };
    B.prototype.Evaluate = function() {};
    Box2D.inherit(K, Box2D.Dynamics.Contacts.b2Contact);
    K.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    K.b2PolyAndCircleContact = function() {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
    };
    K.Create = function() {
        return new K
    };
    K.Destroy = function() {};
    K.prototype.Reset = function(a, b) {
        this.__super.Reset.call(this, a, b);
        aa.b2Assert(a.GetType() == d.e_polygonShape);
        aa.b2Assert(b.GetType() == d.e_circleShape)
    };
    K.prototype.Evaluate = function() {
        var c = this.m_fixtureA.m_body,
            d = this.m_fixtureB.m_body;
        bc.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof b ? this.m_fixtureA.GetShape() : null, c.m_xf, this.m_fixtureB.GetShape() instanceof a ? this.m_fixtureB.GetShape() : null, d.m_xf)
    };
    Box2D.inherit(H, Box2D.Dynamics.Contacts.b2Contact);
    H.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    H.b2PolyAndEdgeContact = function() {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
    };
    H.Create = function() {
        return new H
    };
    H.Destroy = function() {};
    H.prototype.Reset = function(a, b) {
        this.__super.Reset.call(this, a, b);
        aa.b2Assert(a.GetType() == d.e_polygonShape);
        aa.b2Assert(b.GetType() == d.e_edgeShape)
    };
    H.prototype.Evaluate = function() {
        var a = this.m_fixtureA.GetBody(),
            d = this.m_fixtureB.GetBody();
        this.b2CollidePolyAndEdge(this.m_manifold,
            this.m_fixtureA.GetShape() instanceof b ? this.m_fixtureA.GetShape() : null, a.m_xf, this.m_fixtureB.GetShape() instanceof c ? this.m_fixtureB.GetShape() : null, d.m_xf)
    };
    H.prototype.b2CollidePolyAndEdge = function() {};
    Box2D.inherit(E, Box2D.Dynamics.Contacts.b2Contact);
    E.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;
    E.b2PolygonContact = function() {
        Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments)
    };
    E.Create = function() {
        return new E
    };
    E.Destroy = function() {};
    E.prototype.Reset = function(a,
        b) {
        this.__super.Reset.call(this, a, b)
    };
    E.prototype.Evaluate = function() {
        var a = this.m_fixtureA.GetBody(),
            c = this.m_fixtureB.GetBody();
        bc.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape() instanceof b ? this.m_fixtureA.GetShape() : null, a.m_xf, this.m_fixtureB.GetShape() instanceof b ? this.m_fixtureB.GetShape() : null, c.m_xf)
    };
    M.b2PositionSolverManifold = function() {};
    M.prototype.b2PositionSolverManifold = function() {
        this.m_normal = new ac;
        this.m_separations = new Vector_a2j_Number(aa.b2_maxManifoldPoints);
        this.m_points =
            new Vector(aa.b2_maxManifoldPoints);
        for (var a = 0; a < aa.b2_maxManifoldPoints; a++) this.m_points[a] = new ac
    };
    M.prototype.Initialize = function(a) {
        aa.b2Assert(0 < a.pointCount);
        var b, c, d, e, f, g;
        switch (a.type) {
            case jc.e_circles:
                e = a.bodyA.m_xf.R;
                d = a.localPoint;
                b = a.bodyA.m_xf.position.x + (e.col1.x * d.x + e.col2.x * d.y);
                c = a.bodyA.m_xf.position.y + (e.col1.y * d.x + e.col2.y * d.y);
                e = a.bodyB.m_xf.R;
                d = a.points[0].localPoint;
                f = a.bodyB.m_xf.position.x + (e.col1.x * d.x + e.col2.x * d.y);
                e = a.bodyB.m_xf.position.y + (e.col1.y * d.x + e.col2.y * d.y);
                d = f - b;
                g = e - c;
                var h = d * d + g * g;
                h > Number.MIN_VALUE * Number.MIN_VALUE ? (h = Math.sqrt(h), this.m_normal.x = d / h, this.m_normal.y = g / h) : (this.m_normal.x = 1, this.m_normal.y = 0);
                this.m_points[0].x = .5 * (b + f);
                this.m_points[0].y = .5 * (c + e);
                this.m_separations[0] = d * this.m_normal.x + g * this.m_normal.y - a.radius;
                break;
            case jc.e_faceA:
                e = a.bodyA.m_xf.R;
                d = a.localPlaneNormal;
                this.m_normal.x = e.col1.x * d.x + e.col2.x * d.y;
                this.m_normal.y = e.col1.y * d.x + e.col2.y * d.y;
                e = a.bodyA.m_xf.R;
                d = a.localPoint;
                f = a.bodyA.m_xf.position.x + (e.col1.x * d.x + e.col2.x *
                    d.y);
                g = a.bodyA.m_xf.position.y + (e.col1.y * d.x + e.col2.y * d.y);
                e = a.bodyB.m_xf.R;
                for (b = 0; b < a.pointCount; ++b) d = a.points[b].localPoint, c = a.bodyB.m_xf.position.x + (e.col1.x * d.x + e.col2.x * d.y), d = a.bodyB.m_xf.position.y + (e.col1.y * d.x + e.col2.y * d.y), this.m_separations[b] = (c - f) * this.m_normal.x + (d - g) * this.m_normal.y - a.radius, this.m_points[b].x = c, this.m_points[b].y = d;
                break;
            case jc.e_faceB:
                e = a.bodyB.m_xf.R;
                d = a.localPlaneNormal;
                this.m_normal.x = e.col1.x * d.x + e.col2.x * d.y;
                this.m_normal.y = e.col1.y * d.x + e.col2.y * d.y;
                e = a.bodyB.m_xf.R;
                d = a.localPoint;
                f = a.bodyB.m_xf.position.x + (e.col1.x * d.x + e.col2.x * d.y);
                g = a.bodyB.m_xf.position.y + (e.col1.y * d.x + e.col2.y * d.y);
                e = a.bodyA.m_xf.R;
                for (b = 0; b < a.pointCount; ++b) d = a.points[b].localPoint, c = a.bodyA.m_xf.position.x + (e.col1.x * d.x + e.col2.x * d.y), d = a.bodyA.m_xf.position.y + (e.col1.y * d.x + e.col2.y * d.y), this.m_separations[b] = (c - f) * this.m_normal.x + (d - g) * this.m_normal.y - a.radius, this.m_points[b].Set(c, d);
                this.m_normal.x *= -1;
                this.m_normal.y *= -1
        }
    };
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA =
            new ac;
        Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new ac
    })
})();
(function() {
    var a = Box2D.Common.Math.b2Mat22,
        c = Box2D.Common.Math.b2Math,
        b = Box2D.Common.Math.b2Vec2,
        d = Box2D.Common.b2Color,
        e = Box2D.Dynamics.Controllers.b2BuoyancyController,
        f = Box2D.Dynamics.Controllers.b2ConstantAccelController,
        g = Box2D.Dynamics.Controllers.b2ConstantForceController,
        h = Box2D.Dynamics.Controllers.b2Controller,
        l = Box2D.Dynamics.Controllers.b2ControllerEdge,
        m = Box2D.Dynamics.Controllers.b2GravityController,
        q = Box2D.Dynamics.Controllers.b2TensorDampingController;
    Box2D.inherit(e, Box2D.Dynamics.Controllers.b2Controller);
    e.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    e.b2BuoyancyController = function() {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.normal = new b(0, -1);
        this.density = this.offset = 0;
        this.velocity = new b(0, 0);
        this.linearDrag = 2;
        this.angularDrag = 1;
        this.useDensity = !1;
        this.useWorldGravity = !0;
        this.gravity = null
    };
    e.prototype.Step = function() {
        if (this.m_bodyList) {
            this.useWorldGravity && (this.gravity = this.GetWorld().GetGravity().Copy());
            for (var a = this.m_bodyList; a; a =
                a.nextBody) {
                var c = a.body;
                if (0 != c.IsAwake()) {
                    for (var d = new b, e = new b, f = 0, g = 0, h = c.GetFixtureList(); h; h = h.GetNext()) {
                        var l = new b,
                            m = h.GetShape().ComputeSubmergedArea(this.normal, this.offset, c.GetTransform(), l),
                            f = f + m;
                        d.x += m * l.x;
                        d.y += m * l.y;
                        g += 1 * m;
                        e.x += m * l.x * 1;
                        e.y += m * l.y * 1
                    }
                    d.x /= f;
                    d.y /= f;
                    e.x /= g;
                    e.y /= g;
                    f < Number.MIN_VALUE || (g = this.gravity.GetNegative(), g.Multiply(this.density * f), c.ApplyForce(g, e), e = c.GetLinearVelocityFromWorldPoint(d), e.Subtract(this.velocity), e.Multiply(-this.linearDrag * f), c.ApplyForce(e,
                        d), c.ApplyTorque(-c.GetInertia() / c.GetMass() * f * c.GetAngularVelocity() * this.angularDrag))
                }
            }
        }
    };
    e.prototype.Draw = function(a) {
        var c = new b,
            e = new b;
        c.x = this.normal.x * this.offset + 1E3 * this.normal.y;
        c.y = this.normal.y * this.offset - 1E3 * this.normal.x;
        e.x = this.normal.x * this.offset - 1E3 * this.normal.y;
        e.y = this.normal.y * this.offset + 1E3 * this.normal.x;
        var f = new d(0, 0, 1);
        a.DrawSegment(c, e, f)
    };
    Box2D.inherit(f, Box2D.Dynamics.Controllers.b2Controller);
    f.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    f.b2ConstantAccelController = function() {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.A = new b(0, 0)
    };
    f.prototype.Step = function(a) {
        a = new b(this.A.x * a.dt, this.A.y * a.dt);
        for (var c = this.m_bodyList; c; c = c.nextBody) {
            var d = c.body;
            d.IsAwake() && d.SetLinearVelocity(new b(d.GetLinearVelocity().x + a.x, d.GetLinearVelocity().y + a.y))
        }
    };
    Box2D.inherit(g, Box2D.Dynamics.Controllers.b2Controller);
    g.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    g.b2ConstantForceController =
        function() {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
            this.F = new b(0, 0)
        };
    g.prototype.Step = function() {
        for (var a = this.m_bodyList; a; a = a.nextBody) {
            var b = a.body;
            b.IsAwake() && b.ApplyForce(this.F, b.GetWorldCenter())
        }
    };
    h.b2Controller = function() {};
    h.prototype.Step = function() {};
    h.prototype.Draw = function() {};
    h.prototype.AddBody = function(a) {
        var b = new l;
        b.controller = this;
        b.body = a;
        b.nextBody = this.m_bodyList;
        b.prevBody = null;
        this.m_bodyList = b;
        b.nextBody && (b.nextBody.prevBody = b);
        this.m_bodyCount++;
        b.nextController = a.m_controllerList;
        b.prevController = null;
        a.m_controllerList = b;
        b.nextController && (b.nextController.prevController = b);
        a.m_controllerCount++
    };
    h.prototype.RemoveBody = function(a) {
        for (var b = a.m_controllerList; b && b.controller != this;) b = b.nextController;
        b.prevBody && (b.prevBody.nextBody = b.nextBody);
        b.nextBody && (b.nextBody.prevBody = b.prevBody);
        b.nextController && (b.nextController.prevController = b.prevController);
        b.prevController && (b.prevController.nextController = b.nextController);
        this.m_bodyList ==
            b && (this.m_bodyList = b.nextBody);
        a.m_controllerList == b && (a.m_controllerList = b.nextController);
        a.m_controllerCount--;
        this.m_bodyCount--
    };
    h.prototype.Clear = function() {
        for (; this.m_bodyList;) this.RemoveBody(this.m_bodyList.body)
    };
    h.prototype.GetNext = function() {
        return this.m_next
    };
    h.prototype.GetWorld = function() {
        return this.m_world
    };
    h.prototype.GetBodyList = function() {
        return this.m_bodyList
    };
    l.b2ControllerEdge = function() {};
    Box2D.inherit(m, Box2D.Dynamics.Controllers.b2Controller);
    m.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    m.b2GravityController = function() {
        Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
        this.G = 1;
        this.invSqr = !0
    };
    m.prototype.Step = function() {
        var a, c, d, e, f, g, h, l, m, q;
        if (this.invSqr)
            for (a = this.m_bodyList; a; a = a.nextBody)
                for (c = a.body, d = c.GetWorldCenter(), e = c.GetMass(), f = this.m_bodyList; f != a; f = f.nextBody) g = f.body, h = g.GetWorldCenter(), l = h.x - d.x, m = h.y - d.y, q = l * l + m * m, q < Number.MIN_VALUE || (l = new b(l, m), l.Multiply(this.G / q / Math.sqrt(q) * e * g.GetMass()), c.IsAwake() && c.ApplyForce(l, d), l.Multiply(-1),
                    g.IsAwake() && g.ApplyForce(l, h));
        else
            for (a = this.m_bodyList; a; a = a.nextBody)
                for (c = a.body, d = c.GetWorldCenter(), e = c.GetMass(), f = this.m_bodyList; f != a; f = f.nextBody) g = f.body, h = g.GetWorldCenter(), l = h.x - d.x, m = h.y - d.y, q = l * l + m * m, q < Number.MIN_VALUE || (l = new b(l, m), l.Multiply(this.G / q * e * g.GetMass()), c.IsAwake() && c.ApplyForce(l, d), l.Multiply(-1), g.IsAwake() && g.ApplyForce(l, h))
    };
    Box2D.inherit(q, Box2D.Dynamics.Controllers.b2Controller);
    q.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;
    q.b2TensorDampingController =
        function() {
            Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
            this.T = new a;
            this.maxTimestep = 0
        };
    q.prototype.SetAxisAligned = function(a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.T.col1.x = -a;
        this.T.col1.y = 0;
        this.T.col2.x = 0;
        this.T.col2.y = -b;
        this.maxTimestep = 0 < a || 0 < b ? 1 / Math.max(a, b) : 0
    };
    q.prototype.Step = function(a) {
        a = a.dt;
        if (!(a <= Number.MIN_VALUE)) {
            a > this.maxTimestep && 0 < this.maxTimestep && (a = this.maxTimestep);
            for (var d = this.m_bodyList; d; d = d.nextBody) {
                var e = d.body;
                if (e.IsAwake()) {
                    var f =
                        e.GetWorldVector(c.MulMV(this.T, e.GetLocalVector(e.GetLinearVelocity())));
                    e.SetLinearVelocity(new b(e.GetLinearVelocity().x + f.x * a, e.GetLinearVelocity().y + f.y * a))
                }
            }
        }
    }
})();
(function() {
    var a = Box2D.Common.b2Settings,
        c = Box2D.Common.Math.b2Mat22,
        b = Box2D.Common.Math.b2Mat33,
        d = Box2D.Common.Math.b2Math,
        e = Box2D.Common.Math.b2Vec2,
        f = Box2D.Common.Math.b2Vec3,
        g = Box2D.Dynamics.Joints.b2DistanceJoint,
        h = Box2D.Dynamics.Joints.b2DistanceJointDef,
        l = Box2D.Dynamics.Joints.b2FrictionJoint,
        m = Box2D.Dynamics.Joints.b2FrictionJointDef,
        q = Box2D.Dynamics.Joints.b2GearJoint,
        p = Box2D.Dynamics.Joints.b2GearJointDef,
        y = Box2D.Dynamics.Joints.b2Jacobian,
        A = Box2D.Dynamics.Joints.b2Joint,
        B = Box2D.Dynamics.Joints.b2JointDef,
        K = Box2D.Dynamics.Joints.b2JointEdge,
        H = Box2D.Dynamics.Joints.b2LineJoint,
        E = Box2D.Dynamics.Joints.b2LineJointDef,
        M = Box2D.Dynamics.Joints.b2MouseJoint,
        Xb = Box2D.Dynamics.Joints.b2MouseJointDef,
        Zb = Box2D.Dynamics.Joints.b2PrismaticJoint,
        aa = Box2D.Dynamics.Joints.b2PrismaticJointDef,
        Yb = Box2D.Dynamics.Joints.b2PulleyJoint,
        $b = Box2D.Dynamics.Joints.b2PulleyJointDef,
        ac = Box2D.Dynamics.Joints.b2RevoluteJoint,
        bc = Box2D.Dynamics.Joints.b2RevoluteJointDef,
        ec = Box2D.Dynamics.Joints.b2WeldJoint,
        jc = Box2D.Dynamics.Joints.b2WeldJointDef;
    Box2D.inherit(g, Box2D.Dynamics.Joints.b2Joint);
    g.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    g.b2DistanceJoint = function() {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new e;
        this.m_localAnchor2 = new e;
        this.m_u = new e
    };
    g.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    g.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    g.prototype.GetReactionForce = function(a) {
        void 0 === a && (a = 0);
        return new e(a * this.m_impulse * this.m_u.x, a * this.m_impulse * this.m_u.y)
    };
    g.prototype.GetReactionTorque = function() {
        return 0
    };
    g.prototype.GetLength = function() {
        return this.m_length
    };
    g.prototype.SetLength = function(a) {
        void 0 === a && (a = 0);
        this.m_length = a
    };
    g.prototype.GetFrequency = function() {
        return this.m_frequencyHz
    };
    g.prototype.SetFrequency = function(a) {
        void 0 === a && (a = 0);
        this.m_frequencyHz = a
    };
    g.prototype.GetDampingRatio = function() {
        return this.m_dampingRatio
    };
    g.prototype.SetDampingRatio = function(a) {
        void 0 ===
            a && (a = 0);
        this.m_dampingRatio = a
    };
    g.prototype.b2DistanceJoint = function(a) {
        this.__super.b2Joint.call(this, a);
        this.m_localAnchor1.SetV(a.localAnchorA);
        this.m_localAnchor2.SetV(a.localAnchorB);
        this.m_length = a.length;
        this.m_frequencyHz = a.frequencyHz;
        this.m_dampingRatio = a.dampingRatio;
        this.m_bias = this.m_gamma = this.m_impulse = 0
    };
    g.prototype.InitVelocityConstraints = function(b) {
        var c, d, e = this.m_bodyA,
            f = this.m_bodyB;
        c = e.m_xf.R;
        var g = this.m_localAnchor1.x - e.m_sweep.localCenter.x,
            h = this.m_localAnchor1.y - e.m_sweep.localCenter.y;
        d = c.col1.x * g + c.col2.x * h;
        h = c.col1.y * g + c.col2.y * h;
        g = d;
        c = f.m_xf.R;
        var l = this.m_localAnchor2.x - f.m_sweep.localCenter.x,
            m = this.m_localAnchor2.y - f.m_sweep.localCenter.y;
        d = c.col1.x * l + c.col2.x * m;
        m = c.col1.y * l + c.col2.y * m;
        l = d;
        this.m_u.x = f.m_sweep.c.x + l - e.m_sweep.c.x - g;
        this.m_u.y = f.m_sweep.c.y + m - e.m_sweep.c.y - h;
        d = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);
        d > a.b2_linearSlop ? this.m_u.Multiply(1 / d) : this.m_u.SetZero();
        c = g * this.m_u.y - h * this.m_u.x;
        var p = l * this.m_u.y - m * this.m_u.x;
        c = e.m_invMass + e.m_invI *
            c * c + f.m_invMass + f.m_invI * p * p;
        this.m_mass = 0 != c ? 1 / c : 0;
        if (0 < this.m_frequencyHz) {
            d -= this.m_length;
            var p = 2 * Math.PI * this.m_frequencyHz,
                q = this.m_mass * p * p;
            this.m_gamma = b.dt * (2 * this.m_mass * this.m_dampingRatio * p + b.dt * q);
            this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
            this.m_bias = d * b.dt * q * this.m_gamma;
            this.m_mass = c + this.m_gamma;
            this.m_mass = 0 != this.m_mass ? 1 / this.m_mass : 0
        }
        b.warmStarting ? (this.m_impulse *= b.dtRatio, b = this.m_impulse * this.m_u.x, c = this.m_impulse * this.m_u.y, e.m_linearVelocity.x -= e.m_invMass * b, e.m_linearVelocity.y -=
            e.m_invMass * c, e.m_angularVelocity -= e.m_invI * (g * c - h * b), f.m_linearVelocity.x += f.m_invMass * b, f.m_linearVelocity.y += f.m_invMass * c, f.m_angularVelocity += f.m_invI * (l * c - m * b)) : this.m_impulse = 0
    };
    g.prototype.SolveVelocityConstraints = function() {
        var a, b = this.m_bodyA,
            c = this.m_bodyB;
        a = b.m_xf.R;
        var d = this.m_localAnchor1.x - b.m_sweep.localCenter.x,
            e = this.m_localAnchor1.y - b.m_sweep.localCenter.y,
            f = a.col1.x * d + a.col2.x * e,
            e = a.col1.y * d + a.col2.y * e,
            d = f;
        a = c.m_xf.R;
        var g = this.m_localAnchor2.x - c.m_sweep.localCenter.x,
            h = this.m_localAnchor2.y -
            c.m_sweep.localCenter.y,
            f = a.col1.x * g + a.col2.x * h,
            h = a.col1.y * g + a.col2.y * h,
            g = f,
            f = -this.m_mass * (this.m_u.x * (c.m_linearVelocity.x + -c.m_angularVelocity * h - (b.m_linearVelocity.x + -b.m_angularVelocity * e)) + this.m_u.y * (c.m_linearVelocity.y + c.m_angularVelocity * g - (b.m_linearVelocity.y + b.m_angularVelocity * d)) + this.m_bias + this.m_gamma * this.m_impulse);
        this.m_impulse += f;
        a = f * this.m_u.x;
        f *= this.m_u.y;
        b.m_linearVelocity.x -= b.m_invMass * a;
        b.m_linearVelocity.y -= b.m_invMass * f;
        b.m_angularVelocity -= b.m_invI * (d * f - e * a);
        c.m_linearVelocity.x +=
            c.m_invMass * a;
        c.m_linearVelocity.y += c.m_invMass * f;
        c.m_angularVelocity += c.m_invI * (g * f - h * a)
    };
    g.prototype.SolvePositionConstraints = function() {
        var b;
        if (0 < this.m_frequencyHz) return !0;
        var c = this.m_bodyA,
            e = this.m_bodyB;
        b = c.m_xf.R;
        var f = this.m_localAnchor1.x - c.m_sweep.localCenter.x,
            g = this.m_localAnchor1.y - c.m_sweep.localCenter.y,
            h = b.col1.x * f + b.col2.x * g,
            g = b.col1.y * f + b.col2.y * g,
            f = h;
        b = e.m_xf.R;
        var l = this.m_localAnchor2.x - e.m_sweep.localCenter.x,
            m = this.m_localAnchor2.y - e.m_sweep.localCenter.y,
            h = b.col1.x * l + b.col2.x *
            m,
            m = b.col1.y * l + b.col2.y * m,
            l = h,
            h = e.m_sweep.c.x + l - c.m_sweep.c.x - f,
            p = e.m_sweep.c.y + m - c.m_sweep.c.y - g;
        b = Math.sqrt(h * h + p * p);
        h /= b;
        p /= b;
        b -= this.m_length;
        b = d.Clamp(b, -a.b2_maxLinearCorrection, a.b2_maxLinearCorrection);
        var q = -this.m_mass * b;
        this.m_u.Set(h, p);
        h = q * this.m_u.x;
        p = q * this.m_u.y;
        c.m_sweep.c.x -= c.m_invMass * h;
        c.m_sweep.c.y -= c.m_invMass * p;
        c.m_sweep.a -= c.m_invI * (f * p - g * h);
        e.m_sweep.c.x += e.m_invMass * h;
        e.m_sweep.c.y += e.m_invMass * p;
        e.m_sweep.a += e.m_invI * (l * p - m * h);
        c.SynchronizeTransform();
        e.SynchronizeTransform();
        return d.Abs(b) < a.b2_linearSlop
    };
    Box2D.inherit(h, Box2D.Dynamics.Joints.b2JointDef);
    h.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    h.b2DistanceJointDef = function() {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new e;
        this.localAnchorB = new e
    };
    h.prototype.b2DistanceJointDef = function() {
        this.__super.b2JointDef.call(this);
        this.type = A.e_distanceJoint;
        this.length = 1;
        this.dampingRatio = this.frequencyHz = 0
    };
    h.prototype.Initialize = function(a, b, c, d) {
        this.bodyA =
            a;
        this.bodyB = b;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(c));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(d));
        a = d.x - c.x;
        c = d.y - c.y;
        this.length = Math.sqrt(a * a + c * c);
        this.dampingRatio = this.frequencyHz = 0
    };
    Box2D.inherit(l, Box2D.Dynamics.Joints.b2Joint);
    l.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    l.b2FrictionJoint = function() {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchorA = new e;
        this.m_localAnchorB = new e;
        this.m_linearMass = new c;
        this.m_linearImpulse =
            new e
    };
    l.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
    };
    l.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
    };
    l.prototype.GetReactionForce = function(a) {
        void 0 === a && (a = 0);
        return new e(a * this.m_linearImpulse.x, a * this.m_linearImpulse.y)
    };
    l.prototype.GetReactionTorque = function(a) {
        void 0 === a && (a = 0);
        return a * this.m_angularImpulse
    };
    l.prototype.SetMaxForce = function(a) {
        void 0 === a && (a = 0);
        this.m_maxForce = a
    };
    l.prototype.GetMaxForce = function() {
        return this.m_maxForce
    };
    l.prototype.SetMaxTorque = function(a) {
        void 0 === a && (a = 0);
        this.m_maxTorque = a
    };
    l.prototype.GetMaxTorque = function() {
        return this.m_maxTorque
    };
    l.prototype.b2FrictionJoint = function(a) {
        this.__super.b2Joint.call(this, a);
        this.m_localAnchorA.SetV(a.localAnchorA);
        this.m_localAnchorB.SetV(a.localAnchorB);
        this.m_linearMass.SetZero();
        this.m_angularMass = 0;
        this.m_linearImpulse.SetZero();
        this.m_angularImpulse = 0;
        this.m_maxForce = a.maxForce;
        this.m_maxTorque = a.maxTorque
    };
    l.prototype.InitVelocityConstraints = function(a) {
        var b,
            d, e = this.m_bodyA,
            f = this.m_bodyB;
        b = e.m_xf.R;
        var g = this.m_localAnchorA.x - e.m_sweep.localCenter.x,
            h = this.m_localAnchorA.y - e.m_sweep.localCenter.y;
        d = b.col1.x * g + b.col2.x * h;
        h = b.col1.y * g + b.col2.y * h;
        g = d;
        b = f.m_xf.R;
        var l = this.m_localAnchorB.x - f.m_sweep.localCenter.x,
            m = this.m_localAnchorB.y - f.m_sweep.localCenter.y;
        d = b.col1.x * l + b.col2.x * m;
        m = b.col1.y * l + b.col2.y * m;
        l = d;
        b = e.m_invMass;
        d = f.m_invMass;
        var p = e.m_invI,
            q = f.m_invI,
            y = new c;
        y.col1.x = b + d;
        y.col2.x = 0;
        y.col1.y = 0;
        y.col2.y = b + d;
        y.col1.x += p * h * h;
        y.col2.x += -p * g * h;
        y.col1.y += -p * g * h;
        y.col2.y += p * g * g;
        y.col1.x += q * m * m;
        y.col2.x += -q * l * m;
        y.col1.y += -q * l * m;
        y.col2.y += q * l * l;
        y.GetInverse(this.m_linearMass);
        this.m_angularMass = p + q;
        0 < this.m_angularMass && (this.m_angularMass = 1 / this.m_angularMass);
        a.warmStarting ? (this.m_linearImpulse.x *= a.dtRatio, this.m_linearImpulse.y *= a.dtRatio, this.m_angularImpulse *= a.dtRatio, a = this.m_linearImpulse, e.m_linearVelocity.x -= b * a.x, e.m_linearVelocity.y -= b * a.y, e.m_angularVelocity -= p * (g * a.y - h * a.x + this.m_angularImpulse), f.m_linearVelocity.x += d * a.x,
            f.m_linearVelocity.y += d * a.y, f.m_angularVelocity += q * (l * a.y - m * a.x + this.m_angularImpulse)) : (this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0)
    };
    l.prototype.SolveVelocityConstraints = function(a) {
        var b, c, f = this.m_bodyA,
            g = this.m_bodyB,
            h = f.m_linearVelocity,
            l = f.m_angularVelocity,
            m = g.m_linearVelocity,
            p = g.m_angularVelocity,
            q = f.m_invMass,
            y = g.m_invMass,
            A = f.m_invI,
            B = g.m_invI;
        b = f.m_xf.R;
        var H = this.m_localAnchorA.x - f.m_sweep.localCenter.x,
            E = this.m_localAnchorA.y - f.m_sweep.localCenter.y;
        c = b.col1.x * H + b.col2.x *
            E;
        E = b.col1.y * H + b.col2.y * E;
        H = c;
        b = g.m_xf.R;
        var K = this.m_localAnchorB.x - g.m_sweep.localCenter.x,
            M = this.m_localAnchorB.y - g.m_sweep.localCenter.y;
        c = b.col1.x * K + b.col2.x * M;
        M = b.col1.y * K + b.col2.y * M;
        K = c;
        c = -this.m_angularMass * (p - l);
        var aa = this.m_angularImpulse;
        b = a.dt * this.m_maxTorque;
        this.m_angularImpulse = d.Clamp(this.m_angularImpulse + c, -b, b);
        c = this.m_angularImpulse - aa;
        l -= A * c;
        p += B * c;
        b = d.MulMV(this.m_linearMass, new e(-(m.x - p * M - h.x + l * E), -(m.y + p * K - h.y - l * H)));
        c = this.m_linearImpulse.Copy();
        this.m_linearImpulse.Add(b);
        b = a.dt * this.m_maxForce;
        this.m_linearImpulse.LengthSquared() > b * b && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.Multiply(b));
        b = d.SubtractVV(this.m_linearImpulse, c);
        h.x -= q * b.x;
        h.y -= q * b.y;
        l -= A * (H * b.y - E * b.x);
        m.x += y * b.x;
        m.y += y * b.y;
        p += B * (K * b.y - M * b.x);
        f.m_angularVelocity = l;
        g.m_angularVelocity = p
    };
    l.prototype.SolvePositionConstraints = function() {
        return !0
    };
    Box2D.inherit(m, Box2D.Dynamics.Joints.b2JointDef);
    m.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    m.b2FrictionJointDef = function() {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,
            arguments);
        this.localAnchorA = new e;
        this.localAnchorB = new e
    };
    m.prototype.b2FrictionJointDef = function() {
        this.__super.b2JointDef.call(this);
        this.type = A.e_frictionJoint;
        this.maxTorque = this.maxForce = 0
    };
    m.prototype.Initialize = function(a, b, c) {
        this.bodyA = a;
        this.bodyB = b;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(c));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(c))
    };
    Box2D.inherit(q, Box2D.Dynamics.Joints.b2Joint);
    q.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    q.b2GearJoint = function() {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this,
            arguments);
        this.m_groundAnchor1 = new e;
        this.m_groundAnchor2 = new e;
        this.m_localAnchor1 = new e;
        this.m_localAnchor2 = new e;
        this.m_J = new y
    };
    q.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    q.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    q.prototype.GetReactionForce = function(a) {
        void 0 === a && (a = 0);
        return new e(a * this.m_impulse * this.m_J.linearB.x, a * this.m_impulse * this.m_J.linearB.y)
    };
    q.prototype.GetReactionTorque = function(a) {
        void 0 ===
            a && (a = 0);
        var b = this.m_bodyB.m_xf.R,
            c = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x,
            d = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y,
            e = b.col1.x * c + b.col2.x * d,
            d = b.col1.y * c + b.col2.y * d;
        return a * (this.m_impulse * this.m_J.angularB - e * this.m_impulse * this.m_J.linearB.y + d * this.m_impulse * this.m_J.linearB.x)
    };
    q.prototype.GetRatio = function() {
        return this.m_ratio
    };
    q.prototype.SetRatio = function(a) {
        void 0 === a && (a = 0);
        this.m_ratio = a
    };
    q.prototype.b2GearJoint = function(a) {
        this.__super.b2Joint.call(this,
            a);
        var b = parseInt(a.joint1.m_type),
            c = parseInt(a.joint2.m_type);
        this.m_prismatic2 = this.m_revolute2 = this.m_prismatic1 = this.m_revolute1 = null;
        this.m_ground1 = a.joint1.GetBodyA();
        this.m_bodyA = a.joint1.GetBodyB();
        b == A.e_revoluteJoint ? (this.m_revolute1 = a.joint1 instanceof ac ? a.joint1 : null, this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1), this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2), b = this.m_revolute1.GetJointAngle()) : (this.m_prismatic1 = a.joint1 instanceof Zb ? a.joint1 : null, this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1),
            this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2), b = this.m_prismatic1.GetJointTranslation());
        this.m_ground2 = a.joint2.GetBodyA();
        this.m_bodyB = a.joint2.GetBodyB();
        c == A.e_revoluteJoint ? (this.m_revolute2 = a.joint2 instanceof ac ? a.joint2 : null, this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1), this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2), c = this.m_revolute2.GetJointAngle()) : (this.m_prismatic2 = a.joint2 instanceof Zb ? a.joint2 : null, this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1),
            this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2), c = this.m_prismatic2.GetJointTranslation());
        this.m_ratio = a.ratio;
        this.m_constant = b + this.m_ratio * c;
        this.m_impulse = 0
    };
    q.prototype.InitVelocityConstraints = function(a) {
        var b = this.m_ground1,
            c = this.m_ground2,
            d = this.m_bodyA,
            e = this.m_bodyB,
            f, g, h, l, m, p = 0;
        this.m_J.SetZero();
        this.m_revolute1 ? (this.m_J.angularA = -1, p += d.m_invI) : (b = b.m_xf.R, g = this.m_prismatic1.m_localXAxis1, f = b.col1.x * g.x + b.col2.x * g.y, g = b.col1.y * g.x + b.col2.y * g.y, b = d.m_xf.R, h = this.m_localAnchor1.x -
            d.m_sweep.localCenter.x, l = this.m_localAnchor1.y - d.m_sweep.localCenter.y, m = b.col1.x * h + b.col2.x * l, l = b.col1.y * h + b.col2.y * l, h = m * g - l * f, this.m_J.linearA.Set(-f, -g), this.m_J.angularA = -h, p += d.m_invMass + d.m_invI * h * h);
        this.m_revolute2 ? (this.m_J.angularB = -this.m_ratio, p += this.m_ratio * this.m_ratio * e.m_invI) : (b = c.m_xf.R, g = this.m_prismatic2.m_localXAxis1, f = b.col1.x * g.x + b.col2.x * g.y, g = b.col1.y * g.x + b.col2.y * g.y, b = e.m_xf.R, h = this.m_localAnchor2.x - e.m_sweep.localCenter.x, l = this.m_localAnchor2.y - e.m_sweep.localCenter.y,
            m = b.col1.x * h + b.col2.x * l, l = b.col1.y * h + b.col2.y * l, h = m * g - l * f, this.m_J.linearB.Set(-this.m_ratio * f, -this.m_ratio * g), this.m_J.angularB = -this.m_ratio * h, p += this.m_ratio * this.m_ratio * (e.m_invMass + e.m_invI * h * h));
        this.m_mass = 0 < p ? 1 / p : 0;
        a.warmStarting ? (d.m_linearVelocity.x += d.m_invMass * this.m_impulse * this.m_J.linearA.x, d.m_linearVelocity.y += d.m_invMass * this.m_impulse * this.m_J.linearA.y, d.m_angularVelocity += d.m_invI * this.m_impulse * this.m_J.angularA, e.m_linearVelocity.x += e.m_invMass * this.m_impulse * this.m_J.linearB.x,
            e.m_linearVelocity.y += e.m_invMass * this.m_impulse * this.m_J.linearB.y, e.m_angularVelocity += e.m_invI * this.m_impulse * this.m_J.angularB) : this.m_impulse = 0
    };
    q.prototype.SolveVelocityConstraints = function() {
        var a = this.m_bodyA,
            b = this.m_bodyB,
            c = -this.m_mass * this.m_J.Compute(a.m_linearVelocity, a.m_angularVelocity, b.m_linearVelocity, b.m_angularVelocity);
        this.m_impulse += c;
        a.m_linearVelocity.x += a.m_invMass * c * this.m_J.linearA.x;
        a.m_linearVelocity.y += a.m_invMass * c * this.m_J.linearA.y;
        a.m_angularVelocity += a.m_invI *
            c * this.m_J.angularA;
        b.m_linearVelocity.x += b.m_invMass * c * this.m_J.linearB.x;
        b.m_linearVelocity.y += b.m_invMass * c * this.m_J.linearB.y;
        b.m_angularVelocity += b.m_invI * c * this.m_J.angularB
    };
    q.prototype.SolvePositionConstraints = function() {
        var b = this.m_bodyA,
            c = this.m_bodyB,
            d, e;
        d = this.m_revolute1 ? this.m_revolute1.GetJointAngle() : this.m_prismatic1.GetJointTranslation();
        e = this.m_revolute2 ? this.m_revolute2.GetJointAngle() : this.m_prismatic2.GetJointTranslation();
        d = -this.m_mass * (this.m_constant - (d + this.m_ratio * e));
        b.m_sweep.c.x += b.m_invMass * d * this.m_J.linearA.x;
        b.m_sweep.c.y += b.m_invMass * d * this.m_J.linearA.y;
        b.m_sweep.a += b.m_invI * d * this.m_J.angularA;
        c.m_sweep.c.x += c.m_invMass * d * this.m_J.linearB.x;
        c.m_sweep.c.y += c.m_invMass * d * this.m_J.linearB.y;
        c.m_sweep.a += c.m_invI * d * this.m_J.angularB;
        b.SynchronizeTransform();
        c.SynchronizeTransform();
        return 0 < a.b2_linearSlop
    };
    Box2D.inherit(p, Box2D.Dynamics.Joints.b2JointDef);
    p.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    p.b2GearJointDef = function() {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this,
            arguments)
    };
    p.prototype.b2GearJointDef = function() {
        this.__super.b2JointDef.call(this);
        this.type = A.e_gearJoint;
        this.joint2 = this.joint1 = null;
        this.ratio = 1
    };
    y.b2Jacobian = function() {
        this.linearA = new e;
        this.linearB = new e
    };
    y.prototype.SetZero = function() {
        this.linearA.SetZero();
        this.angularA = 0;
        this.linearB.SetZero();
        this.angularB = 0
    };
    y.prototype.Set = function(a, b, c, d) {
        void 0 === b && (b = 0);
        void 0 === d && (d = 0);
        this.linearA.SetV(a);
        this.angularA = b;
        this.linearB.SetV(c);
        this.angularB = d
    };
    y.prototype.Compute = function(a,
        b, c, d) {
        void 0 === b && (b = 0);
        void 0 === d && (d = 0);
        return this.linearA.x * a.x + this.linearA.y * a.y + this.angularA * b + (this.linearB.x * c.x + this.linearB.y * c.y) + this.angularB * d
    };
    A.b2Joint = function() {
        this.m_edgeA = new K;
        this.m_edgeB = new K;
        this.m_localCenterA = new e;
        this.m_localCenterB = new e
    };
    A.prototype.GetType = function() {
        return this.m_type
    };
    A.prototype.GetAnchorA = function() {
        return null
    };
    A.prototype.GetAnchorB = function() {
        return null
    };
    A.prototype.GetReactionForce = function() {
        return null
    };
    A.prototype.GetReactionTorque =
        function() {
            return 0
        };
    A.prototype.GetBodyA = function() {
        return this.m_bodyA
    };
    A.prototype.GetBodyB = function() {
        return this.m_bodyB
    };
    A.prototype.GetNext = function() {
        return this.m_next
    };
    A.prototype.GetUserData = function() {
        return this.m_userData
    };
    A.prototype.SetUserData = function(a) {
        this.m_userData = a
    };
    A.prototype.IsActive = function() {
        return this.m_bodyA.IsActive() && this.m_bodyB.IsActive()
    };
    A.Create = function(a) {
        var b = null;
        switch (a.type) {
            case A.e_distanceJoint:
                b = new g(a instanceof h ? a : null);
                break;
            case A.e_mouseJoint:
                b =
                    new M(a instanceof Xb ? a : null);
                break;
            case A.e_prismaticJoint:
                b = new Zb(a instanceof aa ? a : null);
                break;
            case A.e_revoluteJoint:
                b = new ac(a instanceof bc ? a : null);
                break;
            case A.e_pulleyJoint:
                b = new Yb(a instanceof $b ? a : null);
                break;
            case A.e_gearJoint:
                b = new q(a instanceof p ? a : null);
                break;
            case A.e_lineJoint:
                b = new H(a instanceof E ? a : null);
                break;
            case A.e_weldJoint:
                b = new ec(a instanceof jc ? a : null);
                break;
            case A.e_frictionJoint:
                b = new l(a instanceof m ? a : null)
        }
        return b
    };
    A.Destroy = function() {};
    A.prototype.b2Joint = function(b) {
        a.b2Assert(b.bodyA !=
            b.bodyB);
        this.m_type = b.type;
        this.m_next = this.m_prev = null;
        this.m_bodyA = b.bodyA;
        this.m_bodyB = b.bodyB;
        this.m_collideConnected = b.collideConnected;
        this.m_islandFlag = !1;
        this.m_userData = b.userData
    };
    A.prototype.InitVelocityConstraints = function() {};
    A.prototype.SolveVelocityConstraints = function() {};
    A.prototype.FinalizeVelocityConstraints = function() {};
    A.prototype.SolvePositionConstraints = function() {
        return !1
    };
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
        Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint =
            1;
        Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
        Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
        Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
        Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
        Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
        Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
        Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
        Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
        Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
        Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
        Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit =
            2;
        Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3
    });
    B.b2JointDef = function() {};
    B.prototype.b2JointDef = function() {
        this.type = A.e_unknownJoint;
        this.bodyB = this.bodyA = this.userData = null;
        this.collideConnected = !1
    };
    K.b2JointEdge = function() {};
    Box2D.inherit(H, Box2D.Dynamics.Joints.b2Joint);
    H.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    H.b2LineJoint = function() {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new e;
        this.m_localAnchor2 = new e;
        this.m_localXAxis1 = new e;
        this.m_localYAxis1 =
            new e;
        this.m_axis = new e;
        this.m_perp = new e;
        this.m_K = new c;
        this.m_impulse = new e
    };
    H.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    H.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    H.prototype.GetReactionForce = function(a) {
        void 0 === a && (a = 0);
        return new e(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y))
    };
    H.prototype.GetReactionTorque = function(a) {
        void 0 === a && (a = 0);
        return a * this.m_impulse.y
    };
    H.prototype.GetJointTranslation = function() {
        var a = this.m_bodyA,
            b = this.m_bodyB,
            c = a.GetWorldPoint(this.m_localAnchor1),
            d = b.GetWorldPoint(this.m_localAnchor2),
            b = d.x - c.x,
            c = d.y - c.y,
            a = a.GetWorldVector(this.m_localXAxis1);
        return a.x * b + a.y * c
    };
    H.prototype.GetJointSpeed = function() {
        var a = this.m_bodyA,
            b = this.m_bodyB,
            c;
        c = a.m_xf.R;
        var d = this.m_localAnchor1.x - a.m_sweep.localCenter.x,
            e = this.m_localAnchor1.y - a.m_sweep.localCenter.y,
            f = c.col1.x * d + c.col2.x * e,
            e = c.col1.y * d + c.col2.y * e,
            d = f;
        c = b.m_xf.R;
        var g = this.m_localAnchor2.x - b.m_sweep.localCenter.x,
            h = this.m_localAnchor2.y - b.m_sweep.localCenter.y,
            f = c.col1.x * g + c.col2.x * h,
            h = c.col1.y * g + c.col2.y * h,
            g = f;
        c = b.m_sweep.c.x + g - (a.m_sweep.c.x + d);
        var f = b.m_sweep.c.y + h - (a.m_sweep.c.y + e),
            l = a.GetWorldVector(this.m_localXAxis1),
            m = a.m_linearVelocity,
            p = b.m_linearVelocity,
            a = a.m_angularVelocity,
            b = b.m_angularVelocity;
        return c * -a * l.y + f * a * l.x + (l.x * (p.x + -b * h - m.x - -a * e) + l.y * (p.y + b * g - m.y - a * d))
    };
    H.prototype.IsLimitEnabled =
        function() {
            return this.m_enableLimit
        };
    H.prototype.EnableLimit = function(a) {
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_enableLimit = a
    };
    H.prototype.GetLowerLimit = function() {
        return this.m_lowerTranslation
    };
    H.prototype.GetUpperLimit = function() {
        return this.m_upperTranslation
    };
    H.prototype.SetLimits = function(a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_lowerTranslation = a;
        this.m_upperTranslation = b
    };
    H.prototype.IsMotorEnabled = function() {
        return this.m_enableMotor
    };
    H.prototype.EnableMotor = function(a) {
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_enableMotor = a
    };
    H.prototype.SetMotorSpeed = function(a) {
        void 0 === a && (a = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_motorSpeed = a
    };
    H.prototype.GetMotorSpeed = function() {
        return this.m_motorSpeed
    };
    H.prototype.SetMaxMotorForce = function(a) {
        void 0 === a && (a = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_maxMotorForce = a
    };
    H.prototype.GetMaxMotorForce = function() {
        return this.m_maxMotorForce
    };
    H.prototype.GetMotorForce = function() {
        return this.m_motorImpulse
    };
    H.prototype.b2LineJoint = function(a) {
        this.__super.b2Joint.call(this, a);
        this.m_localAnchor1.SetV(a.localAnchorA);
        this.m_localAnchor2.SetV(a.localAnchorB);
        this.m_localXAxis1.SetV(a.localAxisA);
        this.m_localYAxis1.x = -this.m_localXAxis1.y;
        this.m_localYAxis1.y = this.m_localXAxis1.x;
        this.m_impulse.SetZero();
        this.m_motorImpulse = this.m_motorMass = 0;
        this.m_lowerTranslation = a.lowerTranslation;
        this.m_upperTranslation = a.upperTranslation;
        this.m_maxMotorForce =
            a.maxMotorForce;
        this.m_motorSpeed = a.motorSpeed;
        this.m_enableLimit = a.enableLimit;
        this.m_enableMotor = a.enableMotor;
        this.m_limitState = A.e_inactiveLimit;
        this.m_axis.SetZero();
        this.m_perp.SetZero()
    };
    H.prototype.InitVelocityConstraints = function(b) {
        var c = this.m_bodyA,
            e = this.m_bodyB,
            f, g;
        this.m_localCenterA.SetV(c.GetLocalCenter());
        this.m_localCenterB.SetV(e.GetLocalCenter());
        var h = c.GetTransform();
        e.GetTransform();
        f = c.m_xf.R;
        var l = this.m_localAnchor1.x - this.m_localCenterA.x,
            m = this.m_localAnchor1.y - this.m_localCenterA.y;
        g = f.col1.x * l + f.col2.x * m;
        m = f.col1.y * l + f.col2.y * m;
        l = g;
        f = e.m_xf.R;
        var p = this.m_localAnchor2.x - this.m_localCenterB.x,
            q = this.m_localAnchor2.y - this.m_localCenterB.y;
        g = f.col1.x * p + f.col2.x * q;
        q = f.col1.y * p + f.col2.y * q;
        p = g;
        f = e.m_sweep.c.x + p - c.m_sweep.c.x - l;
        g = e.m_sweep.c.y + q - c.m_sweep.c.y - m;
        this.m_invMassA = c.m_invMass;
        this.m_invMassB = e.m_invMass;
        this.m_invIA = c.m_invI;
        this.m_invIB = e.m_invI;
        this.m_axis.SetV(d.MulMV(h.R, this.m_localXAxis1));
        this.m_a1 = (f + l) * this.m_axis.y - (g + m) * this.m_axis.x;
        this.m_a2 = p * this.m_axis.y -
            q * this.m_axis.x;
        this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
        this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1 / this.m_motorMass : 0;
        this.m_perp.SetV(d.MulMV(h.R, this.m_localYAxis1));
        this.m_s1 = (f + l) * this.m_perp.y - (g + m) * this.m_perp.x;
        this.m_s2 = p * this.m_perp.y - q * this.m_perp.x;
        h = this.m_invMassA;
        l = this.m_invMassB;
        m = this.m_invIA;
        p = this.m_invIB;
        this.m_K.col1.x = h + l + m * this.m_s1 * this.m_s1 + p * this.m_s2 * this.m_s2;
        this.m_K.col1.y = m * this.m_s1 *
            this.m_a1 + p * this.m_s2 * this.m_a2;
        this.m_K.col2.x = this.m_K.col1.y;
        this.m_K.col2.y = h + l + m * this.m_a1 * this.m_a1 + p * this.m_a2 * this.m_a2;
        this.m_enableLimit ? (f = this.m_axis.x * f + this.m_axis.y * g, d.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * a.b2_linearSlop ? this.m_limitState = A.e_equalLimits : f <= this.m_lowerTranslation ? this.m_limitState != A.e_atLowerLimit && (this.m_limitState = A.e_atLowerLimit, this.m_impulse.y = 0) : f >= this.m_upperTranslation ? this.m_limitState != A.e_atUpperLimit && (this.m_limitState = A.e_atUpperLimit,
            this.m_impulse.y = 0) : (this.m_limitState = A.e_inactiveLimit, this.m_impulse.y = 0)) : this.m_limitState = A.e_inactiveLimit;
        0 == this.m_enableMotor && (this.m_motorImpulse = 0);
        b.warmStarting ? (this.m_impulse.x *= b.dtRatio, this.m_impulse.y *= b.dtRatio, this.m_motorImpulse *= b.dtRatio, b = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x, f = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y, g = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) *
            this.m_a1, h = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2, c.m_linearVelocity.x -= this.m_invMassA * b, c.m_linearVelocity.y -= this.m_invMassA * f, c.m_angularVelocity -= this.m_invIA * g, e.m_linearVelocity.x += this.m_invMassB * b, e.m_linearVelocity.y += this.m_invMassB * f, e.m_angularVelocity += this.m_invIB * h) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0)
    };
    H.prototype.SolveVelocityConstraints = function(a) {
        var b = this.m_bodyA,
            c = this.m_bodyB,
            f = b.m_linearVelocity,
            g = b.m_angularVelocity,
            h = c.m_linearVelocity,
            l = c.m_angularVelocity,
            m, p, q, y;
        this.m_enableMotor && this.m_limitState != A.e_equalLimits && (y = this.m_motorMass * (this.m_motorSpeed - (this.m_axis.x * (h.x - f.x) + this.m_axis.y * (h.y - f.y) + this.m_a2 * l - this.m_a1 * g)), m = this.m_motorImpulse, p = a.dt * this.m_maxMotorForce, this.m_motorImpulse = d.Clamp(this.m_motorImpulse + y, -p, p), y = this.m_motorImpulse - m, m = y * this.m_axis.x, p = y * this.m_axis.y, q = y * this.m_a1, y *= this.m_a2, f.x -= this.m_invMassA * m, f.y -= this.m_invMassA * p, g -= this.m_invIA * q, h.x += this.m_invMassB * m, h.y += this.m_invMassB *
            p, l += this.m_invIB * y);
        p = this.m_perp.x * (h.x - f.x) + this.m_perp.y * (h.y - f.y) + this.m_s2 * l - this.m_s1 * g;
        this.m_enableLimit && this.m_limitState != A.e_inactiveLimit ? (q = this.m_axis.x * (h.x - f.x) + this.m_axis.y * (h.y - f.y) + this.m_a2 * l - this.m_a1 * g, m = this.m_impulse.Copy(), a = this.m_K.Solve(new e, -p, -q), this.m_impulse.Add(a), this.m_limitState == A.e_atLowerLimit ? this.m_impulse.y = d.Max(this.m_impulse.y, 0) : this.m_limitState == A.e_atUpperLimit && (this.m_impulse.y = d.Min(this.m_impulse.y, 0)), p = -p - (this.m_impulse.y - m.y) * this.m_K.col2.x,
            q = 0 != this.m_K.col1.x ? p / this.m_K.col1.x + m.x : m.x, this.m_impulse.x = q, a.x = this.m_impulse.x - m.x, a.y = this.m_impulse.y - m.y, m = a.x * this.m_perp.x + a.y * this.m_axis.x, p = a.x * this.m_perp.y + a.y * this.m_axis.y, q = a.x * this.m_s1 + a.y * this.m_a1, y = a.x * this.m_s2 + a.y * this.m_a2) : (a = 0 != this.m_K.col1.x ? -p / this.m_K.col1.x : 0, this.m_impulse.x += a, m = a * this.m_perp.x, p = a * this.m_perp.y, q = a * this.m_s1, y = a * this.m_s2);
        f.x -= this.m_invMassA * m;
        f.y -= this.m_invMassA * p;
        g -= this.m_invIA * q;
        h.x += this.m_invMassB * m;
        h.y += this.m_invMassB * p;
        l += this.m_invIB *
            y;
        b.m_linearVelocity.SetV(f);
        b.m_angularVelocity = g;
        c.m_linearVelocity.SetV(h);
        c.m_angularVelocity = l
    };
    H.prototype.SolvePositionConstraints = function() {
        var b = this.m_bodyA,
            f = this.m_bodyB,
            g = b.m_sweep.c,
            h = b.m_sweep.a,
            l = f.m_sweep.c,
            m = f.m_sweep.a,
            p, q, y, A, B, H = 0,
            E;
        y = !1;
        var K = 0,
            M = c.FromAngle(h);
        A = c.FromAngle(m);
        p = M;
        E = this.m_localAnchor1.x - this.m_localCenterA.x;
        var aa = this.m_localAnchor1.y - this.m_localCenterA.y;
        q = p.col1.x * E + p.col2.x * aa;
        aa = p.col1.y * E + p.col2.y * aa;
        E = q;
        p = A;
        A = this.m_localAnchor2.x - this.m_localCenterB.x;
        B = this.m_localAnchor2.y - this.m_localCenterB.y;
        q = p.col1.x * A + p.col2.x * B;
        B = p.col1.y * A + p.col2.y * B;
        A = q;
        p = l.x + A - g.x - E;
        q = l.y + B - g.y - aa;
        if (this.m_enableLimit) {
            this.m_axis = d.MulMV(M, this.m_localXAxis1);
            this.m_a1 = (p + E) * this.m_axis.y - (q + aa) * this.m_axis.x;
            this.m_a2 = A * this.m_axis.y - B * this.m_axis.x;
            var Yb = this.m_axis.x * p + this.m_axis.y * q;
            d.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * a.b2_linearSlop ? (K = d.Clamp(Yb, -a.b2_maxLinearCorrection, a.b2_maxLinearCorrection), H = d.Abs(Yb), y = !0) : Yb <= this.m_lowerTranslation ?
                (K = d.Clamp(Yb - this.m_lowerTranslation + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), H = this.m_lowerTranslation - Yb, y = !0) : Yb >= this.m_upperTranslation && (K = d.Clamp(Yb - this.m_upperTranslation + a.b2_linearSlop, 0, a.b2_maxLinearCorrection), H = Yb - this.m_upperTranslation, y = !0)
        }
        this.m_perp = d.MulMV(M, this.m_localYAxis1);
        this.m_s1 = (p + E) * this.m_perp.y - (q + aa) * this.m_perp.x;
        this.m_s2 = A * this.m_perp.y - B * this.m_perp.x;
        M = new e;
        aa = this.m_perp.x * p + this.m_perp.y * q;
        H = d.Max(H, d.Abs(aa));
        E = 0;
        y ? (y = this.m_invMassA, A = this.m_invMassB,
            B = this.m_invIA, p = this.m_invIB, this.m_K.col1.x = y + A + B * this.m_s1 * this.m_s1 + p * this.m_s2 * this.m_s2, this.m_K.col1.y = B * this.m_s1 * this.m_a1 + p * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = y + A + B * this.m_a1 * this.m_a1 + p * this.m_a2 * this.m_a2, this.m_K.Solve(M, -aa, -K)) : (y = this.m_invMassA, A = this.m_invMassB, B = this.m_invIA, p = this.m_invIB, K = y + A + B * this.m_s1 * this.m_s1 + p * this.m_s2 * this.m_s2, M.x = 0 != K ? -aa / K : 0, M.y = 0);
        K = M.x * this.m_perp.x + M.y * this.m_axis.x;
        y = M.x * this.m_perp.y + M.y * this.m_axis.y;
        aa = M.x * this.m_s1 +
            M.y * this.m_a1;
        M = M.x * this.m_s2 + M.y * this.m_a2;
        g.x -= this.m_invMassA * K;
        g.y -= this.m_invMassA * y;
        h -= this.m_invIA * aa;
        l.x += this.m_invMassB * K;
        l.y += this.m_invMassB * y;
        m += this.m_invIB * M;
        b.m_sweep.a = h;
        f.m_sweep.a = m;
        b.SynchronizeTransform();
        f.SynchronizeTransform();
        return H <= a.b2_linearSlop && E <= a.b2_angularSlop
    };
    Box2D.inherit(E, Box2D.Dynamics.Joints.b2JointDef);
    E.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    E.b2LineJointDef = function() {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new e;
        this.localAnchorB = new e;
        this.localAxisA = new e
    };
    E.prototype.b2LineJointDef = function() {
        this.__super.b2JointDef.call(this);
        this.type = A.e_lineJoint;
        this.localAxisA.Set(1, 0);
        this.enableLimit = !1;
        this.upperTranslation = this.lowerTranslation = 0;
        this.enableMotor = !1;
        this.motorSpeed = this.maxMotorForce = 0
    };
    E.prototype.Initialize = function(a, b, c, d) {
        this.bodyA = a;
        this.bodyB = b;
        this.localAnchorA = this.bodyA.GetLocalPoint(c);
        this.localAnchorB = this.bodyB.GetLocalPoint(c);
        this.localAxisA = this.bodyA.GetLocalVector(d)
    };
    Box2D.inherit(M, Box2D.Dynamics.Joints.b2Joint);
    M.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    M.b2MouseJoint = function() {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.K = new c;
        this.K1 = new c;
        this.K2 = new c;
        this.m_localAnchor = new e;
        this.m_target = new e;
        this.m_impulse = new e;
        this.m_mass = new c;
        this.m_C = new e
    };
    M.prototype.GetAnchorA = function() {
        return this.m_target
    };
    M.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor)
    };
    M.prototype.GetReactionForce =
        function(a) {
            void 0 === a && (a = 0);
            return new e(a * this.m_impulse.x, a * this.m_impulse.y)
        };
    M.prototype.GetReactionTorque = function() {
        return 0
    };
    M.prototype.GetTarget = function() {
        return this.m_target
    };
    M.prototype.SetTarget = function(a) {
        0 == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0);
        this.m_target = a
    };
    M.prototype.GetMaxForce = function() {
        return this.m_maxForce
    };
    M.prototype.SetMaxForce = function(a) {
        void 0 === a && (a = 0);
        this.m_maxForce = a
    };
    M.prototype.GetFrequency = function() {
        return this.m_frequencyHz
    };
    M.prototype.SetFrequency =
        function(a) {
            void 0 === a && (a = 0);
            this.m_frequencyHz = a
        };
    M.prototype.GetDampingRatio = function() {
        return this.m_dampingRatio
    };
    M.prototype.SetDampingRatio = function(a) {
        void 0 === a && (a = 0);
        this.m_dampingRatio = a
    };
    M.prototype.b2MouseJoint = function(a) {
        this.__super.b2Joint.call(this, a);
        this.m_target.SetV(a.target);
        var b = this.m_target.x - this.m_bodyB.m_xf.position.x,
            c = this.m_target.y - this.m_bodyB.m_xf.position.y,
            d = this.m_bodyB.m_xf.R;
        this.m_localAnchor.x = b * d.col1.x + c * d.col1.y;
        this.m_localAnchor.y = b * d.col2.x + c * d.col2.y;
        this.m_maxForce = a.maxForce;
        this.m_impulse.SetZero();
        this.m_frequencyHz = a.frequencyHz;
        this.m_dampingRatio = a.dampingRatio;
        this.m_gamma = this.m_beta = 0
    };
    M.prototype.InitVelocityConstraints = function(a) {
        var b = this.m_bodyB,
            c = b.GetMass(),
            d = 2 * Math.PI * this.m_frequencyHz,
            e = c * d * d;
        this.m_gamma = a.dt * (2 * c * this.m_dampingRatio * d + a.dt * e);
        this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
        this.m_beta = a.dt * e * this.m_gamma;
        var e = b.m_xf.R,
            c = this.m_localAnchor.x - b.m_sweep.localCenter.x,
            d = this.m_localAnchor.y - b.m_sweep.localCenter.y,
            f = e.col1.x * c + e.col2.x * d,
            d = e.col1.y * c + e.col2.y * d,
            c = f,
            e = b.m_invMass,
            f = b.m_invI;
        this.K1.col1.x = e;
        this.K1.col2.x = 0;
        this.K1.col1.y = 0;
        this.K1.col2.y = e;
        this.K2.col1.x = f * d * d;
        this.K2.col2.x = -f * c * d;
        this.K2.col1.y = -f * c * d;
        this.K2.col2.y = f * c * c;
        this.K.SetM(this.K1);
        this.K.AddM(this.K2);
        this.K.col1.x += this.m_gamma;
        this.K.col2.y += this.m_gamma;
        this.K.GetInverse(this.m_mass);
        this.m_C.x = b.m_sweep.c.x + c - this.m_target.x;
        this.m_C.y = b.m_sweep.c.y + d - this.m_target.y;
        b.m_angularVelocity *= .98;
        this.m_impulse.x *= a.dtRatio;
        this.m_impulse.y *=
            a.dtRatio;
        b.m_linearVelocity.x += e * this.m_impulse.x;
        b.m_linearVelocity.y += e * this.m_impulse.y;
        b.m_angularVelocity += f * (c * this.m_impulse.y - d * this.m_impulse.x)
    };
    M.prototype.SolveVelocityConstraints = function(a) {
        var b = this.m_bodyB,
            c, d, e;
        c = b.m_xf.R;
        var f = this.m_localAnchor.x - b.m_sweep.localCenter.x,
            g = this.m_localAnchor.y - b.m_sweep.localCenter.y;
        d = c.col1.x * f + c.col2.x * g;
        g = c.col1.y * f + c.col2.y * g;
        f = d;
        d = b.m_linearVelocity.x + -b.m_angularVelocity * g;
        var h = b.m_linearVelocity.y + b.m_angularVelocity * f;
        c = this.m_mass;
        d =
            d + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
        e = h + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
        h = -(c.col1.x * d + c.col2.x * e);
        e = -(c.col1.y * d + c.col2.y * e);
        c = this.m_impulse.x;
        d = this.m_impulse.y;
        this.m_impulse.x += h;
        this.m_impulse.y += e;
        a = a.dt * this.m_maxForce;
        this.m_impulse.LengthSquared() > a * a && this.m_impulse.Multiply(a / this.m_impulse.Length());
        h = this.m_impulse.x - c;
        e = this.m_impulse.y - d;
        b.m_linearVelocity.x += b.m_invMass * h;
        b.m_linearVelocity.y += b.m_invMass * e;
        b.m_angularVelocity += b.m_invI * (f *
            e - g * h)
    };
    M.prototype.SolvePositionConstraints = function() {
        return !0
    };
    Box2D.inherit(Xb, Box2D.Dynamics.Joints.b2JointDef);
    Xb.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    Xb.b2MouseJointDef = function() {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.target = new e
    };
    Xb.prototype.b2MouseJointDef = function() {
        this.__super.b2JointDef.call(this);
        this.type = A.e_mouseJoint;
        this.maxForce = 0;
        this.frequencyHz = 5;
        this.dampingRatio = .7
    };
    Box2D.inherit(Zb, Box2D.Dynamics.Joints.b2Joint);
    Zb.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    Zb.b2PrismaticJoint = function() {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchor1 = new e;
        this.m_localAnchor2 = new e;
        this.m_localXAxis1 = new e;
        this.m_localYAxis1 = new e;
        this.m_axis = new e;
        this.m_perp = new e;
        this.m_K = new b;
        this.m_impulse = new f
    };
    Zb.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    Zb.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    Zb.prototype.GetReactionForce = function(a) {
        void 0 === a && (a = 0);
        return new e(a * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), a * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y))
    };
    Zb.prototype.GetReactionTorque = function(a) {
        void 0 === a && (a = 0);
        return a * this.m_impulse.y
    };
    Zb.prototype.GetJointTranslation = function() {
        var a = this.m_bodyA,
            b = this.m_bodyB,
            c = a.GetWorldPoint(this.m_localAnchor1),
            d = b.GetWorldPoint(this.m_localAnchor2),
            b = d.x -
            c.x,
            c = d.y - c.y,
            a = a.GetWorldVector(this.m_localXAxis1);
        return a.x * b + a.y * c
    };
    Zb.prototype.GetJointSpeed = function() {
        var a = this.m_bodyA,
            b = this.m_bodyB,
            c;
        c = a.m_xf.R;
        var d = this.m_localAnchor1.x - a.m_sweep.localCenter.x,
            e = this.m_localAnchor1.y - a.m_sweep.localCenter.y,
            f = c.col1.x * d + c.col2.x * e,
            e = c.col1.y * d + c.col2.y * e,
            d = f;
        c = b.m_xf.R;
        var g = this.m_localAnchor2.x - b.m_sweep.localCenter.x,
            h = this.m_localAnchor2.y - b.m_sweep.localCenter.y,
            f = c.col1.x * g + c.col2.x * h,
            h = c.col1.y * g + c.col2.y * h,
            g = f;
        c = b.m_sweep.c.x + g - (a.m_sweep.c.x +
            d);
        var f = b.m_sweep.c.y + h - (a.m_sweep.c.y + e),
            l = a.GetWorldVector(this.m_localXAxis1),
            m = a.m_linearVelocity,
            p = b.m_linearVelocity,
            a = a.m_angularVelocity,
            b = b.m_angularVelocity;
        return c * -a * l.y + f * a * l.x + (l.x * (p.x + -b * h - m.x - -a * e) + l.y * (p.y + b * g - m.y - a * d))
    };
    Zb.prototype.IsLimitEnabled = function() {
        return this.m_enableLimit
    };
    Zb.prototype.EnableLimit = function(a) {
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_enableLimit = a
    };
    Zb.prototype.GetLowerLimit = function() {
        return this.m_lowerTranslation
    };
    Zb.prototype.GetUpperLimit =
        function() {
            return this.m_upperTranslation
        };
    Zb.prototype.SetLimits = function(a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_lowerTranslation = a;
        this.m_upperTranslation = b
    };
    Zb.prototype.IsMotorEnabled = function() {
        return this.m_enableMotor
    };
    Zb.prototype.EnableMotor = function(a) {
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_enableMotor = a
    };
    Zb.prototype.SetMotorSpeed = function(a) {
        void 0 === a && (a = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_motorSpeed = a
    };
    Zb.prototype.GetMotorSpeed = function() {
        return this.m_motorSpeed
    };
    Zb.prototype.SetMaxMotorForce = function(a) {
        void 0 === a && (a = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_maxMotorForce = a
    };
    Zb.prototype.GetMotorForce = function() {
        return this.m_motorImpulse
    };
    Zb.prototype.b2PrismaticJoint = function(a) {
        this.__super.b2Joint.call(this, a);
        this.m_localAnchor1.SetV(a.localAnchorA);
        this.m_localAnchor2.SetV(a.localAnchorB);
        this.m_localXAxis1.SetV(a.localAxisA);
        this.m_localYAxis1.x = -this.m_localXAxis1.y;
        this.m_localYAxis1.y = this.m_localXAxis1.x;
        this.m_refAngle = a.referenceAngle;
        this.m_impulse.SetZero();
        this.m_motorImpulse = this.m_motorMass = 0;
        this.m_lowerTranslation = a.lowerTranslation;
        this.m_upperTranslation = a.upperTranslation;
        this.m_maxMotorForce = a.maxMotorForce;
        this.m_motorSpeed = a.motorSpeed;
        this.m_enableLimit = a.enableLimit;
        this.m_enableMotor = a.enableMotor;
        this.m_limitState = A.e_inactiveLimit;
        this.m_axis.SetZero();
        this.m_perp.SetZero()
    };
    Zb.prototype.InitVelocityConstraints = function(b) {
        var c =
            this.m_bodyA,
            e = this.m_bodyB,
            f, g;
        this.m_localCenterA.SetV(c.GetLocalCenter());
        this.m_localCenterB.SetV(e.GetLocalCenter());
        var h = c.GetTransform();
        e.GetTransform();
        f = c.m_xf.R;
        var l = this.m_localAnchor1.x - this.m_localCenterA.x,
            m = this.m_localAnchor1.y - this.m_localCenterA.y;
        g = f.col1.x * l + f.col2.x * m;
        m = f.col1.y * l + f.col2.y * m;
        l = g;
        f = e.m_xf.R;
        var p = this.m_localAnchor2.x - this.m_localCenterB.x,
            q = this.m_localAnchor2.y - this.m_localCenterB.y;
        g = f.col1.x * p + f.col2.x * q;
        q = f.col1.y * p + f.col2.y * q;
        p = g;
        f = e.m_sweep.c.x + p - c.m_sweep.c.x -
            l;
        g = e.m_sweep.c.y + q - c.m_sweep.c.y - m;
        this.m_invMassA = c.m_invMass;
        this.m_invMassB = e.m_invMass;
        this.m_invIA = c.m_invI;
        this.m_invIB = e.m_invI;
        this.m_axis.SetV(d.MulMV(h.R, this.m_localXAxis1));
        this.m_a1 = (f + l) * this.m_axis.y - (g + m) * this.m_axis.x;
        this.m_a2 = p * this.m_axis.y - q * this.m_axis.x;
        this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
        this.m_motorMass > Number.MIN_VALUE && (this.m_motorMass = 1 / this.m_motorMass);
        this.m_perp.SetV(d.MulMV(h.R, this.m_localYAxis1));
        this.m_s1 = (f + l) * this.m_perp.y - (g + m) * this.m_perp.x;
        this.m_s2 = p * this.m_perp.y - q * this.m_perp.x;
        h = this.m_invMassA;
        l = this.m_invMassB;
        m = this.m_invIA;
        p = this.m_invIB;
        this.m_K.col1.x = h + l + m * this.m_s1 * this.m_s1 + p * this.m_s2 * this.m_s2;
        this.m_K.col1.y = m * this.m_s1 + p * this.m_s2;
        this.m_K.col1.z = m * this.m_s1 * this.m_a1 + p * this.m_s2 * this.m_a2;
        this.m_K.col2.x = this.m_K.col1.y;
        this.m_K.col2.y = m + p;
        this.m_K.col2.z = m * this.m_a1 + p * this.m_a2;
        this.m_K.col3.x = this.m_K.col1.z;
        this.m_K.col3.y = this.m_K.col2.z;
        this.m_K.col3.z = h + l + m * this.m_a1 *
            this.m_a1 + p * this.m_a2 * this.m_a2;
        this.m_enableLimit ? (f = this.m_axis.x * f + this.m_axis.y * g, d.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * a.b2_linearSlop ? this.m_limitState = A.e_equalLimits : f <= this.m_lowerTranslation ? this.m_limitState != A.e_atLowerLimit && (this.m_limitState = A.e_atLowerLimit, this.m_impulse.z = 0) : f >= this.m_upperTranslation ? this.m_limitState != A.e_atUpperLimit && (this.m_limitState = A.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = A.e_inactiveLimit, this.m_impulse.z = 0)) : this.m_limitState =
            A.e_inactiveLimit;
        0 == this.m_enableMotor && (this.m_motorImpulse = 0);
        b.warmStarting ? (this.m_impulse.x *= b.dtRatio, this.m_impulse.y *= b.dtRatio, this.m_motorImpulse *= b.dtRatio, b = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x, f = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y, g = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1, h = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse +
            this.m_impulse.z) * this.m_a2, c.m_linearVelocity.x -= this.m_invMassA * b, c.m_linearVelocity.y -= this.m_invMassA * f, c.m_angularVelocity -= this.m_invIA * g, e.m_linearVelocity.x += this.m_invMassB * b, e.m_linearVelocity.y += this.m_invMassB * f, e.m_angularVelocity += this.m_invIB * h) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0)
    };
    Zb.prototype.SolveVelocityConstraints = function(a) {
        var b = this.m_bodyA,
            c = this.m_bodyB,
            g = b.m_linearVelocity,
            h = b.m_angularVelocity,
            l = c.m_linearVelocity,
            m = c.m_angularVelocity,
            p, q, y, B;
        this.m_enableMotor &&
            this.m_limitState != A.e_equalLimits && (B = this.m_motorMass * (this.m_motorSpeed - (this.m_axis.x * (l.x - g.x) + this.m_axis.y * (l.y - g.y) + this.m_a2 * m - this.m_a1 * h)), p = this.m_motorImpulse, a = a.dt * this.m_maxMotorForce, this.m_motorImpulse = d.Clamp(this.m_motorImpulse + B, -a, a), B = this.m_motorImpulse - p, p = B * this.m_axis.x, q = B * this.m_axis.y, y = B * this.m_a1, B *= this.m_a2, g.x -= this.m_invMassA * p, g.y -= this.m_invMassA * q, h -= this.m_invIA * y, l.x += this.m_invMassB * p, l.y += this.m_invMassB * q, m += this.m_invIB * B);
        y = this.m_perp.x * (l.x - g.x) + this.m_perp.y *
            (l.y - g.y) + this.m_s2 * m - this.m_s1 * h;
        q = m - h;
        this.m_enableLimit && this.m_limitState != A.e_inactiveLimit ? (a = this.m_axis.x * (l.x - g.x) + this.m_axis.y * (l.y - g.y) + this.m_a2 * m - this.m_a1 * h, p = this.m_impulse.Copy(), a = this.m_K.Solve33(new f, -y, -q, -a), this.m_impulse.Add(a), this.m_limitState == A.e_atLowerLimit ? this.m_impulse.z = d.Max(this.m_impulse.z, 0) : this.m_limitState == A.e_atUpperLimit && (this.m_impulse.z = d.Min(this.m_impulse.z, 0)), y = -y - (this.m_impulse.z - p.z) * this.m_K.col3.x, q = -q - (this.m_impulse.z - p.z) * this.m_K.col3.y,
            q = this.m_K.Solve22(new e, y, q), q.x += p.x, q.y += p.y, this.m_impulse.x = q.x, this.m_impulse.y = q.y, a.x = this.m_impulse.x - p.x, a.y = this.m_impulse.y - p.y, a.z = this.m_impulse.z - p.z, p = a.x * this.m_perp.x + a.z * this.m_axis.x, q = a.x * this.m_perp.y + a.z * this.m_axis.y, y = a.x * this.m_s1 + a.y + a.z * this.m_a1, B = a.x * this.m_s2 + a.y + a.z * this.m_a2) : (a = this.m_K.Solve22(new e, -y, -q), this.m_impulse.x += a.x, this.m_impulse.y += a.y, p = a.x * this.m_perp.x, q = a.x * this.m_perp.y, y = a.x * this.m_s1 + a.y, B = a.x * this.m_s2 + a.y);
        g.x -= this.m_invMassA * p;
        g.y -= this.m_invMassA *
            q;
        h -= this.m_invIA * y;
        l.x += this.m_invMassB * p;
        l.y += this.m_invMassB * q;
        m += this.m_invIB * B;
        b.m_linearVelocity.SetV(g);
        b.m_angularVelocity = h;
        c.m_linearVelocity.SetV(l);
        c.m_angularVelocity = m
    };
    Zb.prototype.SolvePositionConstraints = function() {
        var b = this.m_bodyA,
            g = this.m_bodyB,
            h = b.m_sweep.c,
            l = b.m_sweep.a,
            m = g.m_sweep.c,
            p = g.m_sweep.a,
            q, y, A, B, H = 0,
            E;
        A = !1;
        var K = 0,
            M = c.FromAngle(l),
            aa = c.FromAngle(p);
        q = M;
        E = this.m_localAnchor1.x - this.m_localCenterA.x;
        var Yb = this.m_localAnchor1.y - this.m_localCenterA.y;
        y = q.col1.x * E + q.col2.x *
            Yb;
        Yb = q.col1.y * E + q.col2.y * Yb;
        E = y;
        q = aa;
        aa = this.m_localAnchor2.x - this.m_localCenterB.x;
        B = this.m_localAnchor2.y - this.m_localCenterB.y;
        y = q.col1.x * aa + q.col2.x * B;
        B = q.col1.y * aa + q.col2.y * B;
        aa = y;
        q = m.x + aa - h.x - E;
        y = m.y + B - h.y - Yb;
        if (this.m_enableLimit) {
            this.m_axis = d.MulMV(M, this.m_localXAxis1);
            this.m_a1 = (q + E) * this.m_axis.y - (y + Yb) * this.m_axis.x;
            this.m_a2 = aa * this.m_axis.y - B * this.m_axis.x;
            var Xb = this.m_axis.x * q + this.m_axis.y * y;
            d.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * a.b2_linearSlop ? (K = d.Clamp(Xb, -a.b2_maxLinearCorrection, a.b2_maxLinearCorrection), H = d.Abs(Xb), A = !0) : Xb <= this.m_lowerTranslation ? (K = d.Clamp(Xb - this.m_lowerTranslation + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), H = this.m_lowerTranslation - Xb, A = !0) : Xb >= this.m_upperTranslation && (K = d.Clamp(Xb - this.m_upperTranslation + a.b2_linearSlop, 0, a.b2_maxLinearCorrection), H = Xb - this.m_upperTranslation, A = !0)
        }
        this.m_perp = d.MulMV(M, this.m_localYAxis1);
        this.m_s1 = (q + E) * this.m_perp.y - (y + Yb) * this.m_perp.x;
        this.m_s2 = aa * this.m_perp.y - B * this.m_perp.x;
        M = new f;
        Yb = this.m_perp.x * q + this.m_perp.y * y;
        aa = p - l - this.m_refAngle;
        H = d.Max(H, d.Abs(Yb));
        E = d.Abs(aa);
        A ? (A = this.m_invMassA, B = this.m_invMassB, q = this.m_invIA, y = this.m_invIB, this.m_K.col1.x = A + B + q * this.m_s1 * this.m_s1 + y * this.m_s2 * this.m_s2, this.m_K.col1.y = q * this.m_s1 + y * this.m_s2, this.m_K.col1.z = q * this.m_s1 * this.m_a1 + y * this.m_s2 * this.m_a2, this.m_K.col2.x = this.m_K.col1.y, this.m_K.col2.y = q + y, this.m_K.col2.z = q * this.m_a1 + y * this.m_a2, this.m_K.col3.x = this.m_K.col1.z, this.m_K.col3.y = this.m_K.col2.z, this.m_K.col3.z = A + B + q *
            this.m_a1 * this.m_a1 + y * this.m_a2 * this.m_a2, this.m_K.Solve33(M, -Yb, -aa, -K)) : (A = this.m_invMassA, B = this.m_invMassB, q = this.m_invIA, y = this.m_invIB, K = q * this.m_s1 + y * this.m_s2, Xb = q + y, this.m_K.col1.Set(A + B + q * this.m_s1 * this.m_s1 + y * this.m_s2 * this.m_s2, K, 0), this.m_K.col2.Set(K, Xb, 0), K = this.m_K.Solve22(new e, -Yb, -aa), M.x = K.x, M.y = K.y, M.z = 0);
        K = M.x * this.m_perp.x + M.z * this.m_axis.x;
        A = M.x * this.m_perp.y + M.z * this.m_axis.y;
        Yb = M.x * this.m_s1 + M.y + M.z * this.m_a1;
        M = M.x * this.m_s2 + M.y + M.z * this.m_a2;
        h.x -= this.m_invMassA * K;
        h.y -=
            this.m_invMassA * A;
        l -= this.m_invIA * Yb;
        m.x += this.m_invMassB * K;
        m.y += this.m_invMassB * A;
        p += this.m_invIB * M;
        b.m_sweep.a = l;
        g.m_sweep.a = p;
        b.SynchronizeTransform();
        g.SynchronizeTransform();
        return H <= a.b2_linearSlop && E <= a.b2_angularSlop
    };
    Box2D.inherit(aa, Box2D.Dynamics.Joints.b2JointDef);
    aa.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    aa.b2PrismaticJointDef = function() {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new e;
        this.localAnchorB = new e;
        this.localAxisA =
            new e
    };
    aa.prototype.b2PrismaticJointDef = function() {
        this.__super.b2JointDef.call(this);
        this.type = A.e_prismaticJoint;
        this.localAxisA.Set(1, 0);
        this.referenceAngle = 0;
        this.enableLimit = !1;
        this.upperTranslation = this.lowerTranslation = 0;
        this.enableMotor = !1;
        this.motorSpeed = this.maxMotorForce = 0
    };
    aa.prototype.Initialize = function(a, b, c, d) {
        this.bodyA = a;
        this.bodyB = b;
        this.localAnchorA = this.bodyA.GetLocalPoint(c);
        this.localAnchorB = this.bodyB.GetLocalPoint(c);
        this.localAxisA = this.bodyA.GetLocalVector(d);
        this.referenceAngle =
            this.bodyB.GetAngle() - this.bodyA.GetAngle()
    };
    Box2D.inherit(Yb, Box2D.Dynamics.Joints.b2Joint);
    Yb.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    Yb.b2PulleyJoint = function() {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_groundAnchor1 = new e;
        this.m_groundAnchor2 = new e;
        this.m_localAnchor1 = new e;
        this.m_localAnchor2 = new e;
        this.m_u1 = new e;
        this.m_u2 = new e
    };
    Yb.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    Yb.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    Yb.prototype.GetReactionForce = function(a) {
        void 0 === a && (a = 0);
        return new e(a * this.m_impulse * this.m_u2.x, a * this.m_impulse * this.m_u2.y)
    };
    Yb.prototype.GetReactionTorque = function() {
        return 0
    };
    Yb.prototype.GetGroundAnchorA = function() {
        var a = this.m_ground.m_xf.position.Copy();
        a.Add(this.m_groundAnchor1);
        return a
    };
    Yb.prototype.GetGroundAnchorB = function() {
        var a = this.m_ground.m_xf.position.Copy();
        a.Add(this.m_groundAnchor2);
        return a
    };
    Yb.prototype.GetLength1 = function() {
        var a = this.m_bodyA.GetWorldPoint(this.m_localAnchor1),
            b = a.x - (this.m_ground.m_xf.position.x + this.m_groundAnchor1.x),
            a = a.y - (this.m_ground.m_xf.position.y + this.m_groundAnchor1.y);
        return Math.sqrt(b * b + a * a)
    };
    Yb.prototype.GetLength2 = function() {
        var a = this.m_bodyB.GetWorldPoint(this.m_localAnchor2),
            b = a.x - (this.m_ground.m_xf.position.x + this.m_groundAnchor2.x),
            a = a.y - (this.m_ground.m_xf.position.y + this.m_groundAnchor2.y);
        return Math.sqrt(b * b + a * a)
    };
    Yb.prototype.GetRatio = function() {
        return this.m_ratio
    };
    Yb.prototype.b2PulleyJoint = function(a) {
        this.__super.b2Joint.call(this,
            a);
        this.m_ground = this.m_bodyA.m_world.m_groundBody;
        this.m_groundAnchor1.x = a.groundAnchorA.x - this.m_ground.m_xf.position.x;
        this.m_groundAnchor1.y = a.groundAnchorA.y - this.m_ground.m_xf.position.y;
        this.m_groundAnchor2.x = a.groundAnchorB.x - this.m_ground.m_xf.position.x;
        this.m_groundAnchor2.y = a.groundAnchorB.y - this.m_ground.m_xf.position.y;
        this.m_localAnchor1.SetV(a.localAnchorA);
        this.m_localAnchor2.SetV(a.localAnchorB);
        this.m_ratio = a.ratio;
        this.m_constant = a.lengthA + this.m_ratio * a.lengthB;
        this.m_maxLength1 =
            d.Min(a.maxLengthA, this.m_constant - this.m_ratio * Yb.b2_minPulleyLength);
        this.m_maxLength2 = d.Min(a.maxLengthB, (this.m_constant - Yb.b2_minPulleyLength) / this.m_ratio);
        this.m_limitImpulse2 = this.m_limitImpulse1 = this.m_impulse = 0
    };
    Yb.prototype.InitVelocityConstraints = function(b) {
        var c = this.m_bodyA,
            d = this.m_bodyB,
            e;
        e = c.m_xf.R;
        var f = this.m_localAnchor1.x - c.m_sweep.localCenter.x,
            g = this.m_localAnchor1.y - c.m_sweep.localCenter.y,
            h = e.col1.x * f + e.col2.x * g,
            g = e.col1.y * f + e.col2.y * g,
            f = h;
        e = d.m_xf.R;
        var l = this.m_localAnchor2.x -
            d.m_sweep.localCenter.x,
            m = this.m_localAnchor2.y - d.m_sweep.localCenter.y,
            h = e.col1.x * l + e.col2.x * m,
            m = e.col1.y * l + e.col2.y * m,
            l = h;
        e = d.m_sweep.c.x + l;
        var h = d.m_sweep.c.y + m,
            p = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
            q = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
        this.m_u1.Set(c.m_sweep.c.x + f - (this.m_ground.m_xf.position.x + this.m_groundAnchor1.x), c.m_sweep.c.y + g - (this.m_ground.m_xf.position.y + this.m_groundAnchor1.y));
        this.m_u2.Set(e - p, h - q);
        e = this.m_u1.Length();
        h = this.m_u2.Length();
        e > a.b2_linearSlop ?
            this.m_u1.Multiply(1 / e) : this.m_u1.SetZero();
        h > a.b2_linearSlop ? this.m_u2.Multiply(1 / h) : this.m_u2.SetZero();
        0 < this.m_constant - e - this.m_ratio * h ? (this.m_state = A.e_inactiveLimit, this.m_impulse = 0) : this.m_state = A.e_atUpperLimit;
        e < this.m_maxLength1 ? (this.m_limitState1 = A.e_inactiveLimit, this.m_limitImpulse1 = 0) : this.m_limitState1 = A.e_atUpperLimit;
        h < this.m_maxLength2 ? (this.m_limitState2 = A.e_inactiveLimit, this.m_limitImpulse2 = 0) : this.m_limitState2 = A.e_atUpperLimit;
        e = f * this.m_u1.y - g * this.m_u1.x;
        h = l * this.m_u2.y -
            m * this.m_u2.x;
        this.m_limitMass1 = c.m_invMass + c.m_invI * e * e;
        this.m_limitMass2 = d.m_invMass + d.m_invI * h * h;
        this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
        this.m_limitMass1 = 1 / this.m_limitMass1;
        this.m_limitMass2 = 1 / this.m_limitMass2;
        this.m_pulleyMass = 1 / this.m_pulleyMass;
        b.warmStarting ? (this.m_impulse *= b.dtRatio, this.m_limitImpulse1 *= b.dtRatio, this.m_limitImpulse2 *= b.dtRatio, b = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x, e = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y,
            h = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x, p = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y, c.m_linearVelocity.x += c.m_invMass * b, c.m_linearVelocity.y += c.m_invMass * e, c.m_angularVelocity += c.m_invI * (f * e - g * b), d.m_linearVelocity.x += d.m_invMass * h, d.m_linearVelocity.y += d.m_invMass * p, d.m_angularVelocity += d.m_invI * (l * p - m * h)) : this.m_limitImpulse2 = this.m_limitImpulse1 = this.m_impulse = 0
    };
    Yb.prototype.SolveVelocityConstraints = function() {
        var a = this.m_bodyA,
            b = this.m_bodyB,
            c;
        c = a.m_xf.R;
        var e = this.m_localAnchor1.x - a.m_sweep.localCenter.x,
            f = this.m_localAnchor1.y - a.m_sweep.localCenter.y,
            g = c.col1.x * e + c.col2.x * f,
            f = c.col1.y * e + c.col2.y * f,
            e = g;
        c = b.m_xf.R;
        var h = this.m_localAnchor2.x - b.m_sweep.localCenter.x,
            l = this.m_localAnchor2.y - b.m_sweep.localCenter.y,
            g = c.col1.x * h + c.col2.x * l,
            l = c.col1.y * h + c.col2.y * l,
            h = g,
            m, p;
        this.m_state == A.e_atUpperLimit && (c = a.m_linearVelocity.x + -a.m_angularVelocity * f, g = a.m_linearVelocity.y + a.m_angularVelocity * e, m = b.m_linearVelocity.x + -b.m_angularVelocity * l, p =
            b.m_linearVelocity.y + b.m_angularVelocity * h, c = -(this.m_u1.x * c + this.m_u1.y * g) - this.m_ratio * (this.m_u2.x * m + this.m_u2.y * p), p = this.m_pulleyMass * -c, c = this.m_impulse, this.m_impulse = d.Max(0, this.m_impulse + p), p = this.m_impulse - c, c = -p * this.m_u1.x, g = -p * this.m_u1.y, m = -this.m_ratio * p * this.m_u2.x, p = -this.m_ratio * p * this.m_u2.y, a.m_linearVelocity.x += a.m_invMass * c, a.m_linearVelocity.y += a.m_invMass * g, a.m_angularVelocity += a.m_invI * (e * g - f * c), b.m_linearVelocity.x += b.m_invMass * m, b.m_linearVelocity.y += b.m_invMass * p, b.m_angularVelocity +=
            b.m_invI * (h * p - l * m));
        this.m_limitState1 == A.e_atUpperLimit && (c = a.m_linearVelocity.x + -a.m_angularVelocity * f, g = a.m_linearVelocity.y + a.m_angularVelocity * e, c = -(this.m_u1.x * c + this.m_u1.y * g), p = -this.m_limitMass1 * c, c = this.m_limitImpulse1, this.m_limitImpulse1 = d.Max(0, this.m_limitImpulse1 + p), p = this.m_limitImpulse1 - c, c = -p * this.m_u1.x, g = -p * this.m_u1.y, a.m_linearVelocity.x += a.m_invMass * c, a.m_linearVelocity.y += a.m_invMass * g, a.m_angularVelocity += a.m_invI * (e * g - f * c));
        this.m_limitState2 == A.e_atUpperLimit && (m = b.m_linearVelocity.x +
            -b.m_angularVelocity * l, p = b.m_linearVelocity.y + b.m_angularVelocity * h, c = -(this.m_u2.x * m + this.m_u2.y * p), p = -this.m_limitMass2 * c, c = this.m_limitImpulse2, this.m_limitImpulse2 = d.Max(0, this.m_limitImpulse2 + p), p = this.m_limitImpulse2 - c, m = -p * this.m_u2.x, p = -p * this.m_u2.y, b.m_linearVelocity.x += b.m_invMass * m, b.m_linearVelocity.y += b.m_invMass * p, b.m_angularVelocity += b.m_invI * (h * p - l * m))
    };
    Yb.prototype.SolvePositionConstraints = function() {
        var b = this.m_bodyA,
            c = this.m_bodyB,
            e, f = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x,
            g = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y,
            h = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x,
            l = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y,
            m, p, q, y, B, H, E, K = 0;
        this.m_state == A.e_atUpperLimit && (e = b.m_xf.R, m = this.m_localAnchor1.x - b.m_sweep.localCenter.x, p = this.m_localAnchor1.y - b.m_sweep.localCenter.y, B = e.col1.x * m + e.col2.x * p, p = e.col1.y * m + e.col2.y * p, m = B, e = c.m_xf.R, q = this.m_localAnchor2.x - c.m_sweep.localCenter.x, y = this.m_localAnchor2.y - c.m_sweep.localCenter.y, B = e.col1.x * q + e.col2.x *
            y, y = e.col1.y * q + e.col2.y * y, q = B, e = b.m_sweep.c.x + m, B = b.m_sweep.c.y + p, H = c.m_sweep.c.x + q, E = c.m_sweep.c.y + y, this.m_u1.Set(e - f, B - g), this.m_u2.Set(H - h, E - l), e = this.m_u1.Length(), B = this.m_u2.Length(), e > a.b2_linearSlop ? this.m_u1.Multiply(1 / e) : this.m_u1.SetZero(), B > a.b2_linearSlop ? this.m_u2.Multiply(1 / B) : this.m_u2.SetZero(), e = this.m_constant - e - this.m_ratio * B, K = d.Max(K, -e), e = d.Clamp(e + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), E = -this.m_pulleyMass * e, e = -E * this.m_u1.x, B = -E * this.m_u1.y, H = -this.m_ratio * E * this.m_u2.x,
            E = -this.m_ratio * E * this.m_u2.y, b.m_sweep.c.x += b.m_invMass * e, b.m_sweep.c.y += b.m_invMass * B, b.m_sweep.a += b.m_invI * (m * B - p * e), c.m_sweep.c.x += c.m_invMass * H, c.m_sweep.c.y += c.m_invMass * E, c.m_sweep.a += c.m_invI * (q * E - y * H), b.SynchronizeTransform(), c.SynchronizeTransform());
        this.m_limitState1 == A.e_atUpperLimit && (e = b.m_xf.R, m = this.m_localAnchor1.x - b.m_sweep.localCenter.x, p = this.m_localAnchor1.y - b.m_sweep.localCenter.y, B = e.col1.x * m + e.col2.x * p, p = e.col1.y * m + e.col2.y * p, m = B, e = b.m_sweep.c.x + m, B = b.m_sweep.c.y + p, this.m_u1.Set(e -
            f, B - g), e = this.m_u1.Length(), e > a.b2_linearSlop ? (this.m_u1.x *= 1 / e, this.m_u1.y *= 1 / e) : this.m_u1.SetZero(), e = this.m_maxLength1 - e, K = d.Max(K, -e), e = d.Clamp(e + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), E = -this.m_limitMass1 * e, e = -E * this.m_u1.x, B = -E * this.m_u1.y, b.m_sweep.c.x += b.m_invMass * e, b.m_sweep.c.y += b.m_invMass * B, b.m_sweep.a += b.m_invI * (m * B - p * e), b.SynchronizeTransform());
        this.m_limitState2 == A.e_atUpperLimit && (e = c.m_xf.R, q = this.m_localAnchor2.x - c.m_sweep.localCenter.x, y = this.m_localAnchor2.y - c.m_sweep.localCenter.y,
            B = e.col1.x * q + e.col2.x * y, y = e.col1.y * q + e.col2.y * y, q = B, H = c.m_sweep.c.x + q, E = c.m_sweep.c.y + y, this.m_u2.Set(H - h, E - l), B = this.m_u2.Length(), B > a.b2_linearSlop ? (this.m_u2.x *= 1 / B, this.m_u2.y *= 1 / B) : this.m_u2.SetZero(), e = this.m_maxLength2 - B, K = d.Max(K, -e), e = d.Clamp(e + a.b2_linearSlop, -a.b2_maxLinearCorrection, 0), E = -this.m_limitMass2 * e, H = -E * this.m_u2.x, E = -E * this.m_u2.y, c.m_sweep.c.x += c.m_invMass * H, c.m_sweep.c.y += c.m_invMass * E, c.m_sweep.a += c.m_invI * (q * E - y * H), c.SynchronizeTransform());
        return K < a.b2_linearSlop
    };
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength =
            2
    });
    Box2D.inherit($b, Box2D.Dynamics.Joints.b2JointDef);
    $b.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    $b.b2PulleyJointDef = function() {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.groundAnchorA = new e;
        this.groundAnchorB = new e;
        this.localAnchorA = new e;
        this.localAnchorB = new e
    };
    $b.prototype.b2PulleyJointDef = function() {
        this.__super.b2JointDef.call(this);
        this.type = A.e_pulleyJoint;
        this.groundAnchorA.Set(-1, 1);
        this.groundAnchorB.Set(1, 1);
        this.localAnchorA.Set(-1, 0);
        this.localAnchorB.Set(1, 0);
        this.maxLengthB = this.lengthB = this.maxLengthA = this.lengthA = 0;
        this.ratio = 1;
        this.collideConnected = !0
    };
    $b.prototype.Initialize = function(a, b, c, d, e, f, g) {
        void 0 === g && (g = 0);
        this.bodyA = a;
        this.bodyB = b;
        this.groundAnchorA.SetV(c);
        this.groundAnchorB.SetV(d);
        this.localAnchorA = this.bodyA.GetLocalPoint(e);
        this.localAnchorB = this.bodyB.GetLocalPoint(f);
        a = e.x - c.x;
        c = e.y - c.y;
        this.lengthA = Math.sqrt(a * a + c * c);
        c = f.x - d.x;
        d = f.y - d.y;
        this.lengthB = Math.sqrt(c * c + d * d);
        this.ratio = g;
        g = this.lengthA + this.ratio *
            this.lengthB;
        this.maxLengthA = g - this.ratio * Yb.b2_minPulleyLength;
        this.maxLengthB = (g - Yb.b2_minPulleyLength) / this.ratio
    };
    Box2D.inherit(ac, Box2D.Dynamics.Joints.b2Joint);
    ac.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    ac.b2RevoluteJoint = function() {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.K = new c;
        this.K1 = new c;
        this.K2 = new c;
        this.K3 = new c;
        this.impulse3 = new f;
        this.impulse2 = new e;
        this.reduced = new e;
        this.m_localAnchor1 = new e;
        this.m_localAnchor2 = new e;
        this.m_impulse = new f;
        this.m_mass = new b
    };
    ac.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchor1)
    };
    ac.prototype.GetAnchorB = function() {
        return this.m_bodyB.GetWorldPoint(this.m_localAnchor2)
    };
    ac.prototype.GetReactionForce = function(a) {
        void 0 === a && (a = 0);
        return new e(a * this.m_impulse.x, a * this.m_impulse.y)
    };
    ac.prototype.GetReactionTorque = function(a) {
        void 0 === a && (a = 0);
        return a * this.m_impulse.z
    };
    ac.prototype.GetJointAngle = function() {
        return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle
    };
    ac.prototype.GetJointSpeed = function() {
        return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity
    };
    ac.prototype.IsLimitEnabled = function() {
        return this.m_enableLimit
    };
    ac.prototype.EnableLimit = function(a) {
        this.m_enableLimit = a
    };
    ac.prototype.GetLowerLimit = function() {
        return this.m_lowerAngle
    };
    ac.prototype.GetUpperLimit = function() {
        return this.m_upperAngle
    };
    ac.prototype.SetLimits = function(a, b) {
        void 0 === a && (a = 0);
        void 0 === b && (b = 0);
        this.m_lowerAngle = a;
        this.m_upperAngle = b
    };
    ac.prototype.IsMotorEnabled =
        function() {
            this.m_bodyA.SetAwake(!0);
            this.m_bodyB.SetAwake(!0);
            return this.m_enableMotor
        };
    ac.prototype.EnableMotor = function(a) {
        this.m_enableMotor = a
    };
    ac.prototype.SetMotorSpeed = function(a) {
        void 0 === a && (a = 0);
        this.m_bodyA.SetAwake(!0);
        this.m_bodyB.SetAwake(!0);
        this.m_motorSpeed = a
    };
    ac.prototype.GetMotorSpeed = function() {
        return this.m_motorSpeed
    };
    ac.prototype.SetMaxMotorTorque = function(a) {
        void 0 === a && (a = 0);
        this.m_maxMotorTorque = a
    };
    ac.prototype.GetMotorTorque = function() {
        return this.m_maxMotorTorque
    };
    ac.prototype.b2RevoluteJoint =
        function(a) {
            this.__super.b2Joint.call(this, a);
            this.m_localAnchor1.SetV(a.localAnchorA);
            this.m_localAnchor2.SetV(a.localAnchorB);
            this.m_referenceAngle = a.referenceAngle;
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0;
            this.m_lowerAngle = a.lowerAngle;
            this.m_upperAngle = a.upperAngle;
            this.m_maxMotorTorque = a.maxMotorTorque;
            this.m_motorSpeed = a.motorSpeed;
            this.m_enableLimit = a.enableLimit;
            this.m_enableMotor = a.enableMotor;
            this.m_limitState = A.e_inactiveLimit
        };
    ac.prototype.InitVelocityConstraints = function(b) {
        var c =
            this.m_bodyA,
            e = this.m_bodyB,
            f, g;
        f = c.m_xf.R;
        var h = this.m_localAnchor1.x - c.m_sweep.localCenter.x,
            l = this.m_localAnchor1.y - c.m_sweep.localCenter.y;
        g = f.col1.x * h + f.col2.x * l;
        l = f.col1.y * h + f.col2.y * l;
        h = g;
        f = e.m_xf.R;
        var m = this.m_localAnchor2.x - e.m_sweep.localCenter.x,
            p = this.m_localAnchor2.y - e.m_sweep.localCenter.y;
        g = f.col1.x * m + f.col2.x * p;
        p = f.col1.y * m + f.col2.y * p;
        m = g;
        f = c.m_invMass;
        g = e.m_invMass;
        var q = c.m_invI,
            y = e.m_invI;
        this.m_mass.col1.x = f + g + l * l * q + p * p * y;
        this.m_mass.col2.x = -l * h * q - p * m * y;
        this.m_mass.col3.x = -l *
            q - p * y;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = f + g + h * h * q + m * m * y;
        this.m_mass.col3.y = h * q + m * y;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = q + y;
        this.m_motorMass = 1 / (q + y);
        0 == this.m_enableMotor && (this.m_motorImpulse = 0);
        if (this.m_enableLimit) {
            var B = e.m_sweep.a - c.m_sweep.a - this.m_referenceAngle;
            d.Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * a.b2_angularSlop ? this.m_limitState = A.e_equalLimits : B <= this.m_lowerAngle ? (this.m_limitState != A.e_atLowerLimit &&
                (this.m_impulse.z = 0), this.m_limitState = A.e_atLowerLimit) : B >= this.m_upperAngle ? (this.m_limitState != A.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = A.e_atUpperLimit) : (this.m_limitState = A.e_inactiveLimit, this.m_impulse.z = 0)
        } else this.m_limitState = A.e_inactiveLimit;
        b.warmStarting ? (this.m_impulse.x *= b.dtRatio, this.m_impulse.y *= b.dtRatio, this.m_motorImpulse *= b.dtRatio, b = this.m_impulse.x, B = this.m_impulse.y, c.m_linearVelocity.x -= f * b, c.m_linearVelocity.y -= f * B, c.m_angularVelocity -= q * (h * B - l * b + this.m_motorImpulse +
            this.m_impulse.z), e.m_linearVelocity.x += g * b, e.m_linearVelocity.y += g * B, e.m_angularVelocity += y * (m * B - p * b + this.m_motorImpulse + this.m_impulse.z)) : (this.m_impulse.SetZero(), this.m_motorImpulse = 0)
    };
    ac.prototype.SolveVelocityConstraints = function(a) {
        var b = this.m_bodyA,
            c = this.m_bodyB,
            e, f, g, h, l, m = b.m_linearVelocity,
            p = b.m_angularVelocity,
            q = c.m_linearVelocity,
            y = c.m_angularVelocity,
            B = b.m_invMass,
            H = c.m_invMass,
            E = b.m_invI,
            K = c.m_invI;
        this.m_enableMotor && this.m_limitState != A.e_equalLimits && (f = this.m_motorMass * -(y -
            p - this.m_motorSpeed), g = this.m_motorImpulse, h = a.dt * this.m_maxMotorTorque, this.m_motorImpulse = d.Clamp(this.m_motorImpulse + f, -h, h), f = this.m_motorImpulse - g, p -= E * f, y += K * f);
        if (this.m_enableLimit && this.m_limitState != A.e_inactiveLimit) {
            a = b.m_xf.R;
            f = this.m_localAnchor1.x - b.m_sweep.localCenter.x;
            g = this.m_localAnchor1.y - b.m_sweep.localCenter.y;
            e = a.col1.x * f + a.col2.x * g;
            g = a.col1.y * f + a.col2.y * g;
            f = e;
            a = c.m_xf.R;
            h = this.m_localAnchor2.x - c.m_sweep.localCenter.x;
            l = this.m_localAnchor2.y - c.m_sweep.localCenter.y;
            e = a.col1.x *
                h + a.col2.x * l;
            l = a.col1.y * h + a.col2.y * l;
            h = e;
            a = q.x + -y * l - m.x - -p * g;
            var M = q.y + y * h - m.y - p * f;
            this.m_mass.Solve33(this.impulse3, -a, -M, -(y - p));
            this.m_limitState == A.e_equalLimits ? this.m_impulse.Add(this.impulse3) : this.m_limitState == A.e_atLowerLimit ? (e = this.m_impulse.z + this.impulse3.z, 0 > e && (this.m_mass.Solve22(this.reduced, -a, -M), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0)) :
                this.m_limitState == A.e_atUpperLimit && (e = this.m_impulse.z + this.impulse3.z, 0 < e && (this.m_mass.Solve22(this.reduced, -a, -M), this.impulse3.x = this.reduced.x, this.impulse3.y = this.reduced.y, this.impulse3.z = -this.m_impulse.z, this.m_impulse.x += this.reduced.x, this.m_impulse.y += this.reduced.y, this.m_impulse.z = 0));
            m.x -= B * this.impulse3.x;
            m.y -= B * this.impulse3.y;
            p -= E * (f * this.impulse3.y - g * this.impulse3.x + this.impulse3.z);
            q.x += H * this.impulse3.x;
            q.y += H * this.impulse3.y;
            y += K * (h * this.impulse3.y - l * this.impulse3.x + this.impulse3.z)
        } else a =
            b.m_xf.R, f = this.m_localAnchor1.x - b.m_sweep.localCenter.x, g = this.m_localAnchor1.y - b.m_sweep.localCenter.y, e = a.col1.x * f + a.col2.x * g, g = a.col1.y * f + a.col2.y * g, f = e, a = c.m_xf.R, h = this.m_localAnchor2.x - c.m_sweep.localCenter.x, l = this.m_localAnchor2.y - c.m_sweep.localCenter.y, e = a.col1.x * h + a.col2.x * l, l = a.col1.y * h + a.col2.y * l, h = e, this.m_mass.Solve22(this.impulse2, -(q.x + -y * l - m.x - -p * g), -(q.y + y * h - m.y - p * f)), this.m_impulse.x += this.impulse2.x, this.m_impulse.y += this.impulse2.y, m.x -= B * this.impulse2.x, m.y -= B * this.impulse2.y,
            p -= E * (f * this.impulse2.y - g * this.impulse2.x), q.x += H * this.impulse2.x, q.y += H * this.impulse2.y, y += K * (h * this.impulse2.y - l * this.impulse2.x);
        b.m_linearVelocity.SetV(m);
        b.m_angularVelocity = p;
        c.m_linearVelocity.SetV(q);
        c.m_angularVelocity = y
    };
    ac.prototype.SolvePositionConstraints = function() {
        var b, c, e = this.m_bodyA,
            f = this.m_bodyB,
            g = 0,
            h, l, m;
        if (this.m_enableLimit && this.m_limitState != A.e_inactiveLimit) {
            b = f.m_sweep.a - e.m_sweep.a - this.m_referenceAngle;
            var p = 0;
            this.m_limitState == A.e_equalLimits ? (b = d.Clamp(b - this.m_lowerAngle, -a.b2_maxAngularCorrection, a.b2_maxAngularCorrection), p = -this.m_motorMass * b, g = d.Abs(b)) : this.m_limitState == A.e_atLowerLimit ? (b -= this.m_lowerAngle, g = -b, b = d.Clamp(b + a.b2_angularSlop, -a.b2_maxAngularCorrection, 0), p = -this.m_motorMass * b) : this.m_limitState == A.e_atUpperLimit && (g = b -= this.m_upperAngle, b = d.Clamp(b - a.b2_angularSlop, 0, a.b2_maxAngularCorrection), p = -this.m_motorMass * b);
            e.m_sweep.a -= e.m_invI * p;
            f.m_sweep.a += f.m_invI * p;
            e.SynchronizeTransform();
            f.SynchronizeTransform()
        }
        c = e.m_xf.R;
        p = this.m_localAnchor1.x -
            e.m_sweep.localCenter.x;
        b = this.m_localAnchor1.y - e.m_sweep.localCenter.y;
        h = c.col1.x * p + c.col2.x * b;
        b = c.col1.y * p + c.col2.y * b;
        p = h;
        c = f.m_xf.R;
        var q = this.m_localAnchor2.x - f.m_sweep.localCenter.x,
            y = this.m_localAnchor2.y - f.m_sweep.localCenter.y;
        h = c.col1.x * q + c.col2.x * y;
        y = c.col1.y * q + c.col2.y * y;
        q = h;
        l = f.m_sweep.c.x + q - e.m_sweep.c.x - p;
        m = f.m_sweep.c.y + y - e.m_sweep.c.y - b;
        var B = l * l + m * m;
        c = Math.sqrt(B);
        h = e.m_invMass;
        var H = f.m_invMass,
            E = e.m_invI,
            K = f.m_invI,
            M = 10 * a.b2_linearSlop;
        B > M * M && (B = 1 / (h + H), l = B * -l, m = B * -m, e.m_sweep.c.x -=
            .5 * h * l, e.m_sweep.c.y -= .5 * h * m, f.m_sweep.c.x += .5 * H * l, f.m_sweep.c.y += .5 * H * m, l = f.m_sweep.c.x + q - e.m_sweep.c.x - p, m = f.m_sweep.c.y + y - e.m_sweep.c.y - b);
        this.K1.col1.x = h + H;
        this.K1.col2.x = 0;
        this.K1.col1.y = 0;
        this.K1.col2.y = h + H;
        this.K2.col1.x = E * b * b;
        this.K2.col2.x = -E * p * b;
        this.K2.col1.y = -E * p * b;
        this.K2.col2.y = E * p * p;
        this.K3.col1.x = K * y * y;
        this.K3.col2.x = -K * q * y;
        this.K3.col1.y = -K * q * y;
        this.K3.col2.y = K * q * q;
        this.K.SetM(this.K1);
        this.K.AddM(this.K2);
        this.K.AddM(this.K3);
        this.K.Solve(ac.tImpulse, -l, -m);
        l = ac.tImpulse.x;
        m = ac.tImpulse.y;
        e.m_sweep.c.x -= e.m_invMass * l;
        e.m_sweep.c.y -= e.m_invMass * m;
        e.m_sweep.a -= e.m_invI * (p * m - b * l);
        f.m_sweep.c.x += f.m_invMass * l;
        f.m_sweep.c.y += f.m_invMass * m;
        f.m_sweep.a += f.m_invI * (q * m - y * l);
        e.SynchronizeTransform();
        f.SynchronizeTransform();
        return c <= a.b2_linearSlop && g <= a.b2_angularSlop
    };
    Box2D.postDefs.push(function() {
        Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new e
    });
    Box2D.inherit(bc, Box2D.Dynamics.Joints.b2JointDef);
    bc.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    bc.b2RevoluteJointDef =
        function() {
            Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
            this.localAnchorA = new e;
            this.localAnchorB = new e
        };
    bc.prototype.b2RevoluteJointDef = function() {
        this.__super.b2JointDef.call(this);
        this.type = A.e_revoluteJoint;
        this.localAnchorA.Set(0, 0);
        this.localAnchorB.Set(0, 0);
        this.motorSpeed = this.maxMotorTorque = this.upperAngle = this.lowerAngle = this.referenceAngle = 0;
        this.enableMotor = this.enableLimit = !1
    };
    bc.prototype.Initialize = function(a, b, c) {
        this.bodyA = a;
        this.bodyB = b;
        this.localAnchorA = this.bodyA.GetLocalPoint(c);
        this.localAnchorB = this.bodyB.GetLocalPoint(c);
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
    };
    Box2D.inherit(ec, Box2D.Dynamics.Joints.b2Joint);
    ec.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;
    ec.b2WeldJoint = function() {
        Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
        this.m_localAnchorA = new e;
        this.m_localAnchorB = new e;
        this.m_impulse = new f;
        this.m_mass = new b
    };
    ec.prototype.GetAnchorA = function() {
        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA)
    };
    ec.prototype.GetAnchorB =
        function() {
            return this.m_bodyB.GetWorldPoint(this.m_localAnchorB)
        };
    ec.prototype.GetReactionForce = function(a) {
        void 0 === a && (a = 0);
        return new e(a * this.m_impulse.x, a * this.m_impulse.y)
    };
    ec.prototype.GetReactionTorque = function(a) {
        void 0 === a && (a = 0);
        return a * this.m_impulse.z
    };
    ec.prototype.b2WeldJoint = function(a) {
        this.__super.b2Joint.call(this, a);
        this.m_localAnchorA.SetV(a.localAnchorA);
        this.m_localAnchorB.SetV(a.localAnchorB);
        this.m_referenceAngle = a.referenceAngle;
        this.m_impulse.SetZero();
        this.m_mass = new b
    };
    ec.prototype.InitVelocityConstraints = function(a) {
        var b, c, d = this.m_bodyA,
            e = this.m_bodyB;
        b = d.m_xf.R;
        var f = this.m_localAnchorA.x - d.m_sweep.localCenter.x,
            g = this.m_localAnchorA.y - d.m_sweep.localCenter.y;
        c = b.col1.x * f + b.col2.x * g;
        g = b.col1.y * f + b.col2.y * g;
        f = c;
        b = e.m_xf.R;
        var h = this.m_localAnchorB.x - e.m_sweep.localCenter.x,
            l = this.m_localAnchorB.y - e.m_sweep.localCenter.y;
        c = b.col1.x * h + b.col2.x * l;
        l = b.col1.y * h + b.col2.y * l;
        h = c;
        b = d.m_invMass;
        c = e.m_invMass;
        var m = d.m_invI,
            p = e.m_invI;
        this.m_mass.col1.x = b + c + g * g * m + l * l * p;
        this.m_mass.col2.x = -g * f * m - l * h * p;
        this.m_mass.col3.x = -g * m - l * p;
        this.m_mass.col1.y = this.m_mass.col2.x;
        this.m_mass.col2.y = b + c + f * f * m + h * h * p;
        this.m_mass.col3.y = f * m + h * p;
        this.m_mass.col1.z = this.m_mass.col3.x;
        this.m_mass.col2.z = this.m_mass.col3.y;
        this.m_mass.col3.z = m + p;
        a.warmStarting ? (this.m_impulse.x *= a.dtRatio, this.m_impulse.y *= a.dtRatio, this.m_impulse.z *= a.dtRatio, d.m_linearVelocity.x -= b * this.m_impulse.x, d.m_linearVelocity.y -= b * this.m_impulse.y, d.m_angularVelocity -= m * (f * this.m_impulse.y - g * this.m_impulse.x +
            this.m_impulse.z), e.m_linearVelocity.x += c * this.m_impulse.x, e.m_linearVelocity.y += c * this.m_impulse.y, e.m_angularVelocity += p * (h * this.m_impulse.y - l * this.m_impulse.x + this.m_impulse.z)) : this.m_impulse.SetZero()
    };
    ec.prototype.SolveVelocityConstraints = function() {
        var a, b, c = this.m_bodyA,
            d = this.m_bodyB,
            e = c.m_linearVelocity,
            g = c.m_angularVelocity,
            h = d.m_linearVelocity,
            l = d.m_angularVelocity,
            m = c.m_invMass,
            p = d.m_invMass,
            q = c.m_invI,
            y = d.m_invI;
        a = c.m_xf.R;
        var A = this.m_localAnchorA.x - c.m_sweep.localCenter.x,
            B = this.m_localAnchorA.y -
            c.m_sweep.localCenter.y;
        b = a.col1.x * A + a.col2.x * B;
        B = a.col1.y * A + a.col2.y * B;
        A = b;
        a = d.m_xf.R;
        var H = this.m_localAnchorB.x - d.m_sweep.localCenter.x,
            E = this.m_localAnchorB.y - d.m_sweep.localCenter.y;
        b = a.col1.x * H + a.col2.x * E;
        E = a.col1.y * H + a.col2.y * E;
        H = b;
        a = h.x - l * E - e.x + g * B;
        b = h.y + l * H - e.y - g * A;
        var K = l - g,
            M = new f;
        this.m_mass.Solve33(M, -a, -b, -K);
        this.m_impulse.Add(M);
        e.x -= m * M.x;
        e.y -= m * M.y;
        g -= q * (A * M.y - B * M.x + M.z);
        h.x += p * M.x;
        h.y += p * M.y;
        l += y * (H * M.y - E * M.x + M.z);
        c.m_angularVelocity = g;
        d.m_angularVelocity = l
    };
    ec.prototype.SolvePositionConstraints =
        function() {
            var b, c, e = this.m_bodyA,
                g = this.m_bodyB;
            b = e.m_xf.R;
            var h = this.m_localAnchorA.x - e.m_sweep.localCenter.x,
                l = this.m_localAnchorA.y - e.m_sweep.localCenter.y;
            c = b.col1.x * h + b.col2.x * l;
            l = b.col1.y * h + b.col2.y * l;
            h = c;
            b = g.m_xf.R;
            var m = this.m_localAnchorB.x - g.m_sweep.localCenter.x,
                p = this.m_localAnchorB.y - g.m_sweep.localCenter.y;
            c = b.col1.x * m + b.col2.x * p;
            p = b.col1.y * m + b.col2.y * p;
            m = c;
            b = e.m_invMass;
            c = g.m_invMass;
            var q = e.m_invI,
                y = g.m_invI,
                A = g.m_sweep.c.x + m - e.m_sweep.c.x - h,
                B = g.m_sweep.c.y + p - e.m_sweep.c.y - l,
                H = g.m_sweep.a -
                e.m_sweep.a - this.m_referenceAngle,
                E = 10 * a.b2_linearSlop,
                K = Math.sqrt(A * A + B * B),
                M = d.Abs(H);
            K > E && (q *= 1, y *= 1);
            this.m_mass.col1.x = b + c + l * l * q + p * p * y;
            this.m_mass.col2.x = -l * h * q - p * m * y;
            this.m_mass.col3.x = -l * q - p * y;
            this.m_mass.col1.y = this.m_mass.col2.x;
            this.m_mass.col2.y = b + c + h * h * q + m * m * y;
            this.m_mass.col3.y = h * q + m * y;
            this.m_mass.col1.z = this.m_mass.col3.x;
            this.m_mass.col2.z = this.m_mass.col3.y;
            this.m_mass.col3.z = q + y;
            E = new f;
            this.m_mass.Solve33(E, -A, -B, -H);
            e.m_sweep.c.x -= b * E.x;
            e.m_sweep.c.y -= b * E.y;
            e.m_sweep.a -= q * (h * E.y -
                l * E.x + E.z);
            g.m_sweep.c.x += c * E.x;
            g.m_sweep.c.y += c * E.y;
            g.m_sweep.a += y * (m * E.y - p * E.x + E.z);
            e.SynchronizeTransform();
            g.SynchronizeTransform();
            return K <= a.b2_linearSlop && M <= a.b2_angularSlop
        };
    Box2D.inherit(jc, Box2D.Dynamics.Joints.b2JointDef);
    jc.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;
    jc.b2WeldJointDef = function() {
        Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
        this.localAnchorA = new e;
        this.localAnchorB = new e
    };
    jc.prototype.b2WeldJointDef = function() {
        this.__super.b2JointDef.call(this);
        this.type = A.e_weldJoint;
        this.referenceAngle = 0
    };
    jc.prototype.Initialize = function(a, b, c) {
        this.bodyA = a;
        this.bodyB = b;
        this.localAnchorA.SetV(this.bodyA.GetLocalPoint(c));
        this.localAnchorB.SetV(this.bodyB.GetLocalPoint(c));
        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle()
    }
})();
(function() {
    var a = Box2D.Dynamics.b2DebugDraw;
    a.b2DebugDraw = function() {
        this.m_xformScale = this.m_fillAlpha = this.m_alpha = this.m_lineThickness = this.m_drawScale = 1;
        var a = this;
        this.m_sprite = {
            graphics: {
                clear: function() {
                    a.m_ctx.clearRect(0, 0, a.m_ctx.canvas.width, a.m_ctx.canvas.height)
                }
            }
        }
    };
    a.prototype._color = function(a, b) {
        return "rgba(" + ((a & 16711680) >> 16) + "," + ((a & 65280) >> 8) + "," + (a & 255) + "," + b + ")"
    };
    a.prototype.b2DebugDraw = function() {
        this.m_drawFlags = 0
    };
    a.prototype.SetFlags = function(a) {
        void 0 === a && (a = 0);
        this.m_drawFlags =
            a
    };
    a.prototype.GetFlags = function() {
        return this.m_drawFlags
    };
    a.prototype.AppendFlags = function(a) {
        void 0 === a && (a = 0);
        this.m_drawFlags |= a
    };
    a.prototype.ClearFlags = function(a) {
        void 0 === a && (a = 0);
        this.m_drawFlags &= ~a
    };
    a.prototype.SetSprite = function(a) {
        this.m_ctx = a
    };
    a.prototype.GetSprite = function() {
        return this.m_ctx
    };
    a.prototype.SetDrawScale = function(a) {
        void 0 === a && (a = 0);
        this.m_drawScale = a
    };
    a.prototype.GetDrawScale = function() {
        return this.m_drawScale
    };
    a.prototype.SetLineThickness = function(a) {
        void 0 === a && (a =
            0);
        this.m_lineThickness = a;
        this.m_ctx.strokeWidth = a
    };
    a.prototype.GetLineThickness = function() {
        return this.m_lineThickness
    };
    a.prototype.SetAlpha = function(a) {
        void 0 === a && (a = 0);
        this.m_alpha = a
    };
    a.prototype.GetAlpha = function() {
        return this.m_alpha
    };
    a.prototype.SetFillAlpha = function(a) {
        void 0 === a && (a = 0);
        this.m_fillAlpha = a
    };
    a.prototype.GetFillAlpha = function() {
        return this.m_fillAlpha
    };
    a.prototype.SetXFormScale = function(a) {
        void 0 === a && (a = 0);
        this.m_xformScale = a
    };
    a.prototype.GetXFormScale = function() {
        return this.m_xformScale
    };
    a.prototype.DrawPolygon = function(a, b, d) {
        if (b) {
            var e = this.m_ctx,
                f = this.m_drawScale;
            e.beginPath();
            e.strokeStyle = this._color(d.color, this.m_alpha);
            e.moveTo(a[0].x * f, a[0].y * f);
            for (d = 1; d < b; d++) e.lineTo(a[d].x * f, a[d].y * f);
            e.lineTo(a[0].x * f, a[0].y * f);
            e.closePath();
            e.stroke()
        }
    };
    a.prototype.DrawSolidPolygon = function(a, b, d) {
        if (b) {
            var e = this.m_ctx,
                f = this.m_drawScale;
            e.beginPath();
            e.strokeStyle = this._color(d.color, this.m_alpha);
            e.fillStyle = this._color(d.color, this.m_fillAlpha);
            e.moveTo(a[0].x * f, a[0].y * f);
            for (d =
                1; d < b; d++) e.lineTo(a[d].x * f, a[d].y * f);
            e.lineTo(a[0].x * f, a[0].y * f);
            e.closePath();
            e.fill();
            e.stroke()
        }
    };
    a.prototype.DrawCircle = function(a, b, d) {
        if (b) {
            var e = this.m_ctx,
                f = this.m_drawScale;
            e.beginPath();
            e.strokeStyle = this._color(d.color, this.m_alpha);
            e.arc(a.x * f, a.y * f, b * f, 0, 2 * Math.PI, !0);
            e.closePath();
            e.stroke()
        }
    };
    a.prototype.DrawSolidCircle = function(a, b, d, e) {
        if (b) {
            var f = this.m_ctx,
                g = this.m_drawScale,
                h = a.x * g,
                l = a.y * g;
            f.moveTo(0, 0);
            f.beginPath();
            f.strokeStyle = this._color(e.color, this.m_alpha);
            f.fillStyle =
                this._color(e.color, this.m_fillAlpha);
            f.arc(h, l, b * g, 0, 2 * Math.PI, !0);
            f.moveTo(h, l);
            f.lineTo((a.x + d.x * b) * g, (a.y + d.y * b) * g);
            f.closePath();
            f.fill();
            f.stroke()
        }
    };
    a.prototype.DrawSegment = function(a, b, d) {
        var e = this.m_ctx,
            f = this.m_drawScale;
        e.strokeStyle = this._color(d.color, this.m_alpha);
        e.beginPath();
        e.moveTo(a.x * f, a.y * f);
        e.lineTo(b.x * f, b.y * f);
        e.closePath();
        e.stroke()
    };
    a.prototype.DrawTransform = function(a) {
        var b = this.m_ctx,
            d = this.m_drawScale;
        b.beginPath();
        b.strokeStyle = this._color(16711680, this.m_alpha);
        b.moveTo(a.position.x * d, a.position.y * d);
        b.lineTo((a.position.x + this.m_xformScale * a.R.col1.x) * d, (a.position.y + this.m_xformScale * a.R.col1.y) * d);
        b.strokeStyle = this._color(65280, this.m_alpha);
        b.moveTo(a.position.x * d, a.position.y * d);
        b.lineTo((a.position.x + this.m_xformScale * a.R.col2.x) * d, (a.position.y + this.m_xformScale * a.R.col2.y) * d);
        b.closePath();
        b.stroke()
    }
})();
var i;
for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();
delete Box2D.postDefs;

function MakeNewWorld() {
    var a = Box2D.Common.Math.b2Vec2,
        c = Box2D.Dynamics.b2BodyDef,
        b = Box2D.Dynamics.b2Body,
        d = Box2D.Dynamics.b2FixtureDef,
        e = Box2D.Dynamics.b2World,
        f = Box2D.Collision.Shapes.b2PolygonShape,
        g = new a(0, -10),
        e = new e(g, !0),
        g = new f;
    g.SetAsEdge(new a(-40, 0), new a(40, 0));
    var h = new d;
    h.density = 0;
    h.shape = g;
    var l = new c;
    e.CreateBody(l).CreateFixture(h);
    g = new f;
    g.SetAsBox(.5, .5);
    for (var f = new a(-7, .75), m = new a, q = new a(.5625, 1), a = new a(1.125, 0), p = 0; 10 > p; ++p) {
        m.Set(f.x, f.y);
        for (var y = 0; 5 > y; ++y) h = new d,
            h.density = 5, h.shape = g, l = new c, l.type = b.b2_dynamicBody, l.position.Set(m.x, m.y), e.CreateBody(l).CreateFixture(h), m.Add(a);
        f.Add(q)
    }
    return e
}
var world = null,
    Box2DBenchmark = new BenchmarkSuite("Box2D", [5432788], [new Benchmark("Box2D", !1, !1, 60, runBox2D, setupBox2D, tearDownBox2D, null, 8)]);

function runBox2D() {
    for (var a = MakeNewWorld(), c = 0; 20 > c; c++) a.Step(1 / 60, 10, 3)
}

function setupBox2D() {}

function tearDownBox2D() {
    Box2D = world = null
};
////////////////////////////////////////////////////////////////////////////////
// Runner
////////////////////////////////////////////////////////////////////////////////

var success = true;

function NotifyStart(name) {}

function NotifyError(name, error) {
    WScript.Echo(name + " : ERROR : " + error.stack);
    success = false;
}

function NotifyResult(name, score) {
    if (success) {
        WScript.Echo("### SCORE:", score);
    }
}

function NotifyScore(score) {}

BenchmarkSuite.RunSuites({
    NotifyStart: NotifyStart,
    NotifyError: NotifyError,
    NotifyResult: NotifyResult,
    NotifyScore: NotifyScore
});